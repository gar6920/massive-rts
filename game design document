Game Design Document (GDD) - "Massive RTS"
1. Game Overview
1.1 Concept
"Massive RTS" is a browser-based, cooperative real-time strategy game where players each start with a single controllable "hero" unit. They collaborate to protect a shared human base while working to destroy the AI’s base. Games are fast-paced and capped at one hour, with players able to build structures and hire units that they control exclusively unless they choose to share them with teammates.
1.2 Genre
Cooperative Real-Time Strategy (RTS) with hero units and a shared base mechanic.
1.3 Target Audience
Players who enjoy teamwork-focused strategy games.

RTS fans looking for quick, intense multiplayer sessions.

1.4 Platform
Browser-based (HTML5, JavaScript), designed for desktop and mobile play.

2. Gameplay Mechanics
2.1 Core Loop
Spawn: Each player begins with a single controllable hero unit near the shared human base.

Build and Expand: Players construct buildings and hire units, which they control exclusively unless shared.

Cooperate: Players gather resources, defend the shared human base, and plan attacks on the AI base.

Combat: Use heroes, hired units, and buildings to attack the AI base while repelling AI attacks.

Endgame: The game ends when the AI base is destroyed (win), the shared human base is destroyed (loss), or the one-hour timer runs out (draw or decided by base health).

2.2 Hero Units
Starting Point: Every player starts with one hero unit, their primary controllable character.

Abilities: Heroes have unique abilities (e.g., a healing spell, a powerful attack, or a speed boost).

Respawn: If a hero dies, it respawns at the shared base after a short delay (e.g., 15-30 seconds).

2.3 Shared Human Base
Purpose: A central structure that all players must defend. It’s the team’s spawn point and a key target for the AI.

Basic Functionality: The base starts with minimal defenses and resource production, which players can enhance by contributing resources.

2.4 Buildings and Units
Buildings:
Players can construct personal buildings (e.g., barracks for units, towers for defense) near the shared base or at strategic points.

Buildings require resources and provide specific benefits (e.g., unit production, resource generation).

Units:
Players hire units from their buildings, such as infantry, archers, or siege weapons.

Units are controllable only by the player who hired them unless the player opts to share control with teammates.

2.5 Unit Sharing
Option: Players can choose to share control of their units with specific teammates or the whole team.

Control: By default, units are exclusive to the player; sharing is a deliberate action via a simple interface (e.g., a "share with team" button).

2.6 AI Opponent
Objective: The AI controls a base that players must destroy to win.

Behavior: The AI periodically sends waves of units to attack the shared human base, growing stronger as the game progresses.

Time Scaling: The AI’s difficulty ramps up within the one-hour limit to keep games challenging.

2.7 Resources
Collection: Players gather resources (e.g., gold, wood) individually through their hero or resource-generating buildings.

Usage: Resources fund personal buildings, unit hiring, and contributions to the shared base’s upgrades.

2.8 Time Limit
Duration: Games last no longer than one hour.

Resolution: If the AI base isn’t destroyed by the end, the outcome is a draw or based on remaining base health (human vs. AI).

3. World and Setting
3.1 Map
Design: The map places the shared human base and AI base at opposite ends, with resource nodes and tactical areas (e.g., chokepoints, open fields) in between.

Size Determination: The map size is dynamically determined by the number of players at the start of the match. More players result in a larger map to accommodate expanded gameplay and strategic depth, while fewer players lead to a smaller map for a more intense, fast-paced experience.

3.2 Atmosphere
A war-torn landscape where human players band together against a relentless AI enemy, emphasizing teamwork and urgency.

4. User Interface and Controls
4.1 Controls
Hero: Click-to-move with hotkeys for abilities (e.g., Q for ability 1, W for ability 2).

Units: Standard RTS commands (move, attack, hold position) for hired units.

4.2 Interface
Resource Display: Shows personal resources and contribution options for the shared base.

Base Status: Health bar and alerts for the shared human base’s condition.

Minimap: Displays the human base, AI base, heroes, and key map features.

4.3 Communication
Chat: Text chat for team coordination.

Pings: Quick markers to signal locations or threats on the map.

5. Technical Aspects
5.1 Networking
Server Role: Manages the shared base, AI actions, and player synchronization.

Unit Ownership: Tracks which player controls each unit and handles sharing permissions.

5.2 AI Logic
Attacks: The AI sends waves of units at set intervals, targeting the shared base.

Growth: AI strength increases over the hour to maintain pressure.

5.3 Optimization
Browser-Friendly: Lightweight assets and efficient unit management to ensure smooth performance.

6. Development Priorities
Hero Units:
Implement the single controllable hero per player with basic abilities and respawn mechanics.

Shared Base:
Create the human base with health, basic resource production, and upgrade options.

Buildings and Units:
Add building construction and unit hiring, ensuring units are player-specific by default.

Unit Sharing:
Develop a simple system for players to share unit control with teammates.

AI Base and Behavior:
Build the AI base and program its attack waves, scaling difficulty over one hour.

Time Limit:
Integrate a one-hour timer with clear win/loss/draw conditions.

Testing:
Test with multiple players to refine cooperative gameplay and balance the AI.



Implementation Plan:
const { Room } = require("colyseus");

class GameRoom extends Room {
  onCreate(options) {
    console.log("GameRoom created!");
  }
  onJoin(client) {
    console.log(client.sessionId, "joined!");
  }
  onLeave(client) {
    console.log(client.sessionId, "left!");
  }
}

gameServer.define("game_room", GameRoom);

Why: This creates a room type called “game_room” that handles player connections, replacing your Socket.IO rooms.

Step 4: Set Up the Game State
What to Do: Define the basic game state (like the map and players) for Colyseus to sync.

How:
In colyseusServer.js, add the Schema import and define the state:
javascript

const { Schema, type, MapSchema } = require("@colyseus/schema");

class Player extends Schema {
  @type("number") x = 0;
  @type("number") y = 0;
}

class GameState extends Schema {
  @type({ map: Player }) players = new MapSchema();
}

class GameRoom extends Room {
  onCreate(options) {
    this.setState(new GameState());
    console.log("GameRoom created!");
  }
  // Keep onJoin and onLeave as is
}

Why: The GameState holds the game data (like player positions) that Colyseus will sync to all clients.

Step 5: Add Players to the Game State
What to Do: Give each player a hero unit when they join.

How:
Update the onJoin method in GameRoom:
javascript

onJoin(client) {
  const player = new Player();
  player.x = 50; // Starting position near human base
  player.y = 50;
  this.state.players.set(client.sessionId, player);
  console.log(client.sessionId, "joined!");
}

Add to onLeave:
javascript

onLeave(client) {
  this.state.players.delete(client.sessionId);
  console.log(client.sessionId, "left!");
}

Why: This adds a hero for each player to the game state, tied to their unique session ID.

Step 6: Generate a Simple Map
What to Do: Create a basic map based on the number of players.

How:
Add a map to the GameState:
javascript

class GameState extends Schema {
  @type({ map: Player }) players = new MapSchema();
  @type(["number"]) map = [];
}

Update onCreate in GameRoom:
javascript

onCreate(options) {
  this.maxClients = options.maxPlayers || 4; // Default to 4 players
  this.setState(new GameState());

  const mapSize = this.maxClients * 10; // Simple scaling: 10 tiles per player
  for (let i = 0; i < mapSize * mapSize; i++) {
    this.state.map.push(0); // 0 = empty tile
  }
  console.log("GameRoom created with map size:", mapSize);
}

Why: This makes a square map that grows with the number of players, stored in the game state.

Step 7: Handle Player Movement
What to Do: Let players move their heroes by sending commands to the server.

How:
In GameRoom, add a message handler:
javascript

onCreate(options) {
  // Existing code...
  this.onMessage("move", (client, message) => {
    const player = this.state.players.get(client.sessionId);
    if (player) {
      player.x = message.x;
      player.y = message.y;
    }
  });
}

Why: This lets the server update a player’s hero position when they send a move command.

Step 8: Install Colyseus on the Client
What to Do: Add the Colyseus client library to your game client.

How:
In your client folder, run:
bash

npm install colyseus.js

Why: This lets your client connect to the Colyseus server instead of Socket.IO.

Step 9: Connect the Client to the Server
What to Do: Update your client to join the “game_room”.

How:
In your client code (e.g., game.js), replace Socket.IO with:
javascript

const { Client } = require("colyseus.js");
const client = new Client("ws://localhost:2567");
client.joinOrCreate("game_room").then(room => {
  console.log("Joined game room:", room.sessionId);
  window.gameRoom = room; // Save for later use
}).catch(e => {
  console.error("Join error:", e);
});

Why: This connects your client to the Colyseus server and joins the game room.

Step 10: Show the Game State on the Client
What to Do: Update your client to display the synced game state.

How:
Add a state listener in the client:
javascript

gameRoom.onStateChange((state) => {
  console.log("State updated:", state);
  // Example: Log player positions
  state.players.forEach((player, id) => {
    console.log(`Player ${id} at (${player.x}, ${player.y})`);
  });
  // Update your rendering here (e.g., move sprites)
});

Why: This keeps your client in sync with the server’s game state and lets you render it.

Step 11: Send Movement from the Client
What to Do: Let players move their heroes from the client.

How:
Add a simple move command (e.g., on key press):
javascript

document.addEventListener("keydown", (event) => {
  const player = gameRoom.state.players.get(gameRoom.sessionId);
  if (!player) return;

  if (event.key === "ArrowRight") {
    gameRoom.send("move", { x: player.x + 10, y: player.y });
  }
  if (event.key === "ArrowLeft") {
    gameRoom.send("move", { x: player.x - 10, y: player.y });
  }
});

Why: This sends movement inputs to the server, which updates the game state.

Step 12: Test It Out
What to Do: Make sure everything works so far.

How:
Start the server:
bash

node colyseusServer.js

Open two browser windows (or run two clients) and connect to the game.

Move a hero in one window and check if the other window sees it.

Why: Testing ensures players can join, see the map, and move their heroes together.

Step 13: Add More Features Later
What to Do: Build on this foundation with more GDD features.

How:
Add buildings: Send a “build” message and update the state with new entities.

Add units: Similar to heroes, create them in the state when hired.

Add AI: Run simple AI logic in GameRoom to move enemy units.

Add the timer: Track time in GameRoom and check for one hour.

Why: These steps get the basics working first, then you can add complexity gradually.

Why This Works
Easy Transition: You’re moving from Socket.IO to Colyseus one piece at a time, reusing your existing Express server.

Matches the GDD: The plan supports heroes, a scalable map, and multiplayer cooperation.

Simple Steps: Each step is small and testable, so you can see progress quickly.

Start with Step 1 and work through each one. Once you’ve got players moving heroes on a map, you’ll have a solid base to add buildings, units, AI, and the time limit. Let me know if you need help with any step!

