Massive RTS Game - Code Compilation 
Created: Sun 03/09/2025 15:14:20.61 
======================================== 
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\index.js 
======================================== 
 
import { Client } from "colyseus.js";
import { Renderer } from "./game/RendererColyseus";
import { InputHandler } from "./game/InputHandler";
import { UIManager } from "./game/UIManager";

// Create a global game instance
window.gameInstance = null;

// Initialize the game when DOM is fully loaded
document.addEventListener("DOMContentLoaded", () => {
  // Create game instance
  window.gameInstance = new Game();
  
  // Start the game
  window.gameInstance.start();
});

// Game class
class Game {
  constructor() {
    console.log("Initializing game...");
    
    // Colyseus client
    this.client = new Client("ws://localhost:2567");
    this.room = null;
    
    // Game components
    this.renderer = null;
    this.inputHandler = null;
    this.uiManager = null;
    
    // Game state
    this.playerId = null;
    this.players = new Map();
    this.buildings = new Map();
    this.units = new Map();
    this.map = [];
    this.humanBaseHealth = 1000;
    this.aiBaseHealth = 1000;
    this.gameTime = 0;
    
    // Selected entities
    this.selectedEntities = [];
  }
  
  async start() {
    console.log("Starting game...");
    
    try {
      // Initialize game components
      this.renderer = new Renderer(document.getElementById("game-canvas"));
      this.inputHandler = new InputHandler(this);
      this.uiManager = new UIManager(this);
      
      // Connect to Colyseus server
      await this.connectToServer();
      
      // Start game loop
      this.gameLoop();
    } catch (error) {
      console.error("Error starting game:", error);
    }
  }
  
  async connectToServer() {
    try {
      console.log("Connecting to server...");
      
      // Join or create a game room
      this.room = await this.client.joinOrCreate("game_room");
      
      // Store player ID
      this.playerId = this.room.sessionId;
      console.log("Connected to server with ID:", this.playerId);
      
      // Set up state change listeners
      this.setupStateListeners();
      
      // Set up other room listeners
      this.setupRoomListeners();
      
      return true;
    } catch (error) {
      console.error("Failed to connect to server:", error);
      return false;
    }
  }
  
  setupStateListeners() {
    // Listen for game state changes
    this.room.onStateChange((state) => {
      // Update local game state from server state
      this.updateGameState(state);
    });
  }
  
  setupRoomListeners() {
    // Player joined
    this.room.onMessage("player_joined", (message) => {
      console.log("Player joined:", message.id);
      // Update UI accordingly
      this.uiManager.showNotification(`Player ${message.id} joined the game.`);
    });
    
    // Player left
    this.room.onMessage("player_left", (message) => {
      console.log("Player left:", message.id);
      // Update UI accordingly
      this.uiManager.showNotification(`Player ${message.id} left the game.`);
    });
    
    // Game over
    this.room.onMessage("game_over", (message) => {
      console.log("Game over!", message);
      // Show game over screen
      this.uiManager.showGameOver(message);
    });
  }
  
  updateGameState(state) {
    // Update players
    this.players.clear();
    state.players.forEach((playerData, id) => {
      this.players.set(id, playerData);
    });
    
    // Update buildings
    this.buildings.clear();
    state.buildings.forEach((building, id) => {
      this.buildings.set(id, building);
    });
    
    // Update units
    this.units.clear();
    state.units.forEach((unit, id) => {
      this.units.set(id, unit);
    });
    
    // Update map if it has changed
    if (state.map.length !== this.map.length) {
      this.map = Array.from(state.map);
    }
    
    // Update base health
    this.humanBaseHealth = state.humanBaseHealth;
    this.aiBaseHealth = state.aiBaseHealth;
    
    // Update game time
    this.gameTime = state.gameTime;
  }
  
  gameLoop() {
    // Render the game
    this.render();
    
    // Update UI
    this.uiManager.update();
    
    // Request next frame
    requestAnimationFrame(() => this.gameLoop());
  }
  
  render() {
    // Clear canvas
    this.renderer.clear();
    
    // Render map
    this.renderer.renderMap(this.map);
    
    // Render buildings
    this.buildings.forEach(building => {
      this.renderer.renderBuilding(building);
    });
    
    // Render units
    this.units.forEach(unit => {
      this.renderer.renderUnit(unit);
    });
    
    // Render heroes
    this.players.forEach(playerData => {
      if (playerData.hero) {
        this.renderer.renderHero(playerData.hero, playerData.id === this.playerId);
      }
    });
    
    // Render selection highlight
    this.selectedEntities.forEach(entity => {
      this.renderer.renderSelection(entity);
    });
  }
  
  // Game actions
  
  moveHero(x, y) {
    // Send move hero message to server
    this.room.send("move_hero", { x, y });
  }
  
  moveUnit(unitId, x, y) {
    // Send move unit message to server
    this.room.send("move_unit", { unitId, x, y });
  }
  
  attack(unitId, targetId) {
    // Send attack message to server
    this.room.send("attack", { unitId, targetId });
  }
  
  buildStructure(buildingType, x, y) {
    // Send build message to server
    this.room.send("build", { buildingType, x, y });
  }
  
  hireUnit(unitType, buildingId) {
    // Send hire unit message to server
    this.room.send("hire_unit", { unitType, buildingId });
  }
  
  selectEntity(entity) {
    // Clear previous selection
    this.selectedEntities = [];
    
    // Add new selection
    if (entity) {
      this.selectedEntities.push(entity);
    }
    
    // Update UI with selected entity info
    this.uiManager.updateSelectionInfo(this.selectedEntities);
  }
  
  selectMultipleEntities(entities) {
    // Clear previous selection
    this.selectedEntities = [];
    
    // Add new selections
    this.selectedEntities = [...entities];
    
    // Update UI with selected entities info
    this.uiManager.updateSelectionInfo(this.selectedEntities);
  }
}

export { Game };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Building.js 
======================================== 
 
/**
 * Building class for player bases and other structures
 */
class Building extends Entity {
  /**
   * Initialize a building
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width of the building
   * @param {number} height - Height of the building
   * @param {boolean} isPlayerControlled - Whether this building is controlled by the player
   * @param {string} buildingType - Type of building (e.g., 'BASE', 'BARRACKS')
   * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
   */
  constructor(x, y, width, height, isPlayerControlled = false, buildingType = 'BASE', playerColor = 'red') {
    super(x, y, width, height, isPlayerControlled);
    
    console.log(`Creating building: ${buildingType} at (${x}, ${y}) with color ${playerColor}`);
    
    // Building type and appearance
    this.buildingType = buildingType;
    this.playerColor = playerColor;
    this.image = null;
    this.loadImage();
    
    // Apply attributes based on building type
    const attributes = Config.BUILDING_ATTRIBUTES[buildingType] || Config.BUILDING_ATTRIBUTES.BASE;
    
    // Building properties
    this.productionRate = attributes.productionRate || 0;
    this.productionType = attributes.productionType || null;
    this.productionProgress = 0;
    this.productionQueue = [];
    
    // Health and stats
    this.health = attributes.health || 500;
    this.maxHealth = attributes.health || 500;
  }
  
  /**
   * Load the building image based on player color and building type
   */
  loadImage() {
    const imagePath = `/images/buildings/${this.playerColor}_${this.buildingType.toLowerCase()}.png`;
    console.log(`Loading building image: ${imagePath}`);
    this.image = new Image();
    this.image.src = imagePath;
    this.image.onerror = (e) => {
      console.error(`Failed to load building image: ${imagePath}`, e);
      // Fallback to a colored rectangle
      console.log(`Attempting to load fallback image: /images/buildings/${this.buildingType.toLowerCase()}.png`);
      this.image.src = `/images/buildings/${this.buildingType.toLowerCase()}.png`;
    };
    this.image.onload = () => {
      console.log(`Successfully loaded building image: ${imagePath}`);
    };
  }
  
  /**
   * Set the player color for this building
   */
  setPlayerColor(color) {
    this.playerColor = color;
    this.loadImage();
  }
  
  /**
   * Update building state
   */
  update(deltaTime, game) {
    // Handle production if this building produces units
    if (this.productionRate > 0 && this.productionQueue.length > 0) {
      this.updateProduction(deltaTime, game);
    }
  }
  
  /**
   * Update production progress
   */
  updateProduction(deltaTime, game) {
    // Increase production progress
    this.productionProgress += (this.productionRate * deltaTime) / 1000;
    
    // Check if production is complete
    if (this.productionProgress >= 1) {
      this.completeProduction(game);
      this.productionProgress = 0;
    }
  }
  
  /**
   * Complete production of a unit
   */
  completeProduction(game) {
    if (this.productionQueue.length === 0) return;
    
    // Get the unit type from the queue
    const unitType = this.productionQueue.shift();
    
    // Calculate spawn position (near the building)
    const spawnX = this.x + this.width + 10;
    const spawnY = this.y + this.height / 2;
    
    // Create the unit
    const unit = new Unit(
      spawnX,
      spawnY,
      Config.UNIT_SIZE,
      Config.UNIT_SIZE,
      this.isPlayerControlled,
      unitType,
      this.playerColor
    );
    
    // Set the player ID
    unit.playerId = this.playerId;
    
    // Add the unit to the game
    game.entities.push(unit);
    
    console.log(`Building produced a ${unitType}`);
  }
  
  /**
   * Queue a unit for production
   */
  queueUnit(unitType) {
    this.productionQueue.push(unitType);
    console.log(`Added ${unitType} to production queue`);
  }
  
  /**
   * Take damage from an attacker
   */
  takeDamage(amount, attacker) {
    this.health -= amount;
    console.log(`Building took ${amount} damage, health: ${this.health}`);
    
    // If health drops to 0 or below, destroy the building
    if (this.health <= 0) {
      this.die();
    }
  }
  
  /**
   * Handle building destruction
   */
  die() {
    console.log('Building destroyed');
    // In a real implementation, we would remove the building from the game
    // and possibly play a destruction animation
  }
  
  /**
   * Convert building to a network-friendly format
   */
  toNetworkData() {
    const data = super.toNetworkData();
    return {
      ...data,
      buildingType: this.buildingType,
      playerColor: this.playerColor,
      productionRate: this.productionRate,
      productionType: this.productionType,
      productionProgress: this.productionProgress,
      productionQueue: this.productionQueue
    };
  }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Entity.js 
======================================== 
 
/**
 * Base class for all game entities (units, buildings, etc.)
 */
class Entity {
    /**
     * Initialize an entity
     */
    constructor(x, y, width, height, isPlayerControlled = false) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.isPlayerControlled = isPlayerControlled;
        this.isSelected = false;
        this.health = 100;
        this.maxHealth = 100;
        
        // Multiplayer properties
        this.id = null; // Server-assigned ID
        this.playerId = null; // ID of the player who owns this entity
        this.serverX = null; // Position from server for interpolation
        this.serverY = null; // Position from server for interpolation
    }
    
    /**
     * Update entity state
     */
    update(deltaTime, game) {
        // Base entity doesn't do anything in update
        // This method should be overridden by subclasses
    }
    
    /**
     * Check if this entity collides with another entity
     */
    collidesWith(otherEntity) {
        return (
            this.x < otherEntity.x + otherEntity.width &&
            this.x + this.width > otherEntity.x &&
            this.y < otherEntity.y + otherEntity.height &&
            this.y + this.height > otherEntity.y
        );
    }
    
    /**
     * Check if this entity contains a point
     */
    containsPoint(x, y) {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
    
    /**
     * Take damage
     */
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0;
            this.die();
        }
    }
    
    /**
     * Entity death
     */
    die() {
        // This method should be overridden by subclasses
        console.log('Entity died');
    }
    
    /**
     * Get the center position of the entity
     */
    getCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    
    /**
     * Calculate distance to another entity or point
     */
    distanceTo(target) {
        let targetX, targetY;
        
        if (target instanceof Entity) {
            const targetCenter = target.getCenter();
            targetX = targetCenter.x;
            targetY = targetCenter.y;
        } else {
            targetX = target.x;
            targetY = target.y;
        }
        
        const center = this.getCenter();
        const dx = targetX - center.x;
        const dy = targetY - center.y;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Convert entity to a network-friendly format
     */
    toNetworkData() {
        return {
            id: this.id,
            type: this.constructor.name.toLowerCase(),
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            health: this.health,
            playerId: this.playerId,
            isPlayerControlled: this.isPlayerControlled
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Unit.js 
======================================== 
 
/**
 * Unit class for player and AI controlled units
 */
class Unit extends Entity {
    /**
     * Initialize a unit
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width of the unit
     * @param {number} height - Height of the unit
     * @param {boolean} isPlayerControlled - Whether this unit is controlled by the player
     * @param {string} unitType - Type of unit (e.g., 'SOLDIER')
     * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
     */
    constructor(x, y, width, height, isPlayerControlled = false, unitType = 'SOLDIER', playerColor = 'red') {
        super(x, y, width, height, isPlayerControlled);
        
        // Unit type and appearance
        this.unitType = unitType;
        this.playerColor = playerColor;
        this.image = null;
        this.loadImage();
        
        // Apply attributes based on unit type
        const attributes = Config.UNIT_ATTRIBUTES[unitType] || Config.UNIT_ATTRIBUTES.SOLDIER;
        
        // Movement properties
        this.speed = attributes.speed || Config.UNIT_SPEED;
        this.targetX = null;
        this.targetY = null;
        this.isMoving = false;
        
        // Combat properties
        this.attackRange = attributes.attackRange || 50;
        this.attackDamage = attributes.attackDamage || 10;
        this.attackCooldown = attributes.attackCooldown || 1000; // ms
        this.lastAttackTime = 0;
        this.targetEntity = null;
        
        // Health and stats
        this.health = attributes.health || 100;
        this.maxHealth = attributes.health || 100;
        this.level = 1;
        this.experience = 0;
        
        // Animation properties
        this.isAttacking = false;
        this.attackAnimationTime = null;
        this.attackAnimationDuration = 500; // Animation lasts 500ms
        this.isDestroyed = false;
        this.deathAnimationTime = null;
        this.deathAnimationDuration = 1000; // Animation lasts 1 second
    }
    
    /**
     * Load the unit image based on player color and unit type
     */
    loadImage() {
        const imagePath = `/images/units/${this.playerColor}_${this.unitType.toLowerCase()}.png`;
        console.log(`Loading unit image: ${imagePath}`);
        this.image = new Image();
        this.image.src = imagePath;
        this.image.onerror = () => {
            console.error(`Failed to load unit image: ${imagePath}`);
            // Fallback to default image if available
            console.log(`Attempting to load fallback image: /images/units/${this.unitType.toLowerCase()}.png`);
            this.image.src = `/images/units/${this.unitType.toLowerCase()}.png`;
        };
    }
    
    /**
     * Set the player color for this unit
     */
    setPlayerColor(color) {
        this.playerColor = color;
        this.loadImage();
    }
    
    /**
     * Update unit state
     */
    update(deltaTime, game) {
        if (this.isDestroyed) {
            // Ensure no further interpolation or position updates
            this.isMoving = false;
            this.targetX = null;
            this.targetY = null;
            return; 
        }

        if (this.serverX === undefined && this.isMoving && this.targetX !== null && this.targetY !== null) {
            this.moveTowardsTarget(deltaTime);
        }

        if (this.targetEntity) {
            this.updateCombat(deltaTime, game);
        }

        if (this.isAttacking && this.attackAnimationTime) {
            this.updateAttackAnimation(deltaTime);
        }
    }
    
    /**
     * Move towards the target position
     */
    moveTowardsTarget(deltaTime) {
        // Calculate direction to target
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If we're close enough to the target, stop moving
        if (distance < 1) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.isMoving = false;
            this.targetX = null;
            this.targetY = null;
            return;
        }
        
        // Normalize direction and apply speed
        const moveSpeed = Config.UNIT_SPEED * (deltaTime / 1000);
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;
        
        // Calculate new position
        const newX = this.x + normalizedDx * moveSpeed;
        const newY = this.y + normalizedDy * moveSpeed;
        
        // Ensure the unit stays within map boundaries
        const mapWidth = Config.MAP_WIDTH * Config.TILE_SIZE;
        const mapHeight = Config.MAP_HEIGHT * Config.TILE_SIZE;
        
        this.x = Math.max(0, Math.min(newX, mapWidth - this.width));
        this.y = Math.max(0, Math.min(newY, mapHeight - this.height));
    }
    
    /**
     * Set a movement target
     */
    setTarget(x, y) {
        this.targetX = x;
        this.targetY = y;
        this.isMoving = true;
    }
    
    /**
     * Update combat state
     */
    updateCombat(deltaTime, game) {
        if (!this.targetEntity || this.targetEntity.isDestroyed) {
            this.targetEntity = null;
            this.isAttacking = false;
            this.isMoving = false;  // Immediately stop moving towards a dead target
            this.targetX = null;
            this.targetY = null;
            return;
        }
        
        // Calculate distance to target
        const center = this.getCenter();
        const targetCenter = this.targetEntity.getCenter();
        const dx = targetCenter.x - center.x;
        const dy = targetCenter.y - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If target is out of range, move towards it
        if (distance > this.attackRange) {
            // Update the target position to follow the moving target
            this.setTarget(targetCenter.x, targetCenter.y);
            // Maintain the attacking state even when moving toward the target
            this.isAttacking = true;
            return;
        }
        
        // If we're in range and attack cooldown is over, attack
        const now = Date.now();
        if (now - this.lastAttackTime >= this.attackCooldown) {
            this.attack(this.targetEntity);
            this.lastAttackTime = now;
        }
    }
    
    /**
     * Attack a target entity
     */
    attack(target) {
        console.log(`Unit attacking target for ${this.attackDamage} damage`);
        target.takeDamage(this.attackDamage, this);
        this.performAttackAnimation();
    }
    
    /**
     * Take damage from an attacker
     */
    takeDamage(amount, attacker) {
        if (this.isDestroyed) return; // Prevent further damage after death

        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0; // Never negative
            this.die();

            if (attacker instanceof Unit) {
                attacker.gainExperience(this.level * 10);
            }
        }
    }
    
    /**
     * Gain experience points
     */
    gainExperience(amount) {
        this.experience += amount;
        console.log(`Unit gained ${amount} experience, total: ${this.experience}`);
        
        // Check for level up (simple formula: 100 * current level)
        const experienceNeeded = this.level * 100;
        if (this.experience >= experienceNeeded) {
            this.levelUp();
        }
    }
    
    /**
     * Level up the unit
     */
    levelUp() {
        this.level++;
        this.experience = 0;
        
        // Increase stats
        this.maxHealth += 20;
        this.health = this.maxHealth;
        this.attackDamage += 5;
        
        console.log(`Unit leveled up to level ${this.level}`);
    }
    
    /**
     * Handle unit death
     */
    die() {
        if (this.isDestroyed) return;
        this.isDestroyed = true;
        this.health = 0;                  // Health immediately zero, no negatives
        this.isMoving = false;            // Immediately stop movement
        this.targetEntity = null;         // Clear combat target
        this.targetX = null;              // Clear positional target
        this.targetY = null;
        this.isSelectable = false;        // Disable selection
        this.deathAnimationTime = Date.now(); // Start death timestamp
    }
    
    /**
     * Convert unit to a network-friendly format
     */
    toNetworkData() {
        const data = super.toNetworkData();
        return {
            ...data,
            unitType: this.unitType,
            playerColor: this.playerColor,
            speed: this.speed,
            attackRange: this.attackRange,
            attackDamage: this.attackDamage,
            attackCooldown: this.attackCooldown,
            level: this.level,
            experience: this.experience,
            targetX: this.targetX,
            targetY: this.targetY,
            isMoving: this.isMoving,
            isAttacking: this.isAttacking,
            attackAnimationTime: this.attackAnimationTime,
            attackAnimationDuration: this.attackAnimationDuration,
            isDestroyed: this.isDestroyed,
            deathAnimationTime: this.deathAnimationTime,
            deathAnimationDuration: this.deathAnimationDuration
        };
    }
    
    /**
     * Perform attack animation
     */
    performAttackAnimation() {
        this.isAttacking = true;
        this.attackAnimationTime = Date.now();
        this.attackAnimationDuration = 500; // Animation lasts 500ms
    }
    
    /**
     * Update attack animation
     */
    updateAttackAnimation(deltaTime) {
        const now = Date.now();
        const elapsed = now - this.attackAnimationTime;
        
        if (elapsed >= this.attackAnimationDuration) {
            // Animation complete
            this.attackAnimationTime = null;
        }
    }
    
    /**
     * Render the unit
     */
    render(ctx, camera) {
        // Convert unit's cartesian position to isometric
        const isoX = (this.x - this.y) / 2;
        const isoY = (this.x + this.y) / 4;

        const screenPos = camera.worldToScreen(isoX, isoY);

        // Draw selection indicator if selected
        if (this.isSelected) {
            ctx.beginPath();
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 2;
            ctx.arc(
                screenPos.x,
                screenPos.y,
                this.width / 1.5,
                0,
                Math.PI * 2
            );
            ctx.stroke();
        }

        // Draw attack indicator if attacking
        if (this.isAttacking && this.attackAnimationTime) {
            const elapsed = Date.now() - this.attackAnimationTime;
            const progress = Math.min(1, elapsed / this.attackAnimationDuration);
            
            ctx.beginPath();
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2 * (1 - progress);
            ctx.arc(
                screenPos.x,
                screenPos.y,
                this.width / 1.2 * (1 + progress * 0.5),
                0,
                Math.PI * 2
            );
            ctx.stroke();
        }

        // Draw the unit normally
        if (this.image && this.image.complete) {
            ctx.drawImage(
                this.image,
                screenPos.x - this.width / 2,
                screenPos.y - this.height / 2,
                this.width,
                this.height
            );
        } else {
            ctx.fillStyle = this.playerColor || 'blue';
            ctx.fillRect(screenPos.x - this.width / 2, screenPos.y - this.height / 2, this.width, this.height);
        }

        // Health bar only when alive
        if (this.health > 0) {
            this.renderHealthBar(ctx, screenPos);
        }

        // Red "X" when destroyed, properly isometric
        if (this.isDestroyed) {
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(screenPos.x - this.width / 2, screenPos.y - this.height / 2);
            ctx.lineTo(screenPos.x + this.width / 2, screenPos.y + this.height / 2);
            ctx.moveTo(screenPos.x + this.width / 2, screenPos.y - this.height / 2);
            ctx.lineTo(screenPos.x - this.width / 2, screenPos.y + this.height / 2);
            ctx.stroke();

            if (Date.now() - this.deathAnimationTime >= 3000) {
                this.markForRemoval = true;
            }
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\BuildingImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing building images
 */
class BuildingImageLoader {
    /**
     * Initialize the building image loader
     */
    constructor() {
        // Building types
        this.buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];
        
        // Player colors
        this.playerColors = ['red', 'blue', 'green', 'yellow'];
        
        // Store loaded images
        this.images = {};
        
        // Load all building images
        this.loadBuildingImages();
        
        console.log('BuildingImageLoader initialized');
    }
    
    /**
     * Load all building images
     */
    loadBuildingImages() {
        // Load default building images
        this.buildingTypes.forEach(buildingType => {
            const img = new Image();
            img.src = `/images/buildings/${buildingType.toLowerCase()}.png`;
            this.images[buildingType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded building image: ${buildingType}`);
            img.onerror = () => console.warn(`Failed to load building image: ${buildingType}`);
            
            // Load player-colored variants
            this.playerColors.forEach(color => {
                const coloredImg = new Image();
                coloredImg.src = `/images/buildings/${buildingType.toLowerCase()}_${color}.png`;
                this.images[`${buildingType}_${color}`] = coloredImg;
                
                // Log when image loads or fails
                coloredImg.onload = () => console.log(`Loaded building image: ${buildingType}_${color}`);
                coloredImg.onerror = () => console.warn(`Failed to load building image: ${buildingType}_${color}`);
            });
        });
    }
    
    /**
     * Get the image for a specific building type and player color
     */
    getBuildingImage(buildingType, playerColor = null) {
        if (playerColor) {
            const coloredImage = this.images[`${buildingType}_${playerColor}`];
            if (coloredImage) return coloredImage;
        }
        
        return this.images[buildingType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Camera.js 
======================================== 
 
/**
 * Camera class for handling viewport and map navigation
 */
class Camera {
    /**
     * Initialize the camera
     */
    constructor() {
        // Camera position (top-left corner of the viewport in world coordinates)
        this.x = 0;
        this.y = 0;
        
        // Camera dimensions (viewport size)
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Camera zoom level
        this.zoom = Config.ZOOM_DEFAULT;
        
        // Calculate initial boundaries based on current map dimensions
        this.updateBoundaries();
        
        // We'll center on player units later when they're created
        // Don't call centerOnMap() here
        
        console.log(`Camera initialized at position (${this.x}, ${this.y}) with zoom ${this.zoom}`);
    }

    /**
     * Center the camera on the map
     */
    centerOnMap() {
        // Calculate the map dimensions in isometric coordinates
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the isometric map width and height
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set camera position to center on the map
        this.x = isoCenterX - (viewportWorldWidth / 2);
        this.y = isoCenterY - (viewportWorldHeight / 2);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Camera centered on map at (${this.x.toFixed(2)}, ${this.y.toFixed(2)})`);
    }

    /**
     * Update camera boundaries based on current map dimensions
     */
    updateBoundaries() {
        // For isometric view, we need to calculate boundaries differently
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the width and height of the isometric map in world coordinates
        // In isometric view, the map width is (mapWidth + mapHeight) * tileSize / 2
        // and the map height is (mapWidth + mapHeight) * tileSize / 4
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Calculate maximum camera positions
        // We need to ensure the camera can't move so far that the map is off-screen
        // For isometric maps, we need more generous boundaries
        const extraPadding = Math.max(viewportWorldWidth, viewportWorldHeight) * 0.5;
        
        // Set more balanced boundaries
        // The key is to make the boundaries symmetrical around the map center
        this.maxX = isoCenterX + isoMapWidth/2 + extraPadding;
        this.maxY = isoCenterY + isoMapHeight/2 + extraPadding;
        this.minX = isoCenterX - isoMapWidth/2 - extraPadding;
        this.minY = isoCenterY - isoMapHeight/2 - extraPadding;
        
        console.log(`Camera boundaries updated: minX=${this.minX}, minY=${this.minY}, maxX=${this.maxX}, maxY=${this.maxY}`);
    }

    /**
     * Move the camera by the specified delta
     */
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.clampPosition();
    }

    /**
     * Set the camera position directly
     */
    setPosition(x, y) {
        this.x = x;
        this.y = y;
        this.clampPosition();
    }

    /**
     * Center the camera on a specific world position
     */
    centerOn(worldX, worldY) {
        // Calculate the position to center the camera on the given world coordinates
        this.x = worldX - (this.width / this.zoom / 2);
        this.y = worldY - (this.height / this.zoom / 2);
        
        // Ensure camera stays within map boundaries
        this.clampPosition();
    }

    /**
     * Ensure camera stays within map boundaries
     */
    clampPosition() {
        // For isometric view, we need to allow the camera to go slightly outside the map boundaries
        // to ensure the entire map is visible
        
        // Calculate the effective maximum positions based on viewport size
        // This ensures we can see the bottom of the map
        const viewportWidth = this.width / this.zoom;
        const viewportHeight = this.height / this.zoom;
        
        // Calculate effective boundaries
        // For the max boundaries, we need to subtract the viewport size to ensure
        // we can pan all the way to the bottom/right edges
        const effectiveMinX = this.minX;
        const effectiveMinY = this.minY;
        const effectiveMaxX = Math.max(0, this.maxX - viewportWidth);
        const effectiveMaxY = Math.max(0, this.maxY - viewportHeight);
        
        // Clamp camera position to stay within map boundaries
        this.x = Math.max(effectiveMinX, Math.min(this.x, effectiveMaxX));
        this.y = Math.max(effectiveMinY, Math.min(this.y, effectiveMaxY));
        
        console.log(`Camera position clamped to (${this.x}, ${this.y})`);
    }

    /**
     * Convert world coordinates to screen coordinates
     */
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }

    /**
     * Convert screen coordinates to world coordinates
     */
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX / this.zoom) + this.x,
            y: (screenY / this.zoom) + this.y
        };
    }

    /**
     * Check if a world position is visible on screen
     */
    isVisible(worldX, worldY, width, height) {
        // For units, convert Cartesian coordinates to isometric before checking visibility
        const isoX = (worldX - worldY) / 2;
        const isoY = (worldX + worldY) / 4;
        
        // Use a larger bounding box for visibility check to account for isometric conversion
        const boundingWidth = Math.max(width, height) * 2;
        const boundingHeight = Math.max(width, height) * 2;
        
        return (
            isoX + boundingWidth > this.x &&
            isoX - boundingWidth < this.x + (this.width / this.zoom) &&
            isoY + boundingHeight > this.y &&
            isoY - boundingHeight < this.y + (this.height / this.zoom)
        );
    }

    /**
     * Update camera dimensions when window is resized or map dimensions change
     */
    updateDimensions() {
        // Update viewport dimensions
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Update boundaries based on current map dimensions
        this.updateBoundaries();
        
        // Ensure camera position is still valid
        this.clampPosition();
        
        console.log(`Camera dimensions updated: width=${this.width}, height=${this.height}, map=${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
    }

    /**
     * Zoom at a specific point (mouse position)
     * @param {number} deltaZoom - Amount to change zoom by
     * @param {number} clientX - Mouse X position in screen coordinates
     * @param {number} clientY - Mouse Y position in screen coordinates
     */
    zoomAt(deltaZoom, clientX, clientY) {
        // Store the world point that we're zooming at
        const worldPoint = this.screenToWorld(clientX, clientY);
        const worldX = worldPoint.x;
        const worldY = worldPoint.y;
        
        // Store the old zoom value
        const oldZoom = this.zoom;
        
        // Update zoom level with constraints
        this.zoom += deltaZoom;
        this.zoom = Math.max(Config.ZOOM_MIN, Math.min(Config.ZOOM_MAX, this.zoom));
        
        // If zoom didn't actually change, exit early
        if (this.zoom === oldZoom) return;
        
        // Calculate new camera position to keep the mouse point fixed in world space
        const mouseXRatio = clientX / this.width;
        const mouseYRatio = clientY / this.height;
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set the new camera position
        this.x = worldX - (mouseXRatio * viewportWorldWidth);
        this.y = worldY - (mouseYRatio * viewportWorldHeight);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Zoomed to ${this.zoom.toFixed(2)} at world point (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
    }

    /**
     * Center the camera on player units
     * @param {Array} entities - All game entities
     * @param {string} playerId - The current player's ID
     */
    centerOnPlayerUnits(entities, playerId) {
        if (!entities || entities.length === 0) {
            console.log("No entities to center on, centering on map instead");
            this.centerOnMap();
            return;
        }
        
        // Find player-controlled units
        const playerUnits = entities.filter(entity => 
            entity.playerId === playerId && 
            entity.type === 'UNIT'
        );
        
        // If no player units found, try to find player base
        if (playerUnits.length === 0) {
            const playerBase = entities.find(entity => 
                entity.playerId === playerId && 
                entity.type === 'BUILDING' && 
                entity.buildingType === 'BASE'
            );
            
            if (playerBase) {
                console.log(`Centering camera on player base at (${playerBase.x}, ${playerBase.y})`);
                this.centerOn(playerBase.x + playerBase.width/2, playerBase.y + playerBase.height/2);
                
                // Zoom in a bit to focus on the base
                this.zoom = Config.ZOOM_DEFAULT * 1.2;
                this.clampPosition();
                return;
            }
        } else {
            // Calculate average position of all player units
            let avgX = 0;
            let avgY = 0;
            
            playerUnits.forEach(unit => {
                avgX += unit.x;
                avgY += unit.y;
            });
            
            avgX /= playerUnits.length;
            avgY /= playerUnits.length;
            
            console.log(`Centering camera on ${playerUnits.length} player units at (${avgX}, ${avgY})`);
            this.centerOn(avgX, avgY);
            
            // Zoom in a bit to focus on the units
            this.zoom = Config.ZOOM_DEFAULT * 1.2;
            this.clampPosition();
            return;
        }
        
        // Fallback to centering on map if no player entities found
        console.log("No player entities found, centering on map instead");
        this.centerOnMap();
    }

    /**
     * Get the bounding box for the current viewport in world coordinates
     * Used for quadtree queries
     * @returns {Object} - {x, y, width, height}
     */
    getBoundingBox() {
        // Get viewport dimensions in world coordinates
        const viewportWidth = this.width / this.zoom;
        const viewportHeight = this.height / this.zoom;
        
        // Add a buffer around the viewport to ensure we get entities that are partially visible
        // This is especially important for isometric rendering where entities might be visible
        // outside the strict viewport boundaries
        const buffer = Math.max(viewportWidth, viewportHeight) * 0.2;
        
        return {
            x: this.x - buffer,
            y: this.y - buffer,
            width: viewportWidth + buffer * 2,
            height: viewportHeight + buffer * 2
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Config.js 
======================================== 
 
/**
 * Game configuration constants
 */
class Config {
    // Canvas and rendering
    static CANVAS_WIDTH = window.innerWidth;
    static CANVAS_HEIGHT = window.innerHeight;
    
    // Map settings
    static MAP_WIDTH = 100; // Number of tiles horizontally
    static MAP_HEIGHT = 100; // Number of tiles vertically
    static TILE_SIZE = 64; // Size of each tile in pixels - increased for better isometric rendering
    
    // Camera settings
    static CAMERA_SPEED = 10; // Camera movement speed
    static CAMERA_EDGE_THRESHOLD = 50; // Pixels from edge to trigger camera movement
    static ZOOM_MIN = 0.5; // Minimum zoom level (50%)
    static ZOOM_MAX = 2.0; // Maximum zoom level (200%)
    static ZOOM_SPEED = 0.1; // How much to zoom per mouse wheel tick
    static ZOOM_DEFAULT = 1.2; // Default zoom level - increased for a more detailed view
    
    // Unit settings
    static UNIT_SPEED = 2; // Movement speed of units
    static UNIT_SIZE = 32; // Size of units in pixels
    static UNIT_ATTRIBUTES = {
        SOLDIER: {
            health: 100,
            attackDamage: 10,
            attackRange: 50,
            attackCooldown: 1000,
            speed: 2
        }
    };
    
    // Building settings
    static BUILDING_ATTRIBUTES = {
        BASE: {
            health: 1000,
            productionRate: 0.1, // Units per second
            productionType: 'SOLDIER'
        },
        BARRACKS: {
            health: 500,
            productionRate: 0.2,
            productionType: 'SOLDIER'
        }
    };
    
    // Player settings
    static PLAYER_COLORS = [
        'red',
        'blue',
        'green',
        'yellow'
    ];
    
    // Colors
    static COLORS = {
        GRASS: '#3a8c3a',
        WATER: '#4286f4',
        SAND: '#e6d56e',
        MOUNTAIN: '#7a7a7a',
        FOREST: '#1f5e1f',
        PLAYER_UNIT: '#0000ff',
        ENEMY_UNIT: '#ff0000',
        SELECTION: '#ffffff',
        GRID: 'rgba(0, 0, 0, 0.2)'
    };
    
    // Debug settings
    static DEBUG_MODE = true; // Enable/disable debug information
    static SHOW_GRID = false; // Show grid lines
    
    // Update the canvas dimensions when the window is resized
    static updateDimensions() {
        this.CANVAS_WIDTH = window.innerWidth;
        this.CANVAS_HEIGHT = window.innerHeight;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Game.js 
======================================== 
 
// This file is now replaced by the Game class in src/index.js
// Keeping this file for backward compatibility but it forwards to the new Game class

import { Game as NewGame } from '../index';

// Export the same Game class from index.js
export const Game = NewGame;  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\InputHandler.js 
======================================== 
 
/**
 * Handles all user input (mouse, keyboard) for the game
 */
class InputHandler {
    /**
     * Initialize the input handler
     * @param {Game} game - The main game instance
     */
    constructor(game) {
        this.game = game;
        
        // Keyboard state
        this.keys = {
            up: false,
            down: false,
            left: false,
            right: false,
            shift: false
        };
        
        // Mouse state
        this.mouse = {
            x: 0,
            y: 0,
            leftDown: false,
            rightDown: false,
            dragStart: null,
            dragging: false
        };
        
        // Selection box
        this.selectionBox = null;
        
        // Camera movement speed
        this.cameraSpeed = 10;
        
        // Input enabled flag
        this.inputEnabled = true;
        
        // Setup event listeners
        this.setupEventListeners();
    }
    
    /**
     * Set up event listeners for user input
     */
    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', (e) => this.handleKeyDown(e));
        window.addEventListener('keyup', (e) => this.handleKeyUp(e));
        
        // Mouse events
        const canvas = this.game.renderer.canvas;
        canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        canvas.addEventListener('wheel', (e) => this.handleMouseWheel(e));
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            this.handleRightClick(e);
        });
        
        // Window resize
        window.addEventListener('resize', () => this.handleResize());
    }
    
    /**
     * Handle keydown events
     * @param {KeyboardEvent} e - Keyboard event
     */
    handleKeyDown(e) {
        if (!this.inputEnabled) return;
        
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
                this.keys.up = true;
                break;
            case 'ArrowDown':
            case 's':
                this.keys.down = true;
                break;
            case 'ArrowLeft':
            case 'a':
                this.keys.left = true;
                break;
            case 'ArrowRight':
            case 'd':
                this.keys.right = true;
                break;
            case 'Shift':
                this.keys.shift = true;
                break;
        }
    }
    
    /**
     * Handle keyup events
     * @param {KeyboardEvent} e - Keyboard event
     */
    handleKeyUp(e) {
        switch (e.key) {
            case 'ArrowUp':
            case 'w':
                this.keys.up = false;
                break;
            case 'ArrowDown':
            case 's':
                this.keys.down = false;
                break;
            case 'ArrowLeft':
            case 'a':
                this.keys.left = false;
                break;
            case 'ArrowRight':
            case 'd':
                this.keys.right = false;
                break;
            case 'Shift':
                this.keys.shift = false;
                break;
        }
    }
    
    /**
     * Handle mousedown events
     * @param {MouseEvent} e - Mouse event
     */
    handleMouseDown(e) {
        if (!this.inputEnabled) return;
        
        // Get mouse position relative to canvas
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Store mouse state
        this.mouse.x = x;
        this.mouse.y = y;
        
        // Handle different mouse buttons
        if (e.button === 0) { // Left click
            this.mouse.leftDown = true;
            this.mouse.dragStart = { x, y };
            
            // If not holding shift, clear selection for new selection
            if (!this.keys.shift) {
                this.game.selectEntity(null);
            }
        } else if (e.button === 2) { // Right click
            this.mouse.rightDown = true;
            
            // Right click is handled in context menu event to prevent the default menu
        }
    }
    
    /**
     * Handle mouseup events
     * @param {MouseEvent} e - Mouse event
     */
    handleMouseUp(e) {
        // Get mouse position relative to canvas
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Handle different mouse buttons
        if (e.button === 0) { // Left click
            this.mouse.leftDown = false;
            
            // If dragging, handle selection box
            if (this.mouse.dragging) {
                this.handleSelectionBox();
            } else {
                // Single click selection
                const gridPos = this.game.renderer.screenToGrid(x, y);
                this.handleSelectionClick(gridPos);
            }
            
            // Reset dragging state
            this.mouse.dragging = false;
            this.mouse.dragStart = null;
            this.selectionBox = null;
        } else if (e.button === 2) { // Right click
            this.mouse.rightDown = false;
        }
    }
    
    /**
     * Handle selection box selection
     */
    handleSelectionBox() {
        if (!this.selectionBox) return;
        
        // Convert selection box to grid coordinates
        const topLeft = this.game.renderer.screenToGrid(this.selectionBox.x, this.selectionBox.y);
        const bottomRight = this.game.renderer.screenToGrid(
            this.selectionBox.x + this.selectionBox.width,
            this.selectionBox.y + this.selectionBox.height
        );
        
        // Find entities in selection box
        const selectedEntities = [];
        
        // Check units
        this.game.units.forEach(unit => {
            if (unit.owner === this.game.playerId) {
                const pos = unit.position;
                if (pos.x >= topLeft.x && pos.x <= bottomRight.x &&
                    pos.y >= topLeft.y && pos.y <= bottomRight.y) {
                    selectedEntities.push(unit);
                }
            }
        });
        
        // If entities are found, select them
        if (selectedEntities.length > 0) {
            this.game.selectMultipleEntities(selectedEntities);
        }
    }
    
    /**
     * Handle mousemove events
     * @param {MouseEvent} e - Mouse event
     */
    handleMouseMove(e) {
        // Get mouse position relative to canvas
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Update mouse position
        this.mouse.x = x;
        this.mouse.y = y;
        
        // Check if dragging with left mouse button
        if (this.mouse.leftDown && this.mouse.dragStart) {
            // Set dragging flag
            this.mouse.dragging = true;
            
            // Calculate selection box
            this.selectionBox = {
                x: Math.min(this.mouse.dragStart.x, x),
                y: Math.min(this.mouse.dragStart.y, y),
                width: Math.abs(x - this.mouse.dragStart.x),
                height: Math.abs(y - this.mouse.dragStart.y)
            };
        }
        
        // Screen edge camera panning
        const edgeSize = 50;
        if (x < edgeSize) {
            this.game.renderer.panCamera(-this.cameraSpeed, 0);
        } else if (x > this.game.renderer.canvas.width - edgeSize) {
            this.game.renderer.panCamera(this.cameraSpeed, 0);
        }
        
        if (y < edgeSize) {
            this.game.renderer.panCamera(0, -this.cameraSpeed);
        } else if (y > this.game.renderer.canvas.height - edgeSize) {
            this.game.renderer.panCamera(0, this.cameraSpeed);
        }
    }
    
    /**
     * Handle mousewheel events
     * @param {WheelEvent} e - Wheel event
     */
    handleMouseWheel(e) {
        if (!this.inputEnabled) return;
        
        // Prevent default scrolling
        e.preventDefault();
        
        // Adjust zoom level
        const delta = e.deltaY > 0 ? -0.1 : 0.1;
        this.game.renderer.adjustZoom(delta);
    }
    
    /**
     * Handle right-click events
     * @param {MouseEvent} e - Mouse event
     */
    handleRightClick(e) {
        if (!this.inputEnabled) return;
        
        // Get mouse position relative to canvas
        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Convert screen position to grid position
        const gridPos = this.game.renderer.screenToGrid(x, y);
        
        // Check for selected entities
        if (this.game.selectedEntities.length > 0) {
            // Check if clicking on an enemy entity (for attack)
            const targetEntity = this.findEntityAtPosition(gridPos);
            
            if (targetEntity && targetEntity.owner !== this.game.playerId) {
                // Attack the target
                this.game.selectedEntities.forEach(entity => {
                    if (entity.id !== this.game.players.get(this.game.playerId).hero.id) {
                        this.game.attack(entity.id, targetEntity.id);
                    }
                });
            } else {
                // Move to position
                this.game.selectedEntities.forEach(entity => {
                    if (entity.id === this.game.players.get(this.game.playerId).hero.id) {
                        // Move hero
                        this.game.moveHero(gridPos.x, gridPos.y);
                    } else {
                        // Move unit
                        this.game.moveUnit(entity.id, gridPos.x, gridPos.y);
                    }
                });
            }
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        // Update canvas size in renderer
        this.game.renderer.handleResize();
    }
    
    /**
     * Update camera position based on keyboard input
     */
    updateCameraFromKeys() {
        if (!this.inputEnabled) return;
        
        let dx = 0;
        let dy = 0;
        
        if (this.keys.up) dy -= this.cameraSpeed;
        if (this.keys.down) dy += this.cameraSpeed;
        if (this.keys.left) dx -= this.cameraSpeed;
        if (this.keys.right) dx += this.cameraSpeed;
        
        if (dx !== 0 || dy !== 0) {
            this.game.renderer.panCamera(dx, dy);
        }
    }
    
    /**
     * Handle selection click
     * @param {Object} gridPos - Grid position {x, y}
     */
    handleSelectionClick(gridPos) {
        // Find entity at clicked position
        const entity = this.findEntityAtPosition(gridPos);
        
        if (entity) {
            // If entity belongs to player or is a building that can be selected
            if (entity.owner === this.game.playerId || entity.type === 'building') {
                this.game.selectEntity(entity);
            }
        }
    }
    
    /**
     * Find entity at a grid position
     * @param {Object} gridPos - Grid position {x, y}
     * @returns {Object|null} Entity found at position or null
     */
    findEntityAtPosition(gridPos) {
        // Check for the player's hero
        const playerData = this.game.players.get(this.game.playerId);
        if (playerData && playerData.hero) {
            const heroPos = playerData.hero.position;
            if (Math.abs(heroPos.x - gridPos.x) < 0.5 && Math.abs(heroPos.y - gridPos.y) < 0.5) {
                return playerData.hero;
            }
        }
        
        // Check for units
        for (const [id, unit] of this.game.units) {
            const unitPos = unit.position;
            if (Math.abs(unitPos.x - gridPos.x) < 0.5 && Math.abs(unitPos.y - gridPos.y) < 0.5) {
                return unit;
            }
        }
        
        // Check for buildings
        for (const [id, building] of this.game.buildings) {
            const buildingPos = building.position;
            // Buildings are larger, so check a wider area
            if (Math.abs(buildingPos.x - gridPos.x) < 1.5 && Math.abs(buildingPos.y - gridPos.y) < 1.5) {
                return building;
            }
        }
        
        return null;
    }
    
    /**
     * Update input state
     */
    update() {
        // Update camera based on keys
        this.updateCameraFromKeys();
    }
    
    /**
     * Get current selection box
     * @returns {Object|null} Selection box or null if not dragging
     */
    getSelectionBox() {
        return this.selectionBox;
    }
    
    /**
     * Disable input handling
     */
    disableInput() {
        this.inputEnabled = false;
    }
    
    /**
     * Enable input handling
     */
    enableInput() {
        this.inputEnabled = true;
    }
}

export { InputHandler };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Multiplayer.js 
======================================== 
 
/**
 * Multiplayer class for handling client-side networking
 */
class Multiplayer {
    /**
     * Initialize the multiplayer system
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        this.socket = null;
        this.playerId = null;
        this.connected = false;
        this.serverEntities = {}; // Entities from the server
        this.pendingCommands = []; // Commands waiting to be sent
        this.lastServerUpdate = Date.now();
        this.serverStartTime = null; // Store server start time
        
        // Bind methods to this instance
        this.onConnect = this.onConnect.bind(this);
        this.onDisconnect = this.onDisconnect.bind(this);
        this.onGameState = this.onGameState.bind(this);
        this.onGameUpdate = this.onGameUpdate.bind(this);
        this.onPlayerJoined = this.onPlayerJoined.bind(this);
        this.onPlayerLeft = this.onPlayerLeft.bind(this);
        this.onUnitCreated = this.onUnitCreated.bind(this);
        this.onUnitsMoved = this.onUnitsMoved.bind(this);
        this.onUpdateUnitPosition = this.onUpdateUnitPosition.bind(this);
        this.onEntityRemoved = this.onEntityRemoved.bind(this);
        this.onMapResized = this.onMapResized.bind(this);
        this.onJoinGameSuccess = this.onJoinGameSuccess.bind(this);
        this.onJoinGameError = this.onJoinGameError.bind(this);
        this.onUnitsAttacking = this.onUnitsAttacking.bind(this);
        this.onUnitAttack = this.onUnitAttack.bind(this);
        this.onEntityDestroyed = this.onEntityDestroyed.bind(this);
        this.onGameEnded = this.onGameEnded.bind(this);
        this.onCountdownUpdate = this.onCountdownUpdate.bind(this);
        this.onPrepareNextGame = this.onPrepareNextGame.bind(this);
        this.onServerStarted = this.onServerStarted.bind(this);
        
        // Connect to the server
        this.connect();
    }
    
    /**
     * Connect to the game server
     */
    connect() {
        // Connect to the server on the same host and port
        // Since we're serving the client from the same server
        const serverUrl = window.location.origin;
        
        console.log(`Connecting to game server at ${serverUrl}`);
        
        // Create socket connection
        this.socket = io(serverUrl);
        
        // Set up event handlers
        this.socket.on('connect', this.onConnect);
        this.socket.on('disconnect', this.onDisconnect);
        this.socket.on('gameState', this.onGameState);
        this.socket.on('gameUpdate', this.onGameUpdate);
        this.socket.on('playerJoined', this.onPlayerJoined);
        this.socket.on('playerLeft', this.onPlayerLeft);
        this.socket.on('unitCreated', this.onUnitCreated);
        this.socket.on('unitsMoved', this.onUnitsMoved);
        this.socket.on('updateUnitPosition', this.onUpdateUnitPosition);
        this.socket.on('unitsAttacking', this.onUnitsAttacking);
        this.socket.on('unitAttack', this.onUnitAttack);
        this.socket.on('entityDestroyed', this.onEntityDestroyed);
        this.socket.on('entityRemoved', this.onEntityRemoved);
        this.socket.on('mapResized', this.onMapResized);
        this.socket.on('joinGameSuccess', this.onJoinGameSuccess);
        this.socket.on('joinGameError', this.onJoinGameError);
        this.socket.on('gameEnded', this.onGameEnded);
        this.socket.on('countdownUpdate', this.onCountdownUpdate);
        this.socket.on('prepareNextGame', this.onPrepareNextGame);
        this.socket.on('serverStarted', this.onServerStarted.bind(this));
    }
    
    /**
     * Disconnect from the game server
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.connected = false;
    }
    
    /**
     * Handle connection to the server
     */
    onConnect() {
        console.log('Connected to game server');
        this.connected = true;
        
        // Process any pending commands
        this.processPendingCommands();
    }
    
    /**
     * Handle disconnection from the server
     */
    onDisconnect() {
        console.log('Disconnected from game server');
        this.connected = false;
    }
    
    /**
     * Handle initial game state from server
     */
    onGameState(data) {
        console.log('Received initial game state from server');
        this.playerId = data.playerId;
        this.game.playerId = data.playerId;
        console.log(`My playerId is: ${this.playerId}`);
        
        // Store server start time
        if (data.gameState && data.gameState.serverStartTime) {
            console.log('Setting server start time:', new Date(data.gameState.serverStartTime));
            this.serverStartTime = data.gameState.serverStartTime;
        }
        
        // Update map dimensions from server data
        if (data.gameState && data.gameState.mapDimensions) {
            console.log('Setting map dimensions from server data:', data.gameState.mapDimensions);
            this.updateMapDimensions(data.gameState.mapDimensions);
        }
        
        // Set the map from server data
        if (data.gameState && data.gameState.map) {
            console.log('Setting map from server data');
            this.game.map.setMapFromServer(data.gameState.map);
        } else {
            console.error('No map data received from server');
        }
        
        // Clear existing entities before processing new ones
        this.game.entities = [];
        
        // Process entities from server data (should only be buildings at this point)
        if (data.gameState && data.gameState.entities) {
            console.log('Processing initial entities from server data (buildings only)');
            this.game.processServerEntities(data.gameState.entities);
        }

        // Show the join button
        this.showJoinButton();
    }
    
    /**
     * Show the join button in the UI
     */
    showJoinButton() {
        // Create join button container if it doesn't exist
        let joinContainer = document.getElementById('joinContainer');
        if (!joinContainer) {
            joinContainer = document.createElement('div');
            joinContainer.id = 'joinContainer';
            joinContainer.style.position = 'absolute';
            joinContainer.style.top = '50%';
            joinContainer.style.left = '50%';
            joinContainer.style.transform = 'translate(-50%, -50%)';
            joinContainer.style.textAlign = 'center';
            joinContainer.style.zIndex = '1000';
            document.body.appendChild(joinContainer);
        }

        // Create join button if it doesn't exist
        let joinButton = document.getElementById('joinButton');
        if (!joinButton) {
            joinButton = document.createElement('button');
            joinButton.id = 'joinButton';
            joinButton.textContent = 'Join Game';
            joinButton.style.padding = '15px 30px';
            joinButton.style.fontSize = '18px';
            joinButton.style.cursor = 'pointer';
            joinButton.style.backgroundColor = '#4CAF50';
            joinButton.style.color = 'white';
            joinButton.style.border = 'none';
            joinButton.style.borderRadius = '5px';
            joinButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            
            // Add hover effect
            joinButton.onmouseover = () => {
                joinButton.style.backgroundColor = '#45a049';
            };
            joinButton.onmouseout = () => {
                joinButton.style.backgroundColor = '#4CAF50';
            };

            // Add click handler
            joinButton.onclick = () => {
                this.requestJoinGame();
                joinContainer.remove(); // Remove the button after clicking
            };

            joinContainer.appendChild(joinButton);
        }
    }
    
    /**
     * Request to join the game and create initial unit
     */
    requestJoinGame() {
        console.log('Requesting to join game with playerId:', this.playerId);
        this.socket.emit('joinGame', { playerId: this.playerId });
    }
    
    /**
     * Handle map resize event from server
     */
    onMapResized(data) {
        console.log('Received map resize event from server:', data.mapDimensions);
        
        // Update map dimensions
        this.updateMapDimensions(data.mapDimensions);
        
        // Update the map tiles
        if (data.map) {
            this.game.map.setMapFromServer(data.map);
        }
        
        // Update entities
        if (data.entities) {
            this.game.processServerEntities(data.entities);
        }
        
        // Reset camera position to ensure it's within bounds
        this.game.camera.updateDimensions();
        this.game.camera.clampPosition();
    }
    
    /**
     * Update map dimensions based on server data
     */
    updateMapDimensions(mapDimensions) {
        if (!mapDimensions) return;
        
        // Update Config with new map dimensions
        Config.MAP_WIDTH = mapDimensions.width;
        Config.MAP_HEIGHT = mapDimensions.height;
        
        // Apply zoom factor if provided
        if (mapDimensions.zoomFactor) {
            this.game.camera.zoom = mapDimensions.zoomFactor;
        }
        
        console.log(`Updated map dimensions to ${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
        
        // Update camera boundaries
        this.game.camera.updateDimensions();
    }
    
    /**
     * Handle game update from server
     */
    onGameUpdate(data) {
        const currentTime = Date.now();
        
        // Update server start time if provided
        if (data.serverStartTime && (!this.serverStartTime || this.serverStartTime !== data.serverStartTime)) {
            this.serverStartTime = data.serverStartTime;
        }

        Object.values(data.entities).forEach(serverEntity => {
            let localEntity = this.game.entities.find(e => e.id === serverEntity.id);

            if (localEntity) {
                if (localEntity instanceof Unit) {
                    // Explicitly store previous positions for interpolation
                    localEntity.prevX = localEntity.x;
                    localEntity.prevY = localEntity.y;
                    localEntity.serverX = serverEntity.x;
                    localEntity.serverY = serverEntity.y;
                    localEntity.interpolationStartTime = currentTime;
                }
            }
        });
        
        this.game.processServerEntities(data.entities);
    }
    
    /**
     * Handle new player joining
     */
    onPlayerJoined(data) {
        console.log('Player joined:', data.player);
        // Could show a notification or update player list
    }
    
    /**
     * Handle player leaving
     */
    onPlayerLeft(data) {
        console.log('Player left:', data.playerId);
        // Could show a notification or update player list
    }
    
    /**
     * Handle new unit creation
     */
    onUnitCreated(data) {
        console.log('\n=== Unit Created Event ===');
        console.log('Received unit created event:', data);
        
        if (data.unit) {
            console.log(`Processing new unit - ID: ${data.unit.id}, PlayerId: ${data.unit.playerId}`);
            // Add the new unit to the game
            this.game.processServerEntities({ [data.unit.id]: data.unit });
            console.log('Unit added to game entities');
            
            // If this is our unit, center the camera on it
            if (data.unit.playerId === this.playerId) {
                console.log('Unit belongs to this player, centering camera');
                // Convert unit position to isometric coordinates for camera centering
                const isoX = (data.unit.x - data.unit.y) / 2;
                const isoY = (data.unit.x + data.unit.y) / 4;
                
                // Center camera on the player's unit in isometric space
                this.game.camera.centerOn(isoX, isoY);
                
                // Ensure camera position is within bounds
                this.game.camera.clampPosition();
            }
        } else {
            console.error('Unit created event received but no unit data present');
        }
        console.log('=== Unit Created Complete ===\n');
    }
    
    /**
     * Handle units being moved
     */
    onUnitsMoved(data) {
        const { unitIds, targetX, targetY } = data;
        
        unitIds.forEach(unitId => {
            const unit = this.game.entities.find(e => e.id === unitId);
            if (unit) {
                // Set the target for the unit to move to
                unit.targetX = targetX;
                unit.targetY = targetY;
                unit.isMoving = true;
            }
        });
    }
    
    /**
     * Handle entity removal
     */
    onEntityRemoved(data) {
        const entityIndex = this.game.entities.findIndex(e => e.id === data.entityId);
        if (entityIndex !== -1) {
            this.game.entities.splice(entityIndex, 1);
        }
    }
    
    /**
     * Create an entity from server data
     */
    createEntityFromServer(entityData) {
        // This method is now deprecated in favor of processServerEntities
        console.warn('createEntityFromServer is deprecated, use processServerEntities instead');
        
        if (entityData.type === 'unit') {
            const unit = new Unit(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.unitType || 'SOLDIER',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            unit.id = entityData.id;
            unit.playerId = entityData.playerId;
            
            // Set unit attributes from server data
            if (entityData.health !== undefined) unit.health = entityData.health;
            if (entityData.maxHealth !== undefined) unit.maxHealth = entityData.maxHealth;
            if (entityData.attackDamage !== undefined) unit.attackDamage = entityData.attackDamage;
            if (entityData.attackRange !== undefined) unit.attackRange = entityData.attackRange;
            if (entityData.attackCooldown !== undefined) unit.attackCooldown = entityData.attackCooldown;
            if (entityData.speed !== undefined) unit.speed = entityData.speed;
            if (entityData.level !== undefined) unit.level = entityData.level;
            if (entityData.experience !== undefined) unit.experience = entityData.experience;
            
            // Set movement properties
            if (entityData.targetX !== undefined) unit.targetX = entityData.targetX;
            if (entityData.targetY !== undefined) unit.targetY = entityData.targetY;
            if (entityData.isMoving !== undefined) unit.isMoving = entityData.isMoving;
            
            // Add to game entities
            this.game.entities.push(unit);
            return unit;
        } else if (entityData.type === 'building') {
            const building = new Building(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.buildingType || 'BASE',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            building.id = entityData.id;
            building.playerId = entityData.playerId;
            
            // Set building attributes from server data
            if (entityData.health !== undefined) building.health = entityData.health;
            if (entityData.maxHealth !== undefined) building.maxHealth = entityData.maxHealth;
            
            // Add to game entities
            this.game.entities.push(building);
            return building;
        }
        
        return null;
    }
    
    /**
     * Create a new unit
     */
    createUnit(x, y, isPlayerControlled, unitType = 'SOLDIER') {
        if (!this.connected) {
            console.error('Cannot create unit: not connected to server');
            return;
        }
        
        this.socket.emit('createUnit', {
            x,
            y,
            isPlayerControlled,
            unitType
        });
    }
    
    /**
     * Move units and send to server
     */
    moveUnits(unitIds, targetX, targetY) {
        if (!this.connected) {
            this.pendingCommands.push(() => this.moveUnits(unitIds, targetX, targetY));
            return;
        }
        
        this.socket.emit('moveUnits', {
            unitIds,
            targetX,
            targetY
        });
    }
    
    /**
     * Attack target and send to server
     */
    attackTarget(unitIds, targetEntityId) {
        if (!this.connected) {
            this.pendingCommands.push(() => this.attackTarget(unitIds, targetEntityId));
            return;
        }
        
        this.socket.emit('attackTarget', {
            unitIds,
            targetEntityId
        });
    }
    
    /**
     * Process any pending commands
     */
    processPendingCommands() {
        if (!this.connected) return;
        
        while (this.pendingCommands.length > 0) {
            const command = this.pendingCommands.shift();
            command();
        }
    }
    
    /**
     * Update multiplayer state
     */
    update(deltaTime) {
        const interpolationDuration = 100; // Time between server updates in ms
        const currentTime = Date.now();

        this.game.entities.forEach(entity => {
            if (entity instanceof Unit && 
                entity.serverX !== undefined && 
                entity.serverY !== undefined &&
                !entity.isDestroyed  // Critical Fix: Ignore destroyed units
            ) {
                const elapsed = currentTime - entity.interpolationStartTime;
                const t = Math.min(elapsed / interpolationDuration, 1); // interpolationDuration ~100ms

                entity.x = entity.prevX + (entity.serverX - entity.prevX) * t;
                entity.y = entity.prevY + (entity.serverY - entity.prevY) * t;

                if (t >= 1) {
                    entity.prevX = entity.serverX;
                    entity.prevY = entity.serverY;
                }
            }
        });
    }
    
    /**
     * Get the elapsed time since the server started
     * @returns {string} Formatted elapsed time (HH:MM:SS)
     */
    getElapsedTime() {
        if (!this.serverStartTime) {
            return "00:00:00";
        }
        
        // Calculate elapsed time in seconds
        const elapsedMs = Date.now() - this.serverStartTime;
        const elapsedSeconds = Math.floor(elapsedMs / 1000);
        
        // Calculate hours, minutes, and seconds
        const hours = Math.floor(elapsedSeconds / 3600);
        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
        const seconds = elapsedSeconds % 60;
        
        // Format as HH:MM:SS
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    /**
     * Handle successful game join
     */
    onJoinGameSuccess(data) {
        console.log('\n=== Join Game Success ===');
        console.log('Received join game success with unit:', data.unit);
        
        if (data.unit) {
            console.log(`Unit details - ID: ${data.unit.id}, PlayerId: ${data.unit.playerId}, Position: (${data.unit.x}, ${data.unit.y})`);
            // Process the new unit
            this.game.processServerEntities({ [data.unit.id]: data.unit });
            console.log('Unit processed and added to game');
            
            // First set zoom to a much higher level for a closer view of the unit
            // Do this BEFORE centering to avoid position calculation issues
            this.game.camera.zoom = 1.8; // More zoomed in for a better initial view
            
            // Convert unit position to isometric coordinates for camera centering
            const isoX = (data.unit.x - data.unit.y) / 2;
            const isoY = (data.unit.x + data.unit.y) / 4;
            
            // Center camera on the player's unit in isometric space
            this.game.camera.centerOn(isoX, isoY);
            
            // Ensure camera position is within bounds
            this.game.camera.clampPosition();
            
            console.log(`Camera positioned at (${this.game.camera.x}, ${this.game.camera.y}) with zoom ${this.game.camera.zoom}`);
        } else {
            console.error('Join game success but no unit data received');
        }
        
        // Remove join button
        const joinButton = document.getElementById('joinButton');
        if (joinButton) {
            joinButton.remove();
            console.log('Join button removed');
        }
        console.log('=== Join Game Complete ===\n');
    }
    
    /**
     * Handle game join error
     */
    onJoinGameError(data) {
        console.error('Failed to join game:', data.message);
        alert(`Failed to join game: ${data.message}`);
        // Show join button again
        this.showJoinButton();
    }
    
    /**
     * Handle unit position updates from server
     */
    onUpdateUnitPosition(data) {
        const { unitId, x, y, isMoving } = data;
        const unit = this.game.entities.find(e => e.id === unitId);
        
        if (unit) {
            // Store previous position for interpolation
            unit.prevX = unit.x;
            unit.prevY = unit.y;
            unit.serverX = x;
            unit.serverY = y;
            unit.isMoving = isMoving;
            unit.interpolationStartTime = Date.now();
            
            // If the unit has stopped moving, clear the target
            if (!isMoving) {
                unit.targetX = null;
                unit.targetY = null;
            }
        }
    }
    
    /**
     * Handle units attacking event
     */
    onUnitsAttacking(data) {
        console.log(`Units ${data.unitIds.join(', ')} attacking entity ${data.targetEntityId}`);
        
        // Update unit targets in the game
        const targetEntity = this.game.getEntityById(data.targetEntityId);
        if (!targetEntity) {
            console.error(`Target entity ${data.targetEntityId} not found for attack command`);
            return;
        }
        
        // Update each unit's target
        data.unitIds.forEach(unitId => {
            const unit = this.game.getEntityById(unitId);
            if (unit && unit instanceof Unit) {
                // Set the target entity to follow and attack
                unit.targetEntity = targetEntity;
                
                // Set visual state for attack
                unit.isAttacking = true;
                
                // Also update movement target to match the target's position
                // This ensures units will follow moving targets
                const targetCenter = targetEntity.getCenter();
                unit.setTarget(targetCenter.x, targetCenter.y);
                
                console.log(`Unit ${unitId} set to follow and attack target ${data.targetEntityId} at (${targetCenter.x}, ${targetCenter.y})`);
            }
        });
    }
    
    /**
     * Handle unit attack event
     */
    onUnitAttack(data) {
        console.log(`Unit ${data.attackerId} attacked ${data.targetId} for ${data.damage} damage`);
        
        const attacker = this.game.getEntityById(data.attackerId);
        const target = this.game.getEntityById(data.targetId);
        
        if (!attacker || !target) {
            console.error('Could not find attacker or target for attack event');
            return;
        }
        
        // Update visual state
        if (attacker instanceof Unit) {
            attacker.performAttackAnimation();
        }
        
        // If the server provided the target's health, use that value directly
        if (data.targetHealth !== undefined) {
            target.health = data.targetHealth;
        } else {
            // Otherwise, apply damage locally
            target.takeDamage(data.damage);
        }
        
        // Add visual effects at the correct isometric position
        if (target instanceof Building) {
            // For buildings, convert grid coordinates to isometric coordinates
            const gridX = Math.floor(target.x / Config.TILE_SIZE);
            const gridY = Math.floor(target.y / Config.TILE_SIZE);
            
            // Convert grid coordinates to isometric world coordinates
            const isoPos = this.game.map.gridToIso(gridX, gridY);
            
            // Add effect at the isometric position
            this.game.renderer.addEffect('attack', isoPos.x, isoPos.y);
        } else {
            // For units, use the direct Cartesian-to-isometric conversion
            const isoX = (target.x - target.y) / 2;
            const isoY = (target.x + target.y) / 4;
            
            // Add effect at the isometric position
            this.game.renderer.addEffect('attack', isoX, isoY);
        }
    }
    
    /**
     * Handle entity destroyed event
     */
    onEntityDestroyed(data) {
        console.log(`Entity ${data.entityId} was destroyed`);
        
        const entity = this.game.getEntityById(data.entityId);
        if (entity) {
            // Trigger death animation
            entity.playDeathAnimation();
            
            // Add visual effects
            this.game.renderer.addEffect('explosion', entity.x + entity.width/2, entity.y + entity.height/2);
            
            // Notify any units targeting this entity to stop attacking
            this.game.entities.forEach(e => {
                if (e instanceof Unit && e.targetEntity && e.targetEntity.id === data.entityId) {
                    console.log(`Unit ${e.id} stopping attack on destroyed entity ${data.entityId}`);
                    // Don't immediately clear the target to let the death animation play
                    // The unit's updateCombat will check for isDestroyed and stop attacking
                }
            });
            
            // Wait for death animation to complete before removing
            setTimeout(() => {
                this.game.removeEntity(data.entityId);
            }, 1000); // Match death animation duration
        }
    }
    
    /**
     * Handle game ended event
     */
    onGameEnded(data) {
        console.log(`Game ended. Winner: ${data.winner}`);
        
        // Check if the player's team won
        const playerWon = data.winner === 'human-team';
        
        // Create game end overlay
        this.createGameEndOverlay(playerWon, data.message, data.countdown);
        
        // Disable input during end game
        this.game.inputHandler.disableInput();
    }
    
    /**
     * Handle countdown update
     */
    onCountdownUpdate(data) {
        console.log(`Countdown: ${data.secondsRemaining}`);
        
        // Update the countdown display
        const countdownElement = document.getElementById('game-end-countdown');
        if (countdownElement) {
            countdownElement.textContent = `Next game in: ${data.secondsRemaining}s`;
        }
    }
    
    /**
     * Handle prepare for next game event
     */
    onPrepareNextGame(data) {
        console.log('Preparing for next game');
        
        // Show join next game button
        const overlay = document.getElementById('game-end-overlay');
        if (overlay) {
            // Create join button if it doesn't exist yet
            if (!document.getElementById('join-next-game-button')) {
                const joinButton = document.createElement('button');
                joinButton.id = 'join-next-game-button';
                joinButton.textContent = 'Join Next Game';
                joinButton.classList.add('game-button');
                joinButton.addEventListener('click', () => {
                    this.joinNextGame();
                    joinButton.disabled = true;
                    joinButton.textContent = 'Joined';
                });
                
                overlay.appendChild(joinButton);
            }
            
            // Update countdown text
            const countdownElement = document.getElementById('game-end-countdown');
            if (countdownElement) {
                countdownElement.textContent = 'New game starting soon!';
            }
        }
    }
    
    /**
     * Send join next game request
     */
    joinNextGame() {
        if (this.connected && this.playerId) {
            console.log('Requesting to join next game');
            this.socket.emit('joinNextGame', { playerId: this.playerId });
        }
    }
    
    /**
     * Create the game end overlay
     */
    createGameEndOverlay(victory, message, countdown) {
        // Remove existing overlay if it exists
        const existingOverlay = document.getElementById('game-end-overlay');
        if (existingOverlay) {
            existingOverlay.remove();
        }
        
        // Create overlay container
        const overlay = document.createElement('div');
        overlay.id = 'game-end-overlay';
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '1000';
        overlay.style.color = 'white';
        overlay.style.fontFamily = 'Arial, sans-serif';
        
        // Create result header
        const resultHeader = document.createElement('h1');
        resultHeader.textContent = victory ? 'VICTORY' : 'DEFEAT';
        resultHeader.style.fontSize = '48px';
        resultHeader.style.marginBottom = '20px';
        resultHeader.style.color = victory ? '#4CAF50' : '#F44336';
        
        // Create message
        const messageElement = document.createElement('p');
        messageElement.textContent = message;
        messageElement.style.fontSize = '24px';
        messageElement.style.marginBottom = '30px';
        
        // Create countdown
        const countdownElement = document.createElement('p');
        countdownElement.id = 'game-end-countdown';
        countdownElement.textContent = `Next game in: ${countdown}s`;
        countdownElement.style.fontSize = '20px';
        countdownElement.style.marginBottom = '30px';
        
        // Add elements to overlay
        overlay.appendChild(resultHeader);
        overlay.appendChild(messageElement);
        overlay.appendChild(countdownElement);
        
        // Add overlay to the document
        document.body.appendChild(overlay);
    }
    
    /**
     * Handle server started event
     */
    onServerStarted(data) {
        console.log('Server started a new game');
        
        // Remove game end overlay if it exists
        const overlay = document.getElementById('game-end-overlay');
        if (overlay) {
            overlay.remove();
        }
        
        // Re-enable input
        this.game.inputHandler.enableInput();
        
        // Update game state from server
        if (data.gameState) {
            // Fully clear entities before rebuilding
            this.game.entities = [];
            
            // Process entities from server data
            this.game.processServerEntities(data.gameState.entities);
            
            // Store server start time
            this.serverStartTime = data.gameState.serverStartTime;
            
            console.log(`Entities after server start: ${this.game.entities.length}`);
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Renderer.js 
======================================== 
 
/**
 * Handles all rendering operations for the game
 */
class Renderer {
    /**
     * Initialize the renderer
     */
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        this.ctx = game.ctx;
        this.camera = game.camera;
        this.map = game.map;
        
        // Isometric tile dimensions
        this.tileWidth = Config.TILE_SIZE;
        this.tileHeight = Config.TILE_SIZE / 2;
        
        // Preload images
        this.preloadImages();
        
        // Track loaded images
        this.imagesLoaded = false;
        this.checkImagesLoaded();
        
        this.effects = []; // Array to store visual effects
    }
    
    /**
     * Check if all images are loaded
     */
    checkImagesLoaded() {
        // Check if all tile images are loaded
        const allImagesLoaded = Object.values(this.map.tileImages).every(img => img.complete);
        
        if (allImagesLoaded) {
            this.imagesLoaded = true;
            console.log('All images loaded successfully');
        } else {
            // Check again in 100ms
            setTimeout(() => this.checkImagesLoaded(), 100);
        }
    }
    
    /**
     * Preload any additional images needed for rendering
     */
    preloadImages() {
        // Preload unit and building images here if needed
        // For now, we're just using the tile images preloaded by the Map class
    }
    
    /**
     * Clear the canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    /**
     * Main render method - called each frame
     */
    render() {
        this.clear();
        
        // Render map
        this.renderMap();
        
        // Render entities
        this.renderEntities();
        
        // Render visual effects
        this.renderEffects(this.ctx);
        
        // Render UI
        this.renderUI();
    }
    
    /**
     * Convert grid coordinates to screen coordinates
     */
    gridToScreen(col, row) {
        // Convert grid coordinates to isometric world coordinates
        const isoPos = this.map.gridToIso(col, row);
        
        // Convert world coordinates to screen coordinates
        return this.camera.worldToScreen(isoPos.x, isoPos.y);
    }
    
    /**
     * Render the map tiles
     */
    renderMap() {
        // Calculate visible tile range based on camera position and zoom
        // For isometric view, we need a different approach to determine visible tiles
        
        // Convert camera position to grid coordinates
        const cameraWorldPos = {
            x: this.camera.x,
            y: this.camera.y
        };
        
        // Get the viewport dimensions in world coordinates
        const viewportWidth = this.camera.width / this.camera.zoom;
        const viewportHeight = this.camera.height / this.camera.zoom;
        
        // Calculate the viewport corners in world coordinates
        const viewportCorners = [
            { x: cameraWorldPos.x, y: cameraWorldPos.y }, // Top-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y }, // Top-right
            { x: cameraWorldPos.x, y: cameraWorldPos.y + viewportHeight }, // Bottom-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y + viewportHeight } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Find the min and max grid coordinates that cover the viewport
        let minGridX = Math.floor(Math.min(...gridCorners.map(corner => corner.x)));
        let maxGridX = Math.ceil(Math.max(...gridCorners.map(corner => corner.x)));
        let minGridY = Math.floor(Math.min(...gridCorners.map(corner => corner.y)));
        let maxGridY = Math.ceil(Math.max(...gridCorners.map(corner => corner.y)));
        
        // Add a buffer to ensure we render tiles that are partially visible
        const buffer = 15;
        minGridX = Math.max(0, minGridX - buffer);
        minGridY = Math.max(0, minGridY - buffer);
        maxGridX = Math.min(this.map.width, maxGridX + buffer);
        maxGridY = Math.min(this.map.height, maxGridY + buffer);
        
        // Render tiles in the correct order for isometric view (back to front)
        // This ensures proper overlapping of tiles
        for (let sum = minGridX + minGridY; sum <= maxGridX + maxGridY; sum++) {
            for (let gridX = minGridX; gridX <= maxGridX; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < minGridY || gridY > maxGridY) continue;
                
                // Get the tile at this grid position
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert grid coordinates to isometric world coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Convert world coordinates to screen coordinates
                const screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
                
                // Calculate tile dimensions with zoom
                const tileWidthZoomed = this.tileWidth * this.camera.zoom;
                const tileHeightZoomed = this.tileHeight * this.camera.zoom;
                
                // Draw the tile
                if (this.imagesLoaded) {
                    // Use the appropriate tile image based on terrain type
                    const terrainType = tile.terrainType || tile.type;
                    const tileImage = this.map.getTileImage(terrainType);
                    
                    if (tileImage && tileImage.complete) {
                        // Draw the isometric tile image
                        this.ctx.drawImage(
                            tileImage,
                            screenPos.x - (tileWidthZoomed / 2), // Center the image horizontally
                            screenPos.y - (tileHeightZoomed / 2), // Center the image vertically
                            tileWidthZoomed,
                            tileHeightZoomed
                        );
                    } else {
                        // Fallback to colored diamond if image not loaded
                        this.drawIsometricTile(
                            screenPos.x,
                            screenPos.y,
                            tileWidthZoomed,
                            tileHeightZoomed,
                            this.getTileColor(tile.terrainType || tile.type)
                        );
                    }
                } else {
                    // Fallback to colored diamond if images not loaded yet
                    this.drawIsometricTile(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed,
                        this.getTileColor(tile.terrainType || tile.type)
                    );
                }
                
                // Draw grid lines if enabled
                if (Config.SHOW_GRID) {
                    this.drawIsometricGrid(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed
                    );
                }
            }
        }
    }
    
    /**
     * Draw an isometric tile (diamond shape)
     */
    drawIsometricTile(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.fill();
    }
    
    /**
     * Draw isometric grid lines
     */
    drawIsometricGrid(x, y, width, height) {
        this.ctx.strokeStyle = Config.COLORS.GRID;
        this.ctx.lineWidth = 1;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.stroke();
    }
    
    /**
     * Get the color for a tile type
     */
    getTileColor(tileType) {
        switch (tileType) {
            case 'grass': return Config.COLORS.GRASS;
            case 'water': return Config.COLORS.WATER;
            case 'sand': return Config.COLORS.SAND;
            case 'mountain': return Config.COLORS.MOUNTAIN;
            case 'forest': return Config.COLORS.FOREST;
            default: return Config.COLORS.GRASS;
        }
    }
    
    /**
     * Render all game entities
     */
    renderEntities() {
        // Use quadtree to get only entities in the visible area
        const visibleQuadItems = this.game.quadtree.query(this.camera.getBoundingBox());
        
        // Extract the actual entity objects from the quadtree results
        const visibleEntities = visibleQuadItems
            .map(item => item.entity)
            .filter(entity => entity !== undefined); // Filter out any undefined entities
        
        // Check if we got any entities from the quadtree
        if (visibleEntities.length === 0 && this.game.entities.length > 0) {
            console.warn('Quadtree returned no entities, falling back to full entity list for rendering');
            
            // Fallback to rendering all entities that are visible
            const allVisibleEntities = this.game.entities.filter(entity => 
                this.camera.isVisible(entity.x, entity.y, entity.width, entity.height));
            
            if (allVisibleEntities.length > 0) {
                console.log(`Found ${allVisibleEntities.length} visible entities in fallback check`);
            }
            
            // Sort entities by their y-coordinate for proper depth ordering in isometric view
            const sortedEntities = [...allVisibleEntities].sort((a, b) => a.y - b.y);
            this.renderEntityList(sortedEntities);
            return;
        }
        
        // Sort entities by their y-coordinate for proper depth ordering in isometric view
        const sortedEntities = [...visibleEntities].sort((a, b) => a.y - b.y);
        this.renderEntityList(sortedEntities);
    }
    
    /**
     * Render a list of entities (extracted as a helper method)
     * @param {Array} entityList - List of entities to render
     */
    renderEntityList(entityList) {
        for (const entity of entityList) {
            let screenPos;
            
            if (entity instanceof Building) {
                // For buildings, use the grid-based conversion
                // Convert entity position to grid coordinates
                const gridX = Math.floor(entity.x / Config.TILE_SIZE);
                const gridY = Math.floor(entity.y / Config.TILE_SIZE);
                
                // Convert grid coordinates to isometric world coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Convert world coordinates to screen coordinates
                screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
            } else {
                // For units, use the direct Cartesian-to-isometric conversion
                const isoX = (entity.x - entity.y) / 2;
                const isoY = (entity.x + entity.y) / 4;
                
                // Convert to screen coordinates
                screenPos = this.camera.worldToScreen(isoX, isoY);
            }
            
            // Calculate entity dimensions with zoom
            const entityWidth = entity.width * this.camera.zoom;
            const entityHeight = entity.height * this.camera.zoom;
            
            // Render the entity based on its type
            if (entity instanceof Unit) {
                this.renderUnit(entity, screenPos, entityWidth, entityHeight);
            } else if (entity instanceof Building) {
                this.renderBuilding(entity, screenPos, entityWidth, entityHeight);
            }
        }
    }
    
    /**
     * Render a unit with its image and health bar
     */
    renderUnit(unit, screenPos, width, height) {
        // Debug logging for selection
        if (unit.isSelected) {
            console.log(`Rendering selected unit: ${unit.id}, isPlayerControlled: ${unit.isPlayerControlled}, playerId: ${unit.playerId}, position: (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw unit image if available
        if (unit.image && unit.image.complete) {
            console.log(`Rendering unit image: ${unit.unitType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                unit.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            // Fallback to colored rectangle if image not loaded
            console.log(`Fallback rendering for unit: ${unit.unitType} at (${screenPos.x}, ${screenPos.y})`);
            this.ctx.fillStyle = unit.isPlayerControlled ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
                
            this.ctx.fillRect(
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        }
        
        // Draw red "X" over the unit if it's destroyed (dead)
        if (unit.isDestroyed) {
            this.ctx.strokeStyle = 'red';
            this.ctx.lineWidth = 4 * this.camera.zoom;
            this.ctx.beginPath();
            this.ctx.moveTo(screenPos.x - width / 2, screenPos.y - height / 2);
            this.ctx.lineTo(screenPos.x + width / 2, screenPos.y + height / 2);
            this.ctx.moveTo(screenPos.x + width / 2, screenPos.y - height / 2);
            this.ctx.lineTo(screenPos.x - width / 2, screenPos.y + height / 2);
            this.ctx.stroke();
        }
        
        // Draw selection indicator if unit is selected AND belongs to the player
        if (unit.isSelected && unit.playerId === this.game.playerId) {
            console.log(`Drawing selection indicator for unit ${unit.id} at (${screenPos.x}, ${screenPos.y}) with radius ${(width / 2) + 5 * this.camera.zoom}`);
            
            // Draw a glowing selection circle around the unit
            this.ctx.strokeStyle = Config.COLORS.SELECTION || '#00ff00';
            this.ctx.lineWidth = 2 * this.camera.zoom;
            
            // Draw circle around unit
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.stroke();
            
            // Add a semi-transparent fill for better visibility
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
            
            console.log(`Selection indicator drawn with color ${Config.COLORS.SELECTION}`);
        }
        
        // Draw health bar only if the unit is not destroyed
        if (!unit.isDestroyed) {
            const healthBarWidth = width;
            const healthBarHeight = 4 * this.camera.zoom;
            const healthPercentage = unit.health / unit.maxHealth;
            
            // Health bar background
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            this.ctx.fillRect(
                screenPos.x - width / 2,
                screenPos.y - height / 2 - healthBarHeight - 2,
                healthBarWidth,
                healthBarHeight
            );
            
            // Health bar fill
            this.ctx.fillStyle = this.getHealthColor(healthPercentage);
            this.ctx.fillRect(
                screenPos.x - width / 2,
                screenPos.y - height / 2 - healthBarHeight - 2,
                healthBarWidth * healthPercentage,
                healthBarHeight
            );
        }
        
        // Draw level indicator if level > 1
        if (unit.level > 1) {
            this.ctx.fillStyle = 'white';
            this.ctx.font = `${10 * this.camera.zoom}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                unit.level.toString(),
                screenPos.x,
                screenPos.y + height / 2 + 12 * this.camera.zoom
            );
        }
    }
    
    /**
     * Render a building with its image and health bar
     */
    renderBuilding(building, screenPos, width, height) {
        // Always draw a solid base rectangle first
        this.ctx.fillStyle = building.playerColor === 'red' ? 
            '#ff0000' : building.playerColor === 'blue' ? 
            '#0000ff' : '#888888';
            
        // Draw an isometric building base
        this.drawIsometricBuilding(
            screenPos.x,
            screenPos.y,
            width,
            height / 2, // Half height for isometric look
            this.ctx.fillStyle
        );
        
        // Draw building image if available
        if (building.image && building.image.complete) {
            // For isometric view, we need to adjust the image position
            console.log(`Rendering building image: ${building.buildingType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                building.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            console.log(`Fallback rendering for building: ${building.buildingType} at (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw health bar
        const healthPercentage = building.health / building.maxHealth;
        const healthBarWidth = width;
        const healthBarHeight = 5 * this.camera.zoom;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Determine the label based on player color
        let baseLabel = building.buildingType;
        if (building.buildingType === 'BASE') {
            baseLabel = building.playerColor === 'blue' ? 'Human Base' : 'AI Base';
        }
        
        // Draw building type text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = `${12 * this.camera.zoom}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(
            baseLabel,
            screenPos.x,
            screenPos.y
        );
    }
    
    /**
     * Draw an isometric building
     */
    drawIsometricBuilding(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a 3D isometric building
        // Top face (roof)
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height); // Top point
        this.ctx.lineTo(x + width / 2, y - height / 2); // Right point
        this.ctx.lineTo(x, y); // Bottom point
        this.ctx.lineTo(x - width / 2, y - height / 2); // Left point
        this.ctx.closePath();
        this.ctx.fill();
        
        // Right face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-left
        this.ctx.lineTo(x + width / 2, y - height / 2); // Top-right
        this.ctx.lineTo(x + width / 2, y + height / 2); // Bottom-right
        this.ctx.lineTo(x, y + height); // Bottom-left
        this.ctx.closePath();
        // Darken the right face
        this.ctx.fillStyle = this.darkenColor(color, 0.7);
        this.ctx.fill();
        
        // Left face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-right
        this.ctx.lineTo(x - width / 2, y - height / 2); // Top-left
        this.ctx.lineTo(x - width / 2, y + height / 2); // Bottom-left
        this.ctx.lineTo(x, y + height); // Bottom-right
        this.ctx.closePath();
        // Darken the left face more
        this.ctx.fillStyle = this.darkenColor(color, 0.5);
        this.ctx.fill();
    }
    
    /**
     * Darken a color by a factor
     */
    darkenColor(color, factor) {
        // Convert hex to RGB
        let r, g, b;
        if (color.startsWith('#')) {
            const hex = color.substring(1);
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        } else if (color.startsWith('rgb')) {
            const match = color.match(/\d+/g);
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
        } else {
            return color; // Can't darken
        }
        
        // Darken
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        
        // Convert back to hex
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    /**
     * Get color for health bar based on percentage
     */
    getHealthColor(percentage) {
        if (percentage > 0.6) {
            return 'rgb(0, 255, 0)'; // Green
        } else if (percentage > 0.3) {
            return 'rgb(255, 255, 0)'; // Yellow
        } else {
            return 'rgb(255, 0, 0)'; // Red
        }
    }
    
    /**
     * Render UI elements
     */
    renderUI() {
        // Render elapsed time at the top of the screen
        this.renderElapsedTime();
        
        // Render selection box if dragging
        const selectionBox = this.game.inputHandler.getSelectionBox();
        if (selectionBox) {
            // Semi-transparent fill
            this.ctx.fillStyle = 'rgba(0, 255, 255, 0.1)';
            this.ctx.fillRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
            
            // Selection box border
            this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
            this.ctx.lineWidth = 2;
            this.ctx.strokeRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
        }
        
        // Render minimap
        this.renderMinimap();
        
        // Render selected unit info
        this.renderSelectedUnitInfo();
        
        // Render debug info if enabled
        if (Config.DEBUG_MODE) {
            this.renderDebugInfo();
        }
    }
    
    /**
     * Render the elapsed time since the server started
     */
    renderElapsedTime() {
        const elapsedTime = this.game.multiplayer.getElapsedTime();
        
        // Set up text style
        this.ctx.font = '16px Arial';
        this.ctx.textAlign = 'center';
        
        // Draw background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(this.canvas.width / 2 - 80, 10, 160, 30);
        
        // Draw text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillText(`Time Elapsed: ${elapsedTime}`, this.canvas.width / 2, 30);
    }
    
    /**
     * Render the minimap
     */
    renderMinimap() {
        const minimapElement = document.getElementById('minimap');
        if (!minimapElement) return;
        
        // Create a canvas for the minimap if it doesn't exist
        if (!this.minimapCanvas) {
            this.minimapCanvas = document.createElement('canvas');
            this.minimapCanvas.width = 180; // Slightly smaller than the container
            this.minimapCanvas.height = 180;
            this.minimapCtx = this.minimapCanvas.getContext('2d');
            minimapElement.appendChild(this.minimapCanvas);
        }
        
        // Clear the minimap
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // Calculate the isometric map dimensions
        const isoMapWidth = (this.map.width + this.map.height) * (Config.TILE_SIZE / 2);
        const isoMapHeight = (this.map.width + this.map.height) * (Config.TILE_SIZE / 4);
        
        // Calculate scale factors for the minimap
        const scaleX = this.minimapCanvas.width / isoMapWidth;
        const scaleY = this.minimapCanvas.height / isoMapHeight;
        
        // Use the smaller scale to maintain aspect ratio
        const scale = Math.min(scaleX, scaleY) * 0.8; // 80% to leave some margin
        
        // Calculate offsets to center the map in the minimap
        const offsetX = this.minimapCanvas.width / 2;
        const offsetY = this.minimapCanvas.height / 4;
        
        // Draw map tiles on minimap
        // Render in the correct order for isometric view (back to front)
        for (let sum = 0; sum < this.map.width + this.map.height; sum++) {
            for (let gridX = 0; gridX < this.map.width; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < 0 || gridY >= this.map.height) continue;
                
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert to isometric coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Scale and position for minimap
                const x = offsetX + isoPos.x * scale;
                const y = offsetY + isoPos.y * scale;
                
                // Draw a small diamond for each tile
                this.minimapCtx.fillStyle = this.getTileColor(tile.terrainType || tile.type);
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(x, y - 2); // Top
                this.minimapCtx.lineTo(x + 2, y); // Right
                this.minimapCtx.lineTo(x, y + 2); // Bottom
                this.minimapCtx.lineTo(x - 2, y); // Left
                this.minimapCtx.closePath();
                this.minimapCtx.fill();
            }
        }
        
        // Draw entities on minimap
        for (const entity of this.game.entities) {
            // Convert entity position to grid coordinates
            const gridX = Math.floor(entity.x / Config.TILE_SIZE);
            const gridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            // Convert to isometric coordinates
            const isoPos = this.map.gridToIso(gridX, gridY);
            
            // Scale and position for minimap
            const x = offsetX + isoPos.x * scale;
            const y = offsetY + isoPos.y * scale;
            
            // Draw a dot for each entity
            this.minimapCtx.fillStyle = entity.playerColor === 'blue' ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            
            this.minimapCtx.beginPath();
            this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
            this.minimapCtx.fill();
        }
        
        // Draw camera viewport rectangle
        // Calculate the four corners of the viewport in world coordinates
        const viewportCorners = [
            { x: this.camera.x, y: this.camera.y }, // Top-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y }, // Top-right
            { x: this.camera.x, y: this.camera.y + this.camera.height / this.camera.zoom }, // Bottom-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y + this.camera.height / this.camera.zoom } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Convert back to isometric for minimap and scale
        const minimapCorners = gridCorners.map(gridPos => {
            const isoPos = this.map.gridToIso(gridPos.x, gridPos.y);
            return {
                x: offsetX + isoPos.x * scale,
                y: offsetY + isoPos.y * scale
            };
        });
        
        // Draw viewport outline
        this.minimapCtx.strokeStyle = 'white';
        this.minimapCtx.lineWidth = 1.5;
        this.minimapCtx.beginPath();
        this.minimapCtx.moveTo(minimapCorners[0].x, minimapCorners[0].y);
        this.minimapCtx.lineTo(minimapCorners[1].x, minimapCorners[1].y);
        this.minimapCtx.lineTo(minimapCorners[3].x, minimapCorners[3].y);
        this.minimapCtx.lineTo(minimapCorners[2].x, minimapCorners[2].y);
        this.minimapCtx.closePath();
        this.minimapCtx.stroke();
    }
    
    /**
     * Render information about selected units
     */
    renderSelectedUnitInfo() {
        const selectedUnits = this.game.entities.filter(e => e.isSelected && e instanceof Unit);
        
        if (selectedUnits.length === 0) {
            return;
        }
        
        // Only show info for the first selected unit
        const unit = selectedUnits[0];
        const padding = 10;
        const lineHeight = 20;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(
            this.canvas.width - 200 - padding,
            padding,
            200,
            150
        );
        
        this.ctx.fillStyle = 'white';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'left';
        
        let y = padding + lineHeight;
        
        this.ctx.fillText(`Unit Type: ${unit.unitType}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Level: ${unit.level}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Health: ${unit.health}/${unit.maxHealth}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Attack: ${unit.attackDamage}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Range: ${unit.attackRange}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Speed: ${unit.speed}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        if (unit.level < 10) { // Max level cap
            const expNeeded = unit.level * 100;
            this.ctx.fillText(`XP: ${unit.experience}/${expNeeded}`, this.canvas.width - 190, y);
        }
    }
    
    /**
     * Render debug information
     */
    renderDebugInfo() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'left';
        
        // Display FPS
        this.ctx.fillText(`FPS: ${this.game.fps.toFixed(1)}`, 10, 20);
        
        // Display camera position
        this.ctx.fillText(`Camera: (${this.camera.x.toFixed(0)}, ${this.camera.y.toFixed(0)})`, 10, 40);
        
        // Display zoom level
        this.ctx.fillText(`Zoom: ${(this.camera.zoom * 100).toFixed(0)}%`, 10, 60);
        
        // Display entity count
        this.ctx.fillText(`Entities: ${this.game.entities.length}`, 10, 80);
        
        // Display selected entities count
        const selectedCount = this.game.entities.filter(e => e.isSelected).length;
        this.ctx.fillText(`Selected: ${selectedCount}`, 10, 100);
        
        // Display isometric rendering info
        this.ctx.fillText(`Isometric Mode: Active`, 10, 120);
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
    }

    /**
     * Add a visual effect at a specified position
     */
    addEffect(type, x, y) {
        const effect = {
            type,
            x,
            y,
            startTime: Date.now(),
            duration: 1000 // Default duration 1 second
        };
        
        // Customize effect based on type
        switch (type) {
            case 'moveCommand':
                effect.duration = 800;
                effect.color = 'green';
                effect.size = 20;
                break;
            case 'attackCommand':
                effect.duration = 1000;
                effect.color = '#ff3333'; // Bright red
                effect.size = 25; // Larger size
                break;
            case 'attack':
                effect.duration = 500;
                effect.color = 'orange';
                effect.size = 15;
                break;
            case 'explosion':
                effect.duration = 1200;
                effect.color = 'red';
                effect.size = 30;
                break;
            default:
                effect.color = 'white';
                effect.size = 10;
        }
        
        this.effects.push(effect);
    }

    /**
     * Update and render visual effects
     */
    renderEffects(ctx) {
        const now = Date.now();
        const camera = this.game.camera;
        
        // Update and render each effect
        for (let i = this.effects.length - 1; i >= 0; i--) {
            const effect = this.effects[i];
            const elapsed = now - effect.startTime;
            
            // Remove expired effects
            if (elapsed > effect.duration) {
                this.effects.splice(i, 1);
                continue;
            }
            
            // Calculate progress (0 to 1)
            const progress = elapsed / effect.duration;
            
            // Get screen position
            const screenPos = camera.worldToScreen(effect.x, effect.y);
            
            // Render based on effect type
            switch (effect.type) {
                case 'moveCommand':
                    this.renderMoveCommandEffect(ctx, screenPos, effect, progress);
                    break;
                case 'attackCommand':
                    this.renderAttackCommandEffect(ctx, screenPos, effect, progress);
                    break;
                case 'attack':
                    this.renderAttackEffect(ctx, screenPos, effect, progress);
                    break;
                case 'explosion':
                    this.renderExplosionEffect(ctx, screenPos, effect, progress);
                    break;
                default:
                    this.renderDefaultEffect(ctx, screenPos, effect, progress);
            }
        }
    }

    /**
     * Render a move command effect
     */
    renderMoveCommandEffect(ctx, screenPos, effect, progress) {
        // Draw a circle that fades out
        ctx.globalAlpha = 1 - progress;
        ctx.beginPath();
        ctx.strokeStyle = effect.color;
        ctx.lineWidth = 2;
        
        // Circle expands outward
        const size = effect.size * (1 + progress);
        ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);
        ctx.stroke();
        
        // Reset alpha
        ctx.globalAlpha = 1;
    }

    /**
     * Render an attack command effect
     */
    renderAttackCommandEffect(ctx, screenPos, effect, progress) {
        // Draw a red circle that fades out
        ctx.globalAlpha = 1 - progress;
        ctx.strokeStyle = effect.color;
        ctx.lineWidth = 3;
        
        // Circle grows slightly
        const size = effect.size * (1 + progress * 0.5);
        
        // Outer circle
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, size, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner circle (target-like pattern)
        ctx.beginPath();
        ctx.arc(screenPos.x, screenPos.y, size * 0.5, 0, Math.PI * 2);
        ctx.stroke();
        
        // Reset alpha
        ctx.globalAlpha = 1;
    }

    /**
     * Render an attack effect
     */
    renderAttackEffect(ctx, screenPos, effect, progress) {
        // Draw spark/hit effect
        ctx.globalAlpha = 1 - progress;
        
        // Particles radiating outward
        const particleCount = 8;
        const size = effect.size * progress;
        
        for (let i = 0; i < particleCount; i++) {
            const angle = (i / particleCount) * Math.PI * 2;
            const x = screenPos.x + Math.cos(angle) * size;
            const y = screenPos.y + Math.sin(angle) * size;
            
            ctx.beginPath();
            ctx.fillStyle = effect.color;
            ctx.arc(x, y, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Reset alpha
        ctx.globalAlpha = 1;
    }

    /**
     * Render an explosion effect
     */
    renderExplosionEffect(ctx, screenPos, effect, progress) {
        // Draw explosion effect
        ctx.globalAlpha = 1 - progress;
        
        // Outer ring
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255, 100, 0, 0.5)';
        ctx.arc(screenPos.x, screenPos.y, effect.size * progress * 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Inner ring
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255, 200, 0, 0.7)';
        ctx.arc(screenPos.x, screenPos.y, effect.size * progress, 0, Math.PI * 2);
        ctx.fill();
        
        // Reset alpha
        ctx.globalAlpha = 1;
    }

    /**
     * Render a default effect
     */
    renderDefaultEffect(ctx, screenPos, effect, progress) {
        // Simple fadeout circle
        ctx.globalAlpha = 1 - progress;
        ctx.beginPath();
        ctx.fillStyle = effect.color;
        ctx.arc(screenPos.x, screenPos.y, effect.size * (1 - progress), 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\RendererColyseus.js 
======================================== 
 
/**
 * Handles all rendering operations for the game with Colyseus integration
 */
class Renderer {
  /**
   * Initialize the renderer
   * @param {HTMLCanvasElement} canvas - The canvas element to render on
   */
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    
    // Isometric tile dimensions
    this.tileWidth = 64;
    this.tileHeight = 32;
    
    // Camera position and zoom
    this.cameraX = 0;
    this.cameraY = 0;
    this.zoom = 1;
    
    // Colors
    this.colors = {
      // Tile colors
      tile: '#8fbc8f',
      tileOutline: '#2e8b57',
      
      // Entity colors
      humanHero: '#0000ff',
      humanUnit: '#4169e1',
      humanBuilding: '#4682b4',
      
      aiHero: '#ff0000',
      aiUnit: '#ff4500',
      aiBuilding: '#8b0000',
      
      // Selection color
      selection: '#ffff00'
    };
    
    // Set canvas size
    this.handleResize();
    
    // Listen for window resize
    window.addEventListener('resize', () => this.handleResize());
  }
  
  /**
   * Clear the canvas
   */
  clear() {
    this.ctx.fillStyle = '#000000';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
  }
  
  /**
   * Handle window resize
   */
  handleResize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }
  
  /**
   * Convert grid coordinates to screen coordinates
   * @param {number} x - Grid x coordinate
   * @param {number} y - Grid y coordinate
   * @returns {Object} Screen coordinates {x, y}
   */
  gridToScreen(x, y) {
    // Isometric projection
    const screenX = (x - y) * this.tileWidth / 2;
    const screenY = (x + y) * this.tileHeight / 2;
    
    // Apply camera position and zoom
    return {
      x: (screenX - this.cameraX) * this.zoom + this.canvas.width / 2,
      y: (screenY - this.cameraY) * this.zoom + this.canvas.height / 2
    };
  }
  
  /**
   * Convert screen coordinates to grid coordinates
   * @param {number} screenX - Screen x coordinate
   * @param {number} screenY - Screen y coordinate
   * @returns {Object} Grid coordinates {x, y}
   */
  screenToGrid(screenX, screenY) {
    // Adjust for camera and zoom
    const adjustedX = (screenX - this.canvas.width / 2) / this.zoom + this.cameraX;
    const adjustedY = (screenY - this.canvas.height / 2) / this.zoom + this.cameraY;
    
    // Inverse isometric projection
    return {
      x: (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2,
      y: (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2
    };
  }
  
  /**
   * Render the map
   * @param {Array} map - Array of tile values
   */
  renderMap(map) {
    if (!map || !map.length) return;
    
    // Calculate map size (assuming square map)
    const mapSize = Math.sqrt(map.length);
    
    // Render tiles
    for (let y = 0; y < mapSize; y++) {
      for (let x = 0; x < mapSize; x++) {
        const index = y * mapSize + x;
        const tileType = map[index];
        
        this.renderTile(x, y, tileType);
      }
    }
  }
  
  /**
   * Render a single tile
   * @param {number} x - Grid x coordinate
   * @param {number} y - Grid y coordinate
   * @param {number} tileType - Type of tile
   */
  renderTile(x, y, tileType) {
    const screenPos = this.gridToScreen(x, y);
    
    // Draw tile
    this.drawIsometricTile(
      screenPos.x,
      screenPos.y,
      this.tileWidth * this.zoom,
      this.tileHeight * this.zoom,
      this.colors.tile
    );
    
    // Draw tile outline
    this.drawIsometricTileOutline(
      screenPos.x,
      screenPos.y,
      this.tileWidth * this.zoom,
      this.tileHeight * this.zoom,
      this.colors.tileOutline
    );
  }
  
  /**
   * Draw an isometric tile
   * @param {number} x - Screen x coordinate of tile center
   * @param {number} y - Screen y coordinate of tile center
   * @param {number} width - Tile width
   * @param {number} height - Tile height
   * @param {string} color - Tile color
   */
  drawIsometricTile(x, y, width, height, color) {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.moveTo(x, y - halfHeight); // Top
    this.ctx.lineTo(x + halfWidth, y); // Right
    this.ctx.lineTo(x, y + halfHeight); // Bottom
    this.ctx.lineTo(x - halfWidth, y); // Left
    this.ctx.closePath();
    this.ctx.fill();
  }
  
  /**
   * Draw an isometric tile outline
   * @param {number} x - Screen x coordinate of tile center
   * @param {number} y - Screen y coordinate of tile center
   * @param {number} width - Tile width
   * @param {number} height - Tile height
   * @param {string} color - Outline color
   */
  drawIsometricTileOutline(x, y, width, height, color) {
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    
    this.ctx.strokeStyle = color;
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.moveTo(x, y - halfHeight); // Top
    this.ctx.lineTo(x + halfWidth, y); // Right
    this.ctx.lineTo(x, y + halfHeight); // Bottom
    this.ctx.lineTo(x - halfWidth, y); // Left
    this.ctx.closePath();
    this.ctx.stroke();
  }
  
  /**
   * Render a hero
   * @param {Object} hero - Hero object
   * @param {boolean} isCurrentPlayer - Whether this hero belongs to the current player
   */
  renderHero(hero, isCurrentPlayer) {
    if (!hero || !hero.position) return;
    
    const screenPos = this.gridToScreen(hero.position.x, hero.position.y);
    const color = hero.owner === 'ai' ? this.colors.aiHero : this.colors.humanHero;
    
    // Draw hero as a circle
    this.ctx.fillStyle = color;
    this.ctx.beginPath();
    this.ctx.arc(
      screenPos.x,
      screenPos.y,
      this.tileWidth * 0.3 * this.zoom,
      0,
      Math.PI * 2
    );
    this.ctx.fill();
    
    // Draw outline for current player's hero
    if (isCurrentPlayer) {
      this.ctx.strokeStyle = this.colors.selection;
      this.ctx.lineWidth = 2;
      this.ctx.beginPath();
      this.ctx.arc(
        screenPos.x,
        screenPos.y,
        this.tileWidth * 0.35 * this.zoom,
        0,
        Math.PI * 2
      );
      this.ctx.stroke();
    }
    
    // Draw health bar
    this.renderHealthBar(
      screenPos.x,
      screenPos.y - this.tileHeight * 0.5 * this.zoom,
      this.tileWidth * 0.6 * this.zoom,
      this.tileHeight * 0.1 * this.zoom,
      hero.health / 100
    );
  }
  
  /**
   * Render a unit
   * @param {Object} unit - Unit object
   */
  renderUnit(unit) {
    if (!unit || !unit.position) return;
    
    const screenPos = this.gridToScreen(unit.position.x, unit.position.y);
    const color = unit.owner === 'ai' ? this.colors.aiUnit : this.colors.humanUnit;
    
    // Draw unit as a small square
    this.ctx.fillStyle = color;
    this.ctx.fillRect(
      screenPos.x - this.tileWidth * 0.2 * this.zoom,
      screenPos.y - this.tileHeight * 0.2 * this.zoom,
      this.tileWidth * 0.4 * this.zoom,
      this.tileHeight * 0.4 * this.zoom
    );
    
    // Draw health bar
    this.renderHealthBar(
      screenPos.x,
      screenPos.y - this.tileHeight * 0.3 * this.zoom,
      this.tileWidth * 0.4 * this.zoom,
      this.tileHeight * 0.1 * this.zoom,
      unit.health / 50
    );
  }
  
  /**
   * Render a building
   * @param {Object} building - Building object
   */
  renderBuilding(building) {
    if (!building || !building.position) return;
    
    const screenPos = this.gridToScreen(building.position.x, building.position.y);
    const color = building.owner === 'ai' ? this.colors.aiBuilding : this.colors.humanBuilding;
    
    // Draw building as a larger diamond
    this.drawIsometricTile(
      screenPos.x,
      screenPos.y,
      this.tileWidth * 1.5 * this.zoom,
      this.tileHeight * 1.5 * this.zoom,
      color
    );
    
    // Draw building outline
    this.drawIsometricTileOutline(
      screenPos.x,
      screenPos.y,
      this.tileWidth * 1.5 * this.zoom,
      this.tileHeight * 1.5 * this.zoom,
      this.darkenColor(color, 0.5)
    );
    
    // Draw health bar
    this.renderHealthBar(
      screenPos.x,
      screenPos.y - this.tileHeight * 0.8 * this.zoom,
      this.tileWidth * 0.8 * this.zoom,
      this.tileHeight * 0.1 * this.zoom,
      building.health / 200
    );
    
    // Draw build progress if not complete
    if (!building.isComplete) {
      this.renderBuildProgress(
        screenPos.x,
        screenPos.y - this.tileHeight * 0.6 * this.zoom,
        this.tileWidth * 0.8 * this.zoom,
        this.tileHeight * 0.1 * this.zoom,
        building.buildProgress / 100
      );
    }
  }
  
  /**
   * Render a health bar
   * @param {number} x - Screen x coordinate
   * @param {number} y - Screen y coordinate
   * @param {number} width - Bar width
   * @param {number} height - Bar height
   * @param {number} percentage - Health percentage (0-1)
   */
  renderHealthBar(x, y, width, height, percentage) {
    // Clamp percentage to 0-1
    percentage = Math.max(0, Math.min(1, percentage));
    
    // Bar background
    this.ctx.fillStyle = '#333333';
    this.ctx.fillRect(x - width / 2, y - height / 2, width, height);
    
    // Health bar color based on percentage
    let color;
    if (percentage > 0.6) {
      color = '#00ff00'; // Green
    } else if (percentage > 0.3) {
      color = '#ffff00'; // Yellow
    } else {
      color = '#ff0000'; // Red
    }
    
    // Health bar
    this.ctx.fillStyle = color;
    this.ctx.fillRect(
      x - width / 2,
      y - height / 2,
      width * percentage,
      height
    );
    
    // Outline
    this.ctx.strokeStyle = '#000000';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(x - width / 2, y - height / 2, width, height);
  }
  
  /**
   * Render a build progress bar
   * @param {number} x - Screen x coordinate
   * @param {number} y - Screen y coordinate
   * @param {number} width - Bar width
   * @param {number} height - Bar height
   * @param {number} percentage - Progress percentage (0-1)
   */
  renderBuildProgress(x, y, width, height, percentage) {
    // Clamp percentage to 0-1
    percentage = Math.max(0, Math.min(1, percentage));
    
    // Bar background
    this.ctx.fillStyle = '#333333';
    this.ctx.fillRect(x - width / 2, y - height / 2, width, height);
    
    // Progress bar
    this.ctx.fillStyle = '#0088ff';
    this.ctx.fillRect(
      x - width / 2,
      y - height / 2,
      width * percentage,
      height
    );
    
    // Outline
    this.ctx.strokeStyle = '#000000';
    this.ctx.lineWidth = 1;
    this.ctx.strokeRect(x - width / 2, y - height / 2, width, height);
  }
  
  /**
   * Render a selection highlight
   * @param {Object} entity - The selected entity
   */
  renderSelection(entity) {
    if (!entity || !entity.position) return;
    
    const screenPos = this.gridToScreen(entity.position.x, entity.position.y);
    
    this.ctx.strokeStyle = this.colors.selection;
    this.ctx.lineWidth = 2;
    
    if (entity.type === 'hero') {
      // Highlight hero with a circle
      this.ctx.beginPath();
      this.ctx.arc(
        screenPos.x,
        screenPos.y,
        this.tileWidth * 0.35 * this.zoom,
        0,
        Math.PI * 2
      );
      this.ctx.stroke();
    } else if (entity.type === 'unit') {
      // Highlight unit with a square
      this.ctx.strokeRect(
        screenPos.x - this.tileWidth * 0.25 * this.zoom,
        screenPos.y - this.tileHeight * 0.25 * this.zoom,
        this.tileWidth * 0.5 * this.zoom,
        this.tileHeight * 0.5 * this.zoom
      );
    } else {
      // Highlight building with a diamond
      const halfWidth = this.tileWidth * 0.75 * this.zoom;
      const halfHeight = this.tileHeight * 0.75 * this.zoom;
      
      this.ctx.beginPath();
      this.ctx.moveTo(screenPos.x, screenPos.y - halfHeight);
      this.ctx.lineTo(screenPos.x + halfWidth, screenPos.y);
      this.ctx.lineTo(screenPos.x, screenPos.y + halfHeight);
      this.ctx.lineTo(screenPos.x - halfWidth, screenPos.y);
      this.ctx.closePath();
      this.ctx.stroke();
    }
  }
  
  /**
   * Darken a color by a factor
   * @param {string} color - CSS color string
   * @param {number} factor - Darken factor (0-1)
   * @returns {string} Darkened color
   */
  darkenColor(color, factor) {
    // Simple darkening for hex colors
    if (color.startsWith('#')) {
      let r = parseInt(color.substr(1, 2), 16);
      let g = parseInt(color.substr(3, 2), 16);
      let b = parseInt(color.substr(5, 2), 16);
      
      r = Math.floor(r * (1 - factor));
      g = Math.floor(g * (1 - factor));
      b = Math.floor(b * (1 - factor));
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
    
    return color;
  }
  
  /**
   * Move the camera
   * @param {number} x - New x position
   * @param {number} y - New y position
   */
  moveCamera(x, y) {
    this.cameraX = x;
    this.cameraY = y;
  }
  
  /**
   * Pan the camera
   * @param {number} dx - Change in x
   * @param {number} dy - Change in y
   */
  panCamera(dx, dy) {
    this.cameraX += dx / this.zoom;
    this.cameraY += dy / this.zoom;
  }
  
  /**
   * Set camera zoom
   * @param {number} zoom - New zoom level
   */
  setZoom(zoom) {
    this.zoom = Math.max(0.5, Math.min(2, zoom));
  }
  
  /**
   * Adjust camera zoom
   * @param {number} delta - Change in zoom
   */
  adjustZoom(delta) {
    this.zoom = Math.max(0.5, Math.min(2, this.zoom + delta));
  }
}

export { Renderer };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\UIManager.js 
======================================== 
 
/**
 * Manages all UI elements and interactions
 */
class UIManager {
  /**
   * Initialize the UI manager
   * @param {Game} game - The main game instance
   */
  constructor(game) {
    this.game = game;
    
    // UI elements
    this.notification = null;
    this.notificationTimeout = null;
    
    // UI containers
    this.resourcesElement = document.getElementById('resources-container');
    this.selectionInfoElement = document.getElementById('selection-info');
    this.notificationElement = document.getElementById('notification');
    this.gameOverElement = document.getElementById('game-over');
    
    // Create UI containers if they don't exist
    this.createUIContainers();
    
    // Hide game over screen initially
    if (this.gameOverElement) {
      this.gameOverElement.style.display = 'none';
    }
  }
  
  /**
   * Create UI containers if they don't exist
   */
  createUIContainers() {
    // Create resources container
    if (!this.resourcesElement) {
      this.resourcesElement = document.createElement('div');
      this.resourcesElement.id = 'resources-container';
      this.resourcesElement.className = 'ui-container';
      document.body.appendChild(this.resourcesElement);
    }
    
    // Create selection info container
    if (!this.selectionInfoElement) {
      this.selectionInfoElement = document.createElement('div');
      this.selectionInfoElement.id = 'selection-info';
      this.selectionInfoElement.className = 'ui-container';
      document.body.appendChild(this.selectionInfoElement);
    }
    
    // Create notification container
    if (!this.notificationElement) {
      this.notificationElement = document.createElement('div');
      this.notificationElement.id = 'notification';
      this.notificationElement.className = 'ui-notification';
      document.body.appendChild(this.notificationElement);
    }
    
    // Create game over container
    if (!this.gameOverElement) {
      this.gameOverElement = document.createElement('div');
      this.gameOverElement.id = 'game-over';
      this.gameOverElement.className = 'ui-game-over';
      document.body.appendChild(this.gameOverElement);
    }
  }
  
  /**
   * Update UI elements based on game state
   */
  update() {
    // Update resources display
    this.updateResourcesDisplay();
    
    // Update selection info
    this.updateSelectionInfo(this.game.selectedEntities);
    
    // Update game time
    this.updateGameTime();
  }
  
  /**
   * Update resources display
   */
  updateResourcesDisplay() {
    if (!this.resourcesElement) return;
    
    // Get current player's resources
    const playerData = this.game.players.get(this.game.playerId);
    if (!playerData || !playerData.resources) return;
    
    // Update resources display
    this.resourcesElement.innerHTML = `
      <div class="resource-item">Wood: ${playerData.resources.wood}</div>
      <div class="resource-item">Stone: ${playerData.resources.stone}</div>
      <div class="resource-item">Food: ${playerData.resources.food}</div>
    `;
  }
  
  /**
   * Update selection info display
   * @param {Array} selectedEntities - Array of selected entities
   */
  updateSelectionInfo(selectedEntities) {
    if (!this.selectionInfoElement) return;
    
    // Clear selection info
    this.selectionInfoElement.innerHTML = '';
    
    // If no entities selected, show message
    if (!selectedEntities || selectedEntities.length === 0) {
      this.selectionInfoElement.innerHTML = '<div class="selection-empty">No selection</div>';
      return;
    }
    
    // Show info for each selected entity
    selectedEntities.forEach(entity => {
      let infoHTML = '';
      
      if (entity.type === 'hero') {
        infoHTML = `
          <div class="selection-header">Hero</div>
          <div class="selection-stats">Health: ${entity.health}/100</div>
        `;
      } else if (entity.type === 'unit') {
        infoHTML = `
          <div class="selection-header">Unit: ${entity.type}</div>
          <div class="selection-stats">Health: ${entity.health}/50</div>
        `;
      } else if (entity.type) {
        infoHTML = `
          <div class="selection-header">Building: ${entity.type}</div>
          <div class="selection-stats">Health: ${entity.health}/200</div>
          <div class="selection-stats">Build Progress: ${entity.isComplete ? 'Complete' : Math.floor(entity.buildProgress) + '%'}</div>
        `;
      }
      
      // Add actions based on entity type
      if (entity.type === 'barracks' && entity.isComplete) {
        infoHTML += `
          <div class="selection-actions">
            <button onclick="window.gameInstance.hireUnit('grunt', '${entity.id}')">Hire Grunt</button>
            <button onclick="window.gameInstance.hireUnit('scout', '${entity.id}')">Hire Scout</button>
          </div>
        `;
      } else if (entity.type === 'factory' && entity.isComplete) {
        infoHTML += `
          <div class="selection-actions">
            <button onclick="window.gameInstance.hireUnit('tank', '${entity.id}')">Hire Tank</button>
          </div>
        `;
      }
      
      // Create and append selection info element
      const selectionElement = document.createElement('div');
      selectionElement.className = 'selection-entity';
      selectionElement.innerHTML = infoHTML;
      this.selectionInfoElement.appendChild(selectionElement);
    });
  }
  
  /**
   * Update game time display
   */
  updateGameTime() {
    // Get time element or create it
    let timeElement = document.getElementById('game-time');
    if (!timeElement) {
      timeElement = document.createElement('div');
      timeElement.id = 'game-time';
      timeElement.className = 'ui-game-time';
      document.body.appendChild(timeElement);
    }
    
    // Convert seconds to minutes and seconds
    const minutes = Math.floor(this.game.gameTime / 60);
    const seconds = this.game.gameTime % 60;
    
    // Format time as MM:SS
    const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    // Update time display
    timeElement.textContent = formattedTime;
  }
  
  /**
   * Show a notification message
   * @param {string} message - The message to show
   * @param {number} duration - Duration in milliseconds to show the notification
   */
  showNotification(message, duration = 3000) {
    if (!this.notificationElement) return;
    
    // Clear any existing timeout
    if (this.notificationTimeout) {
      clearTimeout(this.notificationTimeout);
    }
    
    // Show notification
    this.notificationElement.textContent = message;
    this.notificationElement.style.display = 'block';
    
    // Hide notification after duration
    this.notificationTimeout = setTimeout(() => {
      this.notificationElement.style.display = 'none';
    }, duration);
  }
  
  /**
   * Show game over screen
   * @param {Object} data - Game over data including winner and stats
   */
  showGameOver(data) {
    if (!this.gameOverElement) return;
    
    // Create game over content
    let content = '';
    
    if (data.winner === 'human') {
      content = `
        <h2>Victory!</h2>
        <p>Humans have defeated the AI!</p>
      `;
    } else if (data.winner === 'ai') {
      content = `
        <h2>Defeat!</h2>
        <p>The AI has overwhelmed the humans!</p>
      `;
    } else {
      content = `
        <h2>Draw!</h2>
        <p>Time has run out with no clear winner.</p>
      `;
    }
    
    // Add stats
    content += `
      <div class="game-stats">
        <div>Game Time: ${Math.floor(data.gameTime / 60)}:${(data.gameTime % 60).toString().padStart(2, '0')}</div>
        <div>Human Base Health: ${data.humanBaseHealth}/1000</div>
        <div>AI Base Health: ${data.aiBaseHealth}/1000</div>
      </div>
      <button id="play-again">Play Again</button>
    `;
    
    // Set content and show game over screen
    this.gameOverElement.innerHTML = content;
    this.gameOverElement.style.display = 'flex';
    
    // Add play again button listener
    const playAgainButton = document.getElementById('play-again');
    if (playAgainButton) {
      playAgainButton.addEventListener('click', () => {
        // Reload the page to start a new game
        window.location.reload();
      });
    }
  }
}

export { UIManager };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\UnitImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing unit images
 */
class UnitImageLoader {
    /**
     * Initialize the unit image loader
     */
    constructor() {
        // Unit types
        this.unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];
        
        // Store loaded images
        this.images = {};
        
        // Load all unit images
        this.loadUnitImages();
        
        console.log('UnitImageLoader initialized');
    }
    
    /**
     * Load all unit images
     */
    loadUnitImages() {
        this.unitTypes.forEach(unitType => {
            const img = new Image();
            img.src = `/images/units/${unitType.toLowerCase()}.png`;
            this.images[unitType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded unit image: ${unitType}`);
            img.onerror = () => console.warn(`Failed to load unit image: ${unitType}`);
        });
    }
    
    /**
     * Get the image for a specific unit type
     */
    getUnitImage(unitType) {
        return this.images[unitType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Map.js 
======================================== 
 
/**
 * Manages the game map
 */
class Map {
    /**
     * Initialize the map
     */
    constructor() {
        this.width = Config.MAP_WIDTH;
        this.height = Config.MAP_HEIGHT;
        this.tiles = [];
        
        // Initialize with empty tiles
        this.initializeEmptyTiles();
        
        // Preload tile images
        this.tileImages = {};
        this.preloadTileImages();
    }
    
    /**
     * Preload tile images for different terrain types
     */
    preloadTileImages() {
        const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        terrainTypes.forEach(terrainType => {
            const img = new Image();
            img.src = `/images/terraintiles/${terrainType}.png`;
            this.tileImages[terrainType] = img;
        });
    }
    
    /**
     * Initialize empty tiles
     */
    initializeEmptyTiles() {
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                // Initialize with grass tiles as a fallback
                this.tiles[y][x] = new Tile('grass');
            }
        }
        console.log('Initialized empty map');
    }
    
    /**
     * Set the map data from the server
     */
    setMapFromServer(mapData) {
        console.log('Received map data from server', mapData ? 'valid' : 'invalid');
        
        if (!mapData || !Array.isArray(mapData) || mapData.length === 0) {
            console.error('Invalid map data from server');
            return;
        }
        
        this.height = mapData.length;
        this.width = mapData[0].length;
        
        console.log(`Setting map from server data: ${this.width}x${this.height}`);
        
        // Convert server map data to our tile format
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                if (!mapData[y] || !mapData[y][x]) {
                    console.error(`Missing tile data at ${x},${y}`);
                    this.tiles[y][x] = new Tile('grass');
                    continue;
                }
                
                const serverTile = mapData[y][x];
                // Use terrainType if available, fall back to type for backward compatibility
                const terrainType = serverTile.terrainType || serverTile.type || 'grass';
                this.tiles[y][x] = new Tile(terrainType);
                
                // Use passable if available, fall back to walkable for backward compatibility
                this.tiles[y][x].walkable = serverTile.passable !== undefined ? 
                    serverTile.passable : 
                    (serverTile.walkable !== undefined ? 
                        serverTile.walkable : 
                        (terrainType !== 'water' && terrainType !== 'mountain'));
                
                // Store elevation if available
                if (serverTile.elevation !== undefined) {
                    this.tiles[y][x].elevation = serverTile.elevation;
                }
            }
        }
        
        console.log('Map set from server data');
    }
    
    /**
     * Get the tile at the specified coordinates
     */
    getTile(x, y) {
        // Check bounds
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
            return null;
        }
        
        // Check if tiles array is properly initialized
        if (!this.tiles || !this.tiles[y] || !this.tiles[y][x]) {
            console.warn(`Tile at ${x},${y} is not initialized`);
            return new Tile('grass'); // Return a default tile
        }
        
        return this.tiles[y][x];
    }
    
    /**
     * Get the tile image for a specific terrain type
     */
    getTileImage(terrainType) {
        return this.tileImages[terrainType] || this.tileImages['grass'];
    }
    
    /**
     * Convert grid coordinates to isometric world coordinates
     */
    gridToIso(x, y) {
        return {
            x: (x - y) * (Config.TILE_SIZE / 2),
            y: (x + y) * (Config.TILE_SIZE / 4)
        };
    }
    
    /**
     * Convert isometric world coordinates to grid coordinates
     */
    isoToGrid(x, y) {
        const tileHalfWidth = Config.TILE_SIZE / 2;
        const tileQuarterHeight = Config.TILE_SIZE / 4;
        
        return {
            x: Math.floor((x / tileHalfWidth + y / tileQuarterHeight) / 2),
            y: Math.floor((y / tileQuarterHeight - x / tileHalfWidth) / 2)
        };
    }
    
    /**
     * Check if a tile is walkable
     */
    isWalkable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.walkable;
    }
    
    /**
     * Check if a tile is buildable
     */
    isBuildable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.buildable;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Tile.js 
======================================== 
 
/**
 * Represents a single tile on the game map
 */
class Tile {
    /**
     * Initialize a tile
     */
    constructor(terrainType = 'grass') {
        // Ensure valid tile type
        this.type = this.validateTerrainType(terrainType);
        this.terrainType = this.type; // For consistency with server data
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
        this.resourceType = this.getResourceType(this.type);
        this.resourceAmount = this.resourceType ? Math.floor(Math.random() * 500) + 500 : 0;
        this.elevation = 0; // Default elevation
    }
    
    /**
     * Validate and normalize terrain type
     */
    validateTerrainType(type) {
        const validTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        if (!type || typeof type !== 'string') {
            console.warn(`Invalid tile type: ${type}, defaulting to grass`);
            return 'grass';
        }
        
        const normalizedType = type.toLowerCase();
        
        if (!validTypes.includes(normalizedType)) {
            console.warn(`Unknown tile type: ${normalizedType}, defaulting to grass`);
            return 'grass';
        }
        
        return normalizedType;
    }
    
    /**
     * Determine if a tile type is walkable
     */
    isWalkable(type) {
        switch (type) {
            case 'water':
            case 'mountain':
                return false;
            case 'grass':
            case 'sand':
            case 'forest':
                return true;
            default:
                return true;
        }
    }
    
    /**
     * Determine if a tile type is buildable
     */
    isBuildable(type) {
        switch (type) {
            case 'grass':
            case 'sand':
                return true;
            case 'water':
            case 'mountain':
            case 'forest':
                return false;
            default:
                return false;
        }
    }
    
    /**
     * Get resource type for a tile if applicable
     */
    getResourceType(type) {
        switch (type) {
            case 'forest':
                return 'wood';
            case 'mountain':
                return 'stone';
            default:
                return null;
        }
    }
    
    /**
     * Extract resources from the tile
     */
    extractResource(amount) {
        if (!this.resourceType || this.resourceAmount <= 0) {
            return 0;
        }
        
        const extracted = Math.min(amount, this.resourceAmount);
        this.resourceAmount -= extracted;
        
        // If resources are depleted, change the tile type
        if (this.resourceAmount <= 0) {
            this.depleteResource();
        }
        
        return extracted;
    }
    
    /**
     * Handle resource depletion
     */
    depleteResource() {
        switch (this.resourceType) {
            case 'wood':
                this.type = 'grass';
                this.terrainType = 'grass';
                break;
            case 'stone':
                this.type = 'mountain';
                this.terrainType = 'mountain';
                break;
            default:
                break;
        }
        
        this.resourceType = null;
        this.resourceAmount = 0;
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateDetailedImages.js 
======================================== 
 
/**
 * Script to generate detailed images for units and buildings
 * This creates visually appealing assets for the game
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

/**
 * Generate a detailed unit image
 */
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Generate a detailed building image
 */
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Helper function to draw an isometric building
 */
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

/**
 * Helper function to darken a color
 */
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

/**
 * Function to save an image
 */
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

/**
 * Generate and save unit images
 */
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

/**
 * Generate and save building images
 */
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating detailed images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: public/images/units/');
console.log('   - Building images: public/images/buildings/');
console.log('2. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateImages.js 
======================================== 
 
const fs = require('fs');
const path = require('path');
const { createCanvas } = require('canvas');

// Create directories if they don't exist
const unitsDir = path.join(__dirname, '../../public/images/units');
const buildingsDir = path.join(__dirname, '../../public/images/buildings');

if (!fs.existsSync(unitsDir)) {
    fs.mkdirSync(unitsDir, { recursive: true });
}

if (!fs.existsSync(buildingsDir)) {
    fs.mkdirSync(buildingsDir, { recursive: true });
}

// Create a canvas
const canvas = createCanvas(64, 64);
const ctx = canvas.getContext('2d');

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Helper function to draw an isometric building
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(canvas, filename) {
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(filename, buffer);
    console.log(`Generated: ${filename}`);
}

// Generate and save unit images
function generateUnitImages() {
    console.log('Generating unit images...');
    
    unitTypes.forEach(unitType => {
        const canvas = generateUnitImage(unitType);
        const filename = path.join(unitsDir, `${unitType.toLowerCase()}.png`);
        saveImage(canvas, filename);
    });
    
    console.log('Unit image generation complete!');
}

// Generate and save building images
function generateBuildingImages() {
    console.log('Generating building images...');
    
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const canvas = generateBuildingImage(buildingType);
        const filename = path.join(buildingsDir, `${buildingType.toLowerCase()}.png`);
        saveImage(canvas, filename);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredCanvas = generateBuildingImage(buildingType, color);
            const coloredFilename = path.join(buildingsDir, `${buildingType.toLowerCase()}_${color}.png`);
            saveImage(coloredCanvas, coloredFilename);
        });
    });
    
    console.log('Building image generation complete!');
}

// Generate all images
function generateAllImages() {
    generateUnitImages();
    generateBuildingImages();
}

// Run the generator
generateAllImages();  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generatePlaceholderImages.js 
======================================== 
 
/**
 * Script to generate placeholder images for units and buildings
 * Run this script to create basic placeholder images until proper assets are available
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set background color based on unit type
    let color;
    switch(unitType) {
        case 'SOLDIER': color = '#3366cc'; break;
        case 'ARCHER': color = '#33cc33'; break;
        case 'CAVALRY': color = '#cc3333'; break;
        case 'TANK': color = '#666666'; break;
        case 'WORKER': color = '#cc9933'; break;
        default: color = '#3366cc';
    }
    
    // Draw isometric unit shape
    ctx.fillStyle = color;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Add details based on unit type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add unit type initial
    ctx.fillText(unitType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set base color based on building type
    let baseColor;
    switch(buildingType) {
        case 'BASE': baseColor = '#666699'; break;
        case 'BARRACKS': baseColor = '#996666'; break;
        case 'TOWER': baseColor = '#669966'; break;
        case 'FARM': baseColor = '#999966'; break;
        case 'MINE': baseColor = '#666666'; break;
        default: baseColor = '#666699';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red': baseColor = '#cc3333'; break;
            case 'blue': baseColor = '#3366cc'; break;
            case 'green': baseColor = '#33cc33'; break;
            case 'yellow': baseColor = '#cccc33'; break;
        }
    }
    
    // Draw isometric building
    // Base
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Right face (darker)
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(48, 32); // Right middle
    ctx.lineTo(48, 40); // Right bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Left face (darkest)
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(16, 32); // Left middle
    ctx.lineTo(16, 40); // Left bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Add details based on building type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add building type initial
    ctx.fillText(buildingType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Generate and save unit images
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

// Generate and save building images
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating placeholder images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: assets/units/');
console.log('   - Building images: assets/buildings/');
console.log('2. Make sure the folder structure exists');
console.log('3. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\utils\helpers.js 
======================================== 
 
/**
 * Utility functions for the game
 */

/**
 * Calculate distance between two points
 */
function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation between two values
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}

/**
 * Generate a random integer between min and max (inclusive)
 */
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Check if a point is inside a rectangle
 */
function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

/**
 * Check if two rectangles overlap
 */
function rectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h) {
    return (
        r1x < r2x + r2w &&
        r1x + r1w > r2x &&
        r1y < r2y + r2h &&
        r1y + r1h > r2y
    );
}

/**
 * Convert degrees to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Convert radians to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Calculate the angle between two points (in radians)
 */
function angleBetweenPoints(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
}

/**
 * Get a point on a circle given center, radius, and angle
 */
function pointOnCircle(centerX, centerY, radius, angleRadians) {
    return {
        x: centerX + radius * Math.cos(angleRadians),
        y: centerY + radius * Math.sin(angleRadians)
    };
}

/**
 * Shuffle an array (Fisher-Yates algorithm)
 */
function shuffleArray(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Format time in seconds to MM:SS format
 */
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Ease in-out function (smooth acceleration and deceleration)
 */
function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Get a random element from an array
 */
function randomArrayElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

/**
 * Check if a value is between min and max (inclusive)
 */
function isBetween(value, min, max) {
    return value >= min && value <= max;
}

/**
 * Calculate the Manhattan distance between two points
 */
function manhattanDistance(x1, y1, x2, y2) {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1);
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\utils\Quadtree.js 
======================================== 
 
/**
 * Quadtree for spatial partitioning of game entities
 * Optimized for isometric rendering and camera visibility queries
 */
class Quadtree {
    /**
     * Create a new quadtree
     * @param {Object} bounds - {x, y, width, height}
     * @param {number} maxObjects - Max objects per node before splitting
     * @param {number} maxLevels - Max subdivision levels
     * @param {number} level - Current level (for internal use)
     */
    constructor(bounds, maxObjects = 10, maxLevels = 4, level = 0) {
        this.bounds = bounds;
        this.maxObjects = maxObjects;
        this.maxLevels = maxLevels;
        this.level = level;
        this.objects = [];
        this.nodes = [];
    }

    /**
     * Split the node into four quadrants
     */
    split() {
        const nextLevel = this.level + 1;
        const subWidth = this.bounds.width / 2;
        const subHeight = this.bounds.height / 2;
        const x = this.bounds.x;
        const y = this.bounds.y;

        // Top right
        this.nodes[0] = new Quadtree(
            { x: x + subWidth, y: y, width: subWidth, height: subHeight },
            this.maxObjects,
            this.maxLevels,
            nextLevel
        );

        // Top left
        this.nodes[1] = new Quadtree(
            { x: x, y: y, width: subWidth, height: subHeight },
            this.maxObjects,
            this.maxLevels,
            nextLevel
        );

        // Bottom left
        this.nodes[2] = new Quadtree(
            { x: x, y: y + subHeight, width: subWidth, height: subHeight },
            this.maxObjects,
            this.maxLevels,
            nextLevel
        );

        // Bottom right
        this.nodes[3] = new Quadtree(
            { x: x + subWidth, y: y + subHeight, width: subWidth, height: subHeight },
            this.maxObjects,
            this.maxLevels,
            nextLevel
        );
    }

    /**
     * Determine which node the object belongs to
     * @param {Object} rect - {x, y, width, height}
     * @returns {number} - Index of the subnode (0-3), or -1 if object cannot completely fit in a subnode
     */
    getIndex(rect) {
        let index = -1;
        const verticalMidpoint = this.bounds.x + (this.bounds.width / 2);
        const horizontalMidpoint = this.bounds.y + (this.bounds.height / 2);

        // Object can completely fit within the top quadrants
        const topQuadrant = (rect.y < horizontalMidpoint && rect.y + rect.height < horizontalMidpoint);
        // Object can completely fit within the bottom quadrants
        const bottomQuadrant = (rect.y > horizontalMidpoint);

        // Object can completely fit within the left quadrants
        if (rect.x < verticalMidpoint && rect.x + rect.width < verticalMidpoint) {
            if (topQuadrant) {
                index = 1;
            } else if (bottomQuadrant) {
                index = 2;
            }
        }
        // Object can completely fit within the right quadrants
        else if (rect.x > verticalMidpoint) {
            if (topQuadrant) {
                index = 0;
            } else if (bottomQuadrant) {
                index = 3;
            }
        }

        return index;
    }

    /**
     * Insert an object into the quadtree
     * @param {Object} object - {x, y, width, height, ...}
     */
    insert(object) {
        // If we have subnodes, try to insert into them
        if (this.nodes.length) {
            const index = this.getIndex(object);

            if (index !== -1) {
                this.nodes[index].insert(object);
                return;
            }
        }

        // If it doesn't fit into a subnode or we don't have subnodes, add it to this node
        this.objects.push(object);

        // Split if we exceed the capacity and haven't reached max levels
        if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
            // Split if we don't already have subnodes
            if (!this.nodes.length) {
                this.split();
            }

            // Attempt to redistribute objects to subnodes
            for (let i = 0; i < this.objects.length; i++) {
                const index = this.getIndex(this.objects[i]);
                if (index !== -1) {
                    this.nodes[index].insert(this.objects.splice(i, 1)[0]);
                    i--;
                }
            }
        }
    }

    /**
     * Get all objects that could collide with the given rect
     * @param {Object} rect - {x, y, width, height}
     * @returns {Array} - Array of objects that could collide
     */
    retrieve(rect) {
        let returnObjects = [];
        const index = this.getIndex(rect);

        // If we have subnodes and this object could fit in a subnode, check there
        if (this.nodes.length) {
            // If the object fits into a subnode, retrieve from there
            if (index !== -1) {
                returnObjects = returnObjects.concat(this.nodes[index].retrieve(rect));
            } else {
                // If the object doesn't fit into a specific subnode, check all subnodes
                for (let i = 0; i < this.nodes.length; i++) {
                    returnObjects = returnObjects.concat(this.nodes[i].retrieve(rect));
                }
            }
        }

        // Return all objects in this node
        returnObjects = returnObjects.concat(this.objects);
        return returnObjects;
    }

    /**
     * Get all objects that intersect the given rectangle
     * @param {Object} rect - {x, y, width, height}
     * @returns {Array} - Array of objects that intersect
     */
    query(rect) {
        // First, get all potential objects using retrieve
        const potentialObjects = this.retrieve(rect);
        
        // Then filter out objects that don't actually intersect
        return potentialObjects.filter(object => this.intersects(rect, object));
    }

    /**
     * Check if two rectangles intersect
     * @param {Object} rect1 - {x, y, width, height}
     * @param {Object} rect2 - {x, y, width, height}
     * @returns {boolean} - True if the rectangles intersect
     */
    intersects(rect1, rect2) {
        return !(
            rect1.x > rect2.x + rect2.width ||
            rect1.x + rect1.width < rect2.x ||
            rect1.y > rect2.y + rect2.height ||
            rect1.y + rect1.height < rect2.y
        );
    }

    /**
     * Clear the quadtree, removing all objects and subnodes
     */
    clear() {
        this.objects = [];

        for (let i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i]) {
                this.nodes[i].clear();
            }
        }

        this.nodes = [];
    }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { Quadtree };
} else {
    // For browser use
    window.Quadtree = Quadtree;
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\server\index.js 
======================================== 
 
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

// Create Express app and HTTP server
const app = express();
const server = http.createServer(app);

// Create Socket.IO server with CORS enabled
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST']
  }
});

// Game state management
const gameState = {
  players: {},
  entities: {},
  map: null,
  mapDimensions: { width: 40, height: 40, zoomFactor: 1.5 },
  lastUpdateTime: Date.now(),
  serverStartTime: Date.now(),
  isRunning: false,
  gameEndTime: null,
  countdown: null,
  winner: null,
  playersForNextGame: []
};

// Function to start the game
function startGame() {
  console.log('Starting game...');
  
  // Reset game state
  gameState.players = {};
  gameState.entities = {};
  gameState.isRunning = true;
  gameState.serverStartTime = Date.now();
  gameState.lastUpdateTime = Date.now();
  gameState.mapDimensions = getMapDimensions(0); // Initialize with default dimensions
  gameState.gameEndTime = null;
  gameState.countdown = null;
  gameState.winner = null;
  gameState.playersForNextGame = [];
  
  // Generate initial map
  console.log('Generating initial map...');
  gameState.map = generateMap(gameState.mapDimensions.width, gameState.mapDimensions.height);
  
  // Initialize game with bases
  console.log('Initializing game with bases...');
  initializeGame();
  
  // Notify all connected clients
  console.log('Notifying clients of game start...');
  io.emit('serverStarted', {
    message: 'Game started',
    gameState: {
      players: gameState.players,
      entities: gameState.entities,
      map: gameState.map,
      mapDimensions: gameState.mapDimensions,
      lastUpdateTime: gameState.lastUpdateTime,
      serverStartTime: gameState.serverStartTime
    }
  });
  
  console.log('Game started successfully');
}

// Function to stop the game
function stopGame() {
  console.log('Stopping game...');
  
  // Notify all clients before clearing state
  io.emit('serverShutdown', { 
    message: 'Server is shutting down. Please wait for reconnection.' 
  });
  
  // Clear game state
  gameState.isRunning = false;
  gameState.players = {};
  gameState.entities = {};
  
  console.log('Game stopped successfully');
}

// Start game on server initialization
startGame();

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('Received SIGTERM signal');
  stopGame();
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('Received SIGINT signal');
  stopGame();
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});

// Server startup event
server.on('listening', () => {
  console.log(`Server started on port ${process.env.PORT || 3000}`);
  startGame(); // Ensure game is started when server is ready
});

// Serve static files from the public directory
app.use(express.static(path.join(__dirname, '../public')));
app.use('/src', express.static(path.join(__dirname, '../src')));

// Serve the main HTML file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '../public/index.html'));
});

// Redirect from /public to root for backward compatibility
app.get('/public', (req, res) => {
  res.redirect('/');
});

app.get('/public/index.html', (req, res) => {
  res.redirect('/');
});

// Function to determine map size based on player count
function getMapDimensions(playerCount) {
  if (playerCount <= 5) {
    return { 
      width: 100, 
      height: 100,
      zoomFactor: 1.5 // Higher zoom factor for smaller maps
    };
  } else if (playerCount <= 15) {
    return { 
      width: 200, 
      height: 200,
      zoomFactor: 1.0 // Medium zoom factor
    };
  } else {
    return { 
      width: 400, 
      height: 400,
      zoomFactor: 0.75 // Lower zoom factor for larger maps
    };
  }
}

// Generate a random map
function generateMap(width, height) {
  console.log(`Generating map with dimensions ${width}x${height}`);
  
  const tiles = [];
  const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
  const terrainWeights = [0.65, 0.15, 0.1, 0.08, 0.02]; // Adjusted probabilities for each terrain type
  
  // Generate a seed for consistent random generation
  let seed = Math.floor(Math.random() * 1000000);
  
  // Simple random number generator with seed
  const seededRandom = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
  
  // Create noise functions for terrain generation
  const createNoiseGenerator = (scale, amplitude, octaves) => {
    const offsets = Array(octaves).fill().map(() => ({
      x: seededRandom() * 1000,
      y: seededRandom() * 1000
    }));
    
    return (x, y) => {
      let value = 0;
      let totalAmplitude = 0;
      
      for (let i = 0; i < octaves; i++) {
        const currentScale = scale * Math.pow(2, i);
        const currentAmplitude = amplitude * Math.pow(0.5, i);
        
        const nx = (x / currentScale) + offsets[i].x;
        const ny = (y / currentScale) + offsets[i].y;
        
        // Simple value noise
        const sampleX = Math.floor(nx);
        const sampleY = Math.floor(ny);
        const fracX = nx - sampleX;
        const fracY = ny - sampleY;
        
        // Generate 4 corner values
        const hash1 = (sampleX * 12345 + sampleY * 54321) % 123456;
        const hash2 = ((sampleX + 1) * 12345 + sampleY * 54321) % 123456;
        const hash3 = (sampleX * 12345 + (sampleY + 1) * 54321) % 123456;
        const hash4 = ((sampleX + 1) * 12345 + (sampleY + 1) * 54321) % 123456;
        
        const val1 = (hash1 / 123456) * 2 - 1;
        const val2 = (hash2 / 123456) * 2 - 1;
        const val3 = (hash3 / 123456) * 2 - 1;
        const val4 = (hash4 / 123456) * 2 - 1;
        
        // Bilinear interpolation
        const v1 = val1 + fracX * (val2 - val1);
        const v2 = val3 + fracX * (val4 - val3);
        const noise = v1 + fracY * (v2 - v1);
        
        value += noise * currentAmplitude;
        totalAmplitude += currentAmplitude;
      }
      
      // Normalize to [0, 1]
      return (value / totalAmplitude + 1) / 2;
    };
  };
  
  const elevationNoise = createNoiseGenerator(10, 1.0, 3);
  const moistureNoise = createNoiseGenerator(15, 1.0, 2);
  const resourceNoise = createNoiseGenerator(8, 1.0, 2);
  
  // Generate initial random tiles in an isometric layout
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      // Calculate isometric coordinates
      // In an isometric layout, the diamond shape comes from how we interpret the coordinates
      // The actual data structure remains a 2D grid
      
      // Get noise values for this position
      const elevation = Math.floor(elevationNoise(x, y) * 4); // 0-3 elevation
      const moisture = moistureNoise(x, y);
      const resourceValue = resourceNoise(x, y);
      
      // Determine terrain type based on elevation and moisture
      let terrainType;
      let passable = true;
      
      if (elevation === 0 && moisture > 0.7) {
        // Low elevation with high moisture = water
        terrainType = 'water';
        passable = false;
      } else if (elevation === 3 && moisture < 0.4) {
        // High elevation with low moisture = mountain
        terrainType = 'mountain';
        passable = false;
      } else if (elevation === 2 && moisture > 0.6) {
        // Medium-high elevation with high moisture = forest
        terrainType = 'forest';
        passable = true;
      } else if (elevation === 1 && moisture < 0.3) {
        // Low-medium elevation with low moisture = sand
        terrainType = 'sand';
        passable = true;
      } else {
        // Default is grass
        terrainType = 'grass';
        passable = true;
      }
      
      // Create the tile with the new data structure
      row.push({
        x: x,
        y: y,
        terrainType: terrainType,
        passable: passable,
        elevation: elevation,
        // Keep the old properties for backward compatibility
        type: terrainType,
        walkable: passable
      });
    }
    tiles.push(row);
  }
  
  // Apply some smoothing to make the map more natural
  const smoothedTiles = JSON.parse(JSON.stringify(tiles)); // Deep copy
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      // Count neighboring terrain types
      const neighbors = {};
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const neighborType = tiles[ny][nx].terrainType;
            neighbors[neighborType] = (neighbors[neighborType] || 0) + 1;
          }
        }
      }
      
      // Find most common neighbor type
      let mostCommonType = tiles[y][x].terrainType;
      let maxCount = 0;
      
      for (const type in neighbors) {
        if (neighbors[type] > maxCount) {
          maxCount = neighbors[type];
          mostCommonType = type;
        }
      }
      
      // 50% chance to change to most common neighbor type
      if (maxCount > 4 && seededRandom() < 0.5) {
        smoothedTiles[y][x].terrainType = mostCommonType;
        smoothedTiles[y][x].type = mostCommonType; // For backward compatibility
        
        // Update passable status based on terrain type
        smoothedTiles[y][x].passable = mostCommonType !== 'water' && mostCommonType !== 'mountain';
        smoothedTiles[y][x].walkable = smoothedTiles[y][x].passable; // For backward compatibility
        
        // Adjust elevation based on new terrain type
        if (mostCommonType === 'mountain') {
          smoothedTiles[y][x].elevation = 3;
        } else if (mostCommonType === 'forest') {
          smoothedTiles[y][x].elevation = 2;
        } else if (mostCommonType === 'water') {
          smoothedTiles[y][x].elevation = 0;
        }
      }
    }
  }
  
  console.log('Map generation complete');
  return smoothedTiles;
}

// Function to initialize the game with bases and AI unit
function initializeGame() {
    console.log('Initializing game with shared human base');

    // Create shared human base in the bottom-left quadrant
    const humanBaseId = uuidv4();
    const humanBaseX = Math.floor(gameState.mapDimensions.width * 0.25);
    const humanBaseY = Math.floor(gameState.mapDimensions.height * 0.75);

    // Define the human base, shared by all players
    gameState.entities[humanBaseId] = {
        id: humanBaseId,
        type: 'building',
        buildingType: 'BASE',
        playerColor: 'blue',
        x: humanBaseX * 32,
        y: humanBaseY * 32,
        width: 5 * 32,
        height: 5 * 32,
        playerId: 'human-team',  // Shared team ID, not tied to a single player
        isPlayerControlled: true,
        health: 1000,
        maxHealth: 1000
    };

    console.log('Initialized shared human base for team "human-team"');

    // Create AI base in the top-right quadrant
    const aiBaseId = uuidv4();
    const aiBaseX = Math.floor(gameState.mapDimensions.width * 0.75);
    const aiBaseY = Math.floor(gameState.mapDimensions.height * 0.25);

    // Make sure the base locations are walkable
    makeAreaWalkable(humanBaseX, humanBaseY, 5, 5);
    makeAreaWalkable(aiBaseX, aiBaseY, 5, 5);

    // Add AI base to entities
    gameState.entities[aiBaseId] = {
        id: aiBaseId,
        type: 'building',
        buildingType: 'BASE',
        playerColor: 'red',
        x: aiBaseX * 32,
        y: aiBaseY * 32,
        width: 5 * 32,
        height: 5 * 32,
        playerId: 'ai-team',
        isPlayerControlled: false,
        health: 1000,
        maxHealth: 1000
    };

    // Create an AI unit near the AI base
    const aiUnitId = uuidv4();
    gameState.entities[aiUnitId] = {
        id: aiUnitId,
        type: 'unit',
        unitType: 'SOLDIER',
        playerColor: 'red',
        x: aiBaseX * 32 - 64,
        y: aiBaseY * 32 + 80,
        width: 32,
        height: 32,
        playerId: 'ai-team',
        isPlayerControlled: false,
        health: 100,
        maxHealth: 100,
        attackDamage: 10,
        attackRange: 50,
        attackCooldown: 1000,
        speed: 20,
        level: 1,
        experience: 0,
        targetX: null,
        targetY: null,
        isMoving: false,
        lastUpdateTime: Date.now()
    };

    console.log('Game initialized with shared human base and AI entities');
}

// Function to make an area walkable (for base placement)
function makeAreaWalkable(centerX, centerY, width, height) {
  const halfWidth = Math.floor(width / 2);
  const halfHeight = Math.floor(height / 2);
  
  for (let y = centerY - halfHeight; y <= centerY + halfHeight; y++) {
    for (let x = centerX - halfWidth; x <= centerX + halfWidth; x++) {
      if (y >= 0 && y < gameState.map.length && x >= 0 && x < gameState.map[0].length) {
        gameState.map[y][x].terrainType = 'grass';
        gameState.map[y][x].type = 'grass'; // For backward compatibility
        gameState.map[y][x].passable = true;
        gameState.map[y][x].walkable = true; // For backward compatibility
        gameState.map[y][x].elevation = 1;
      }
    }
  }
}

// Function to check if map needs to be resized based on player count
function checkAndResizeMap() {
  const playerCount = Object.values(gameState.players).filter(player => player.connected).length;
  const newDimensions = getMapDimensions(playerCount);
  
  // Check if dimensions have changed
  if (newDimensions.width !== gameState.mapDimensions.width || 
      newDimensions.height !== gameState.mapDimensions.height) {
    
    console.log(`Resizing map from ${gameState.mapDimensions.width}x${gameState.mapDimensions.height} (zoom: ${gameState.mapDimensions.zoomFactor}) to ${newDimensions.width}x${newDimensions.height} (zoom: ${newDimensions.zoomFactor}) based on ${playerCount} players`);
    
    // Save old entities
    const oldEntities = { ...gameState.entities };
    
    // Update map dimensions
    gameState.mapDimensions = newDimensions;
    
    // Generate new map
    gameState.map = generateMap(newDimensions.width, newDimensions.height);
    
    // Clear entities
    gameState.entities = {};
    
    // Re-initialize game with bases
    initializeGame();
    
    // Restore player units with adjusted positions
    Object.values(oldEntities).forEach(entity => {
      if (entity.type === 'unit' && entity.playerId !== 'ai') {
        // Calculate relative position in the old map
        const oldMapWidth = gameState.map[0].length * 32;
        const oldMapHeight = gameState.map.length * 32;
        const relativeX = entity.x / oldMapWidth;
        const relativeY = entity.y / oldMapHeight;
        
        // Calculate new position in the new map
        const newMapWidth = newDimensions.width * 32;
        const newMapHeight = newDimensions.height * 32;
        const newX = Math.floor(relativeX * newMapWidth);
        const newY = Math.floor(relativeY * newMapHeight);
        
        // Create a new entity with adjusted position
        const newEntityId = uuidv4();
        gameState.entities[newEntityId] = {
          ...entity,
          id: newEntityId,
          x: newX,
          y: newY,
          targetX: null,
          targetY: null,
          isMoving: false
        };
      }
    });
    
    // Broadcast the new map and entities to all players
    io.emit('mapResized', {
      mapDimensions: gameState.mapDimensions,
      map: gameState.map,
      entities: gameState.entities
    });
    
    return true;
  }
  
  return false;
}

// Player colors for assignment
const playerColors = ['red', 'blue', 'green', 'yellow'];
let nextPlayerColorIndex = 0;

// Function to create a unit for a player
function createPlayerUnit(playerId) {
    console.log(`=== Creating Player Unit ===`);
    
    // Find the shared human base
    const humanBase = Object.values(gameState.entities).find(entity => 
        entity.type === 'building' && 
        entity.buildingType === 'BASE' && 
        entity.playerId === 'human-team'
    );

    if (!humanBase) {
        console.error('Failed to create unit: Shared human base not found!');
        console.log('Current entities:', Object.keys(gameState.entities));
        return null;
    }
    
    console.log(`Found shared base at position: (${humanBase.x}, ${humanBase.y})`);
    
    // Position the new unit near the base
    const unitX = humanBase.x + humanBase.width + 64;
    const unitY = humanBase.y + (humanBase.height / 2);
    
    console.log(`Positioning new unit at: (${unitX}, ${unitY})`);
    
    // Create the unit with the player's unique ID
    const unitId = uuidv4();
    const unit = {
        id: unitId,
        type: 'unit',
        unitType: 'SOLDIER',
        playerId: playerId,
        teamId: 'human-team',
        x: unitX,
        y: unitY,
        width: 32,
        height: 32,
        speed: 150,
        targetX: null,
        targetY: null,
        isMoving: false,
        health: 100,
        maxHealth: 100,
        attackRange: 60,
        attackDamage: 10,
        attackCooldown: 1000,
        lastAttackTime: null,
        targetEntityId: null,
        isAttacking: false
    };
    
    console.log(`Created unit ${unitId} for player ${playerId}`);
    return unit;
}

// AI Unit Control Functions
function findClosestEnemyBase(aiUnit, entities) {
    let closestDistance = Infinity;
    let closestBase = null;

    for (const entityId in entities) {
        const entity = entities[entityId];
        if (entity.type === 'building' && entity.buildingType === 'BASE' && entity.playerId === 'human-team') {
            const dx = entity.x - aiUnit.x;
            const dy = entity.y - aiUnit.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < closestDistance) {
                closestDistance = distance;
                closestBase = entity;
            }
        }
    }
    return closestBase;
}

function updateAIUnits(deltaTime) {
    for (const entityId in gameState.entities) {
        const aiUnit = gameState.entities[entityId];
        
        // Only process AI units (non-player-controlled units)
        if (aiUnit.type === 'unit' && aiUnit.playerId === 'ai-team') {
            // Find target if none exists or current target is destroyed
            if (!aiUnit.targetEntityId || !gameState.entities[aiUnit.targetEntityId]) {
                const closestBase = findClosestEnemyBase(aiUnit, gameState.entities);
                if (closestBase) {
                    aiUnit.targetEntityId = closestBase.id;
                    console.log(`AI Unit ${aiUnit.id} targeting base ${closestBase.id}`);
                }
            }

            const targetEntity = gameState.entities[aiUnit.targetEntityId];
            if (targetEntity) {
                const dx = targetEntity.x - aiUnit.x;
                const dy = targetEntity.y - aiUnit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > aiUnit.attackRange) {
                    // Move towards target
                    const normalizedDx = dx / distance;
                    const normalizedDy = dy / distance;
                    aiUnit.x += normalizedDx * aiUnit.speed * (deltaTime / 1000);
                    aiUnit.y += normalizedDy * aiUnit.speed * (deltaTime / 1000);
                    aiUnit.isMoving = true;
                    
                    // Broadcast position update
                    io.emit('updateUnitPosition', {
                        unitId: aiUnit.id,
                        x: aiUnit.x,
                        y: aiUnit.y,
                        isMoving: true
                    });
                } else {
                    // Within attack range
                    aiUnit.isMoving = false;
                    if (!aiUnit.lastAttackTime || Date.now() - aiUnit.lastAttackTime >= aiUnit.attackCooldown) {
                        // Attack the target
                        targetEntity.health -= aiUnit.attackDamage;
                        
                        // Clamp health to zero if negative
                        if (targetEntity.health < 0) {
                            targetEntity.health = 0;
                        }
                        
                        aiUnit.lastAttackTime = Date.now();
                        
                        // Broadcast attack
                        io.emit('unitAttack', {
                            attackerId: aiUnit.id,
                            targetId: targetEntity.id,
                            damage: aiUnit.attackDamage,
                            targetHealth: targetEntity.health
                        });
                        
                        // Check if target is destroyed
                        if (targetEntity.health <= 0) {
                            // Check if this is a base building
                            if (targetEntity.type === 'building' && targetEntity.buildingType === 'BASE') {
                                // Trigger end game logic
                                if (!gameState.gameEndTime) {
                                    const winner = targetEntity.playerId === 'human-team' ? 'ai-team' : 'human-team';
                                    
                                    console.log(`Base of team ${targetEntity.playerId} has been destroyed. ${winner} wins!`);
                                    
                                    // Set the game end state
                                    gameState.gameEndTime = Date.now();
                                    gameState.winner = winner;
                                    
                                    // Start the countdown (30 seconds)
                                    gameState.countdown = 30;
                                    
                                    // Notify all clients that the game has ended
                                    io.emit('gameEnded', { 
                                        winner: winner,
                                        message: winner === 'human-team' ? 'The enemy base has fallen!' : 'Your base was destroyed!',
                                        countdown: gameState.countdown
                                    });
                                    
                                    // Start the countdown timer
                                    startEndGameCountdown();
                                }
                            } else {
                                // For non-base entities, destroy them
                                delete gameState.entities[targetEntity.id];
                                aiUnit.targetEntityId = null;
                                io.emit('entityDestroyed', { entityId: targetEntity.id });
                            }
                        }
                    }
                }
            }
        }
    }
}

// Game update loop
let lastUpdateTime = Date.now();
setInterval(() => {
    if (gameState.isRunning) {
        const currentTime = Date.now();
        const deltaTime = currentTime - lastUpdateTime;
        lastUpdateTime = currentTime;
        
        // Check for base destruction if game is still active
        if (!gameState.gameEndTime) {
            // Check if any bases have been destroyed
            checkBaseDestruction();
            
            // Only update units if the game hasn't ended
            updateAIUnits(deltaTime);
            updatePlayerUnits(deltaTime);
        } else if (gameState.countdown) {
            // Handle countdown if game has ended
            updateEndGameCountdown();
        }
    }
}, 50);

// Function to update player-controlled units
function updatePlayerUnits(deltaTime) {
    for (const entityId in gameState.entities) {
        const unit = gameState.entities[entityId];
        
        // Only process player-controlled units that are moving or attacking
        if (unit.type === 'unit' && unit.playerId !== 'ai-team') {
            // Handle attacking logic
            if (unit.isAttacking && unit.targetEntityId) {
                const targetEntity = gameState.entities[unit.targetEntityId];
                
                // If target no longer exists, clear attack state
                if (!targetEntity) {
                    unit.targetEntityId = null;
                    unit.isAttacking = false;
                    unit.isMoving = false;
                    continue;
                }
                
                // Always update target position for attacking units to ensure they follow moving targets
                unit.targetX = targetEntity.x;
                unit.targetY = targetEntity.y;
                
                // Calculate distance to target
                const dx = targetEntity.x - unit.x;
                const dy = targetEntity.y - unit.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate attack range - use default if not set
                const attackRange = unit.attackRange || 50;
                
                // If within attack range, stop and attack
                if (distance <= attackRange) {
                    unit.isMoving = false;
                    
                    // Process attack
                    const now = Date.now();
                    const attackCooldown = unit.attackCooldown || 1000; // Default 1 second cooldown
                    
                    if (!unit.lastAttackTime || now - unit.lastAttackTime >= attackCooldown) {
                        // Apply damage to target
                        const damage = unit.attackDamage || 10; // Default damage
                        targetEntity.health -= damage;
                        
                        // Clamp health to zero if negative
                        if (targetEntity.health < 0) {
                            targetEntity.health = 0;
                        }
                        
                        unit.lastAttackTime = now;
                        
                        // Broadcast attack
                        io.emit('unitAttack', {
                            attackerId: unit.id,
                            targetId: unit.targetEntityId,
                            damage: damage,
                            targetHealth: targetEntity.health
                        });
                        
                        // Check if target is destroyed
                        if (targetEntity.health <= 0) {
                            // Check if this is a base building
                            if (targetEntity.type === 'building' && targetEntity.buildingType === 'BASE') {
                                // Trigger end game logic
                                if (!gameState.gameEndTime) {
                                    const winner = targetEntity.playerId === 'human-team' ? 'ai-team' : 'human-team';
                                    
                                    console.log(`Base of team ${targetEntity.playerId} has been destroyed. ${winner} wins!`);
                                    
                                    // Set the game end state
                                    gameState.gameEndTime = Date.now();
                                    gameState.winner = winner;
                                    
                                    // Start the countdown (30 seconds)
                                    gameState.countdown = 30;
                                    
                                    // Notify all clients that the game has ended
                                    io.emit('gameEnded', { 
                                        winner: winner,
                                        message: winner === 'human-team' ? 'The enemy base has fallen!' : 'Your base was destroyed!',
                                        countdown: gameState.countdown
                                    });
                                    
                                    // Start the countdown timer
                                    startEndGameCountdown();
                                }
                            } else {
                                // For non-base entities, destroy them
                                io.emit('entityDestroyed', {
                                    entityId: targetEntity.id
                                });
                                
                                // Remove entity from game state
                                delete gameState.entities[targetEntity.id];
                            }
                            
                            // Clear attack target
                            unit.targetEntityId = null;
                            unit.isAttacking = false;
                            unit.isMoving = false;
                        }
                    }
                } else {
                    // If not in range, keep moving toward the target
                    unit.isMoving = true;
                }
            }
            
            // Handle movement for units that are moving
            if (unit.isMoving) {
                if (unit.targetX !== null && unit.targetY !== null) {
                    const dx = unit.targetX - unit.x;
                    const dy = unit.targetY - unit.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 1) {
                        // Move towards target
                        const normalizedDx = dx / distance;
                        const normalizedDy = dy / distance;
                        unit.x += normalizedDx * unit.speed * (deltaTime / 1000);
                        unit.y += normalizedDy * unit.speed * (deltaTime / 1000);
                        
                        // Broadcast position update
                        io.emit('updateUnitPosition', {
                            unitId: unit.id,
                            x: unit.x,
                            y: unit.y,
                            isMoving: true
                        });
                    } else if (!unit.isAttacking) {
                        // Reached target without attacking
                        unit.x = unit.targetX;
                        unit.y = unit.targetY;
                        unit.isMoving = false;
                        unit.targetX = null;
                        unit.targetY = null;
                        
                        // Broadcast final position
                        io.emit('updateUnitPosition', {
                            unitId: unit.id,
                            x: unit.x,
                            y: unit.y,
                            isMoving: false
                        });
                    }
                }
            }
        }
    }
}

// Function to check if any bases have been destroyed
function checkBaseDestruction() {
    // Find all bases
    const bases = Object.values(gameState.entities).filter(
        entity => entity.type === 'building' && entity.buildingType === 'BASE'
    );
    
    // Check each base
    for (const base of bases) {
        if (base.health <= 0) {
            // Determine the winner
            const winner = base.playerId === 'human-team' ? 'ai-team' : 'human-team';
            
            console.log(`Base of team ${base.playerId} has been destroyed. ${winner} wins!`);
            
            // Set the game end state
            gameState.gameEndTime = Date.now();
            gameState.winner = winner;
            
            // Start the countdown (30 seconds)
            gameState.countdown = 30;
            
            // Notify all clients that the game has ended
            io.emit('gameEnded', { 
                winner: winner,
                message: winner === 'human-team' ? 'The enemy base has fallen!' : 'Your base was destroyed!',
                countdown: gameState.countdown
            });
            
            // Start the countdown timer
            startEndGameCountdown();
            
            // Only need to handle one base destruction
            break;
        }
    }
}

// Function to start the end game countdown
function startEndGameCountdown() {
    // Send countdown updates every second
    const countdownInterval = setInterval(() => {
        // Decrement countdown
        gameState.countdown--;
        
        // Send countdown update to all clients
        io.emit('countdownUpdate', { 
            secondsRemaining: gameState.countdown 
        });
        
        // When countdown reaches 0, reset and start a new game
        if (gameState.countdown <= 0) {
            clearInterval(countdownInterval);
            
            // Prompt players to join next game
            io.emit('prepareNextGame', {});
            
            // After 5 more seconds, start the next game
            setTimeout(() => {
                startGame();
            }, 5000);
        }
    }, 1000);
}

// Function to update the end game countdown
function updateEndGameCountdown() {
    // This is handled by the startEndGameCountdown interval
    // Function is kept for clarity in the game update loop
}

// Handle socket connections
io.on('connection', (socket) => {
  console.log(`New player connected: ${socket.id}`);
  
  const playerId = uuidv4();
  
  // Assign the player to the human team
  gameState.players[playerId] = {
    id: playerId,
    socketId: socket.id,
    name: `Player ${Object.keys(gameState.players).length + 1}`,
    teamId: 'human-team',  // Links player to the shared base
    color: 'blue',
    connected: true,
    lastActivity: Date.now()
  };

  console.log(`Player ${playerId} joined team "human-team"`);
  
  // Send current game state to the connecting client
  socket.emit('gameState', {
    status: gameState.isRunning ? 'active' : 'ended',
    playerId: playerId,
    gameState: gameState.isRunning ? {
      players: gameState.players,
      entities: gameState.entities,
      map: gameState.map,
      mapDimensions: gameState.mapDimensions,
      lastUpdateTime: gameState.lastUpdateTime,
      serverStartTime: gameState.serverStartTime
    } : null
  });

  // Handle rejoin attempts
  socket.on('rejoinGame', (data) => {
    const { oldPlayerId } = data;
    let rejoinPlayerId = playerId;
    
    if (oldPlayerId && gameState.players[oldPlayerId] && !gameState.players[oldPlayerId].connected) {
      // Reclaim old player ID if available
      rejoinPlayerId = oldPlayerId;
      gameState.players[rejoinPlayerId].socketId = socket.id;
      gameState.players[rejoinPlayerId].connected = true;
      console.log(`Player ${rejoinPlayerId} rejoined team "human-team"`);
    } else {
      // Create new player entry
      gameState.players[rejoinPlayerId] = {
        id: rejoinPlayerId,
        socketId: socket.id,
        name: `Player ${Object.keys(gameState.players).length + 1}`,
        teamId: 'human-team',  // Links player to the shared base
        color: 'blue',
        connected: true,
        lastActivity: Date.now()
      };
      console.log(`New player ${rejoinPlayerId} joined team "human-team"`);
    }
    
    // Send current game state
    socket.emit('gameState', {
      status: 'active',
      playerId: rejoinPlayerId,
      gameState: {
        players: gameState.players,
        entities: gameState.entities,
        map: gameState.map,
        mapDimensions: gameState.mapDimensions,
        lastUpdateTime: gameState.lastUpdateTime,
        serverStartTime: gameState.serverStartTime
      }
    });
    
    // Notify other players
    socket.broadcast.emit('playerJoined', {
      player: gameState.players[rejoinPlayerId]
    });
  });
  
  // Handle join game request
  socket.on('joinGame', (data) => {
    // Check if game is running
    if (!gameState.isRunning) {
      console.log('Join game rejected: Game not running');
      socket.emit('joinGameError', { message: 'Game has ended' });
      return;
    }
    
    const playerId = data.playerId;
    console.log(`\n=== Join Game Request ===`);
    console.log(`Player ${playerId} requesting to join game`);
    console.log(`Current players:`, Object.keys(gameState.players));

    if (!gameState.players[playerId]) {
      console.error(`Join game error: Player ${playerId} not found in gameState.players`);
      socket.emit('joinGameError', { message: "Player not found." });
      return;
    }

    // Log the state before creating unit
    console.log(`Creating unit for player ${playerId}`);
    console.log(`Player team: ${gameState.players[playerId].teamId}`);

    // Create the unit explicitly
    const newUnit = createPlayerUnit(playerId);
    if (!newUnit) {
      console.error(`Failed to create unit for player ${playerId}`);
      socket.emit('joinGameError', { message: "Could not create unit." });
      return;
    }

    // Log the new unit details
    console.log(`Successfully created unit:`, {
      unitId: newUnit.id,
      playerId: newUnit.playerId,
      position: { x: newUnit.x, y: newUnit.y }
    });

    // Add unit to game state explicitly
    gameState.entities[newUnit.id] = newUnit;
    console.log(`Added unit ${newUnit.id} to game state`);
    console.log(`Total entities in game:`, Object.keys(gameState.entities).length);

    // Broadcast to ALL clients (including the one who joined)
    io.emit('unitCreated', { unit: newUnit });
    console.log(`Broadcasted unitCreated event for unit ${newUnit.id}`);

    // Confirm join to requesting client explicitly
    socket.emit('joinGameSuccess', { unit: newUnit });
    console.log(`Sent joinGameSuccess to player ${playerId}`);
    console.log(`=== Join Game Complete ===\n`);
  });
  
  // Handle unit movement
  socket.on('moveUnits', (data) => {
    // Check if game is running
    if (!gameState.isRunning) {
      socket.emit('moveUnitsError', { message: 'Game has ended' });
      return;
    }
    
    console.log(`Received moveUnits command: units ${data.unitIds.join(", ")} to target (${data.targetX}, ${data.targetY})`);
    
    // Validate the data
    if (!data.unitIds || !Array.isArray(data.unitIds) || data.targetX === undefined || data.targetY === undefined) {
      console.error('Invalid moveUnits data received');
      return;
    }

    // Find the player ID associated with this socket
    const playerId = Object.keys(gameState.players).find(
      id => gameState.players[id].socketId === socket.id
    );

    if (!playerId) {
      console.error('Player not found for socket', socket.id);
      return;
    }

    // Validate and update each unit
    data.unitIds.forEach(unitId => {
      const unit = gameState.entities[unitId];
      if (!unit) {
        console.error(`Unit ${unitId} not found`);
        return;
      }

      // Verify the unit belongs to the player and is not an AI unit
      if (unit.playerId !== playerId || unit.playerId === 'ai-team') {
        console.error(`Unit ${unitId} does not belong to player ${playerId} or is an AI unit`);
        return;
      }

      // Clear any previous attack target
      unit.targetEntityId = null;
      unit.isAttacking = false;

      // Update unit's target position and movement state
      unit.targetX = data.targetX;
      unit.targetY = data.targetY;
      unit.isMoving = true;
      console.log(`Updated unit ${unitId} target to (${data.targetX}, ${data.targetY})`);
    });

    // Broadcast the movement to all clients
    io.emit('unitsMoved', {
      unitIds: data.unitIds,
      targetX: data.targetX,
      targetY: data.targetY
    });
  });
  
  // Handle unit attack commands
  socket.on('attackTarget', (data) => {
    // Check if game is running
    if (!gameState.isRunning) {
      socket.emit('attackTargetError', { message: 'Game has ended' });
      return;
    }
    
    console.log(`Received attackTarget command: units ${data.unitIds.join(", ")} attacking entity ${data.targetEntityId}`);
    
    // Validate the data
    if (!data.unitIds || !Array.isArray(data.unitIds) || !data.targetEntityId) {
      console.error('Invalid attackTarget data received');
      return;
    }

    // Find the player ID associated with this socket
    const playerId = Object.keys(gameState.players).find(
      id => gameState.players[id].socketId === socket.id
    );

    if (!playerId) {
      console.error('Player not found for socket', socket.id);
      return;
    }
    
    // Check if target entity exists
    const targetEntity = gameState.entities[data.targetEntityId];
    if (!targetEntity) {
      console.error(`Target entity ${data.targetEntityId} not found`);
      return;
    }
    
    // Validate and update each attacking unit
    data.unitIds.forEach(unitId => {
      const unit = gameState.entities[unitId];
      if (!unit) {
        console.error(`Unit ${unitId} not found`);
        return;
      }

      // Verify the unit belongs to the player and is not an AI unit
      if (unit.playerId !== playerId || unit.playerId === 'ai-team') {
        console.error(`Unit ${unitId} does not belong to player ${playerId} or is an AI unit`);
        return;
      }

      // Set attack target
      unit.targetEntityId = data.targetEntityId;
      unit.isAttacking = true;
      
      // Set movement target to target entity's position
      unit.targetX = targetEntity.x;
      unit.targetY = targetEntity.y;
      unit.isMoving = true;
      
      console.log(`Unit ${unitId} attacking entity ${data.targetEntityId} at (${targetEntity.x}, ${targetEntity.y})`);
    });

    // Broadcast the attack command to all clients
    io.emit('unitsAttacking', {
      unitIds: data.unitIds,
      targetEntityId: data.targetEntityId
    });
  });
  
  // Handle player disconnection
  socket.on('disconnect', () => {
    console.log(`Player disconnected: ${socket.id}`);
    
    // Find the player by socket ID
    const playerId = Object.keys(gameState.players).find(
      id => gameState.players[id].socketId === socket.id
    );
    
    if (playerId && gameState.isRunning) {
      // Mark player as disconnected but keep their data for potential rejoin
      gameState.players[playerId].connected = false;
      gameState.players[playerId].lastActivity = Date.now();
      
      // Broadcast player disconnection to all other players
      socket.broadcast.emit('playerLeft', {
        playerId: playerId
      });
      
      // Remove player units, but NOT their base
      Object.keys(gameState.entities).forEach(entityId => {
        const entity = gameState.entities[entityId];
        if (entity.playerId === playerId && entity.buildingType !== 'BASE') {
          delete gameState.entities[entityId];
          
          // Broadcast entity removal
          io.emit('entityRemoved', {
            entityId: entityId
          });
        }
      });
      
      // Check if map needs to be resized after player disconnection
      checkAndResizeMap();
    }
  });

  // Handle player opting in for the next game
  socket.on('joinNextGame', (data) => {
    const playerId = data.playerId;
    
    if (playerId && gameState.players[playerId]) {
      console.log(`Player ${playerId} opts in for the next game`);
      
      // Add player to the list for next game if not already there
      if (!gameState.playersForNextGame.includes(playerId)) {
        gameState.playersForNextGame.push(playerId);
      }
      
      // Confirm to the player
      socket.emit('joinNextGameConfirmed', {});
    }
  });
});

// Start the server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Game client available at http://localhost:${PORT}`);
  console.log(`Initial map size: ${gameState.mapDimensions.width}x${gameState.mapDimensions.height} (zoom: ${gameState.mapDimensions.zoomFactor})`);
});  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\server\server.js 
======================================== 
 
const http = require('http');
const express = require('express');
const cors = require('cors');
const { Server } = require('colyseus');
const { monitor } = require('@colyseus/monitor');
const { WebSocketTransport } = require('@colyseus/ws-transport');
const { GameRoom } = require('./rooms/GameRoom');

const app = express();

// Enable CORS
app.use(cors());

// Serve static files from the public directory
app.use(express.static('public'));

// Create HTTP server
const server = http.createServer(app);

// Create Colyseus server
const gameServer = new Server({
  transport: new WebSocketTransport({
    server
  })
});

// Register room handlers
gameServer.define('game_room', GameRoom);

// Register Colyseus monitor (accessible at /colyseus)
app.use('/colyseus', monitor());

// Define port to run server on
const port = process.env.PORT || 2567;

// Listen on specified port
gameServer.listen(port);
console.log(`Game server running on http://localhost:${port}`);

// Export for testing
module.exports = { app, server, gameServer };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\server\rooms\GameRoom.js 
======================================== 
 
const { Room } = require("colyseus");
const { GameState, PlayerData, Hero, Building, Unit, Position } = require("../schema/GameState");
const { v4: uuidv4 } = require("uuid");

class GameRoom extends Room {
  constructor() {
    super();
    this.autoDispose = false; // Don't automatically dispose the room when empty
    this.maxClients = 100; // Default max clients (will be adjusted based on options)
  }

  onCreate(options) {
    console.log("GameRoom created!");
    
    // Set max clients based on options or default to 100
    this.maxClients = options.maxPlayers || 100;
    
    // Create and set the game state
    this.setState(new GameState());
    
    // Generate map size based on player count (10 tiles per expected player)
    const mapSize = Math.max(20, Math.min(100, this.maxClients * 10));
    this.generateMap(mapSize);
    
    // Set up human and AI bases
    this.setupBases(mapSize);
    
    // Set up game timer (3600 seconds = 1 hour)
    this.setMetadata({ gameTime: 0, maxTime: 3600 });
    
    // Create a timer that ticks every second
    this.clock.setInterval(() => {
      // Update game time
      this.state.gameTime++;
      
      // Run AI logic every 5 seconds
      if (this.state.gameTime % 5 === 0) {
        this.runAILogic();
      }
      
      // End game after 60 minutes
      if (this.state.gameTime >= 3600) {
        this.endGame();
      }
    }, 1000);
    
    // Set up message handlers
    this.setupMessageHandlers();
    
    console.log("GameRoom initialized with map size:", mapSize);
  }
  
  generateMap(mapSize) {
    // Simple map generation - 0 represents empty tile
    for (let i = 0; i < mapSize * mapSize; i++) {
      this.state.map.push(0);
    }
    
    // TODO: Add more complex map generation with terrain, resources, etc.
  }
  
  setupBases(mapSize) {
    // Place human base near bottom-left
    const humanBaseX = Math.floor(mapSize * 0.2);
    const humanBaseY = Math.floor(mapSize * 0.8);
    
    // Create human base building
    const humanBase = new Building(
      "human_base",
      "headquarters",
      "human",
      humanBaseX,
      humanBaseY,
      1000
    );
    humanBase.isComplete = true;
    this.state.buildings.set(humanBase.id, humanBase);
    
    // Place AI base near top-right
    const aiBaseX = Math.floor(mapSize * 0.8);
    const aiBaseY = Math.floor(mapSize * 0.2);
    
    // Create AI base building
    const aiBase = new Building(
      "ai_base",
      "headquarters",
      "ai",
      aiBaseX,
      aiBaseY,
      1000
    );
    aiBase.isComplete = true;
    this.state.buildings.set(aiBase.id, aiBase);
  }
  
  setupMessageHandlers() {
    // Handle hero movement
    this.onMessage("move_hero", (client, message) => {
      const playerData = this.state.players.get(client.sessionId);
      if (playerData && playerData.hero) {
        playerData.hero.position.x = message.x;
        playerData.hero.position.y = message.y;
      }
    });
    
    // Handle building construction
    this.onMessage("build", (client, message) => {
      const { buildingType, x, y } = message;
      const playerData = this.state.players.get(client.sessionId);
      
      if (!playerData) return;
      
      // Check if player has enough resources
      // TODO: Add resource cost checks
      
      // Create new building
      const buildingId = `building_${uuidv4()}`;
      const building = new Building(
        buildingId,
        buildingType,
        client.sessionId,
        x,
        y,
        200 // Default health
      );
      
      // Add building to state
      this.state.buildings.set(buildingId, building);
      
      // TODO: Deduct resources
    });
    
    // Handle unit hiring
    this.onMessage("hire_unit", (client, message) => {
      const { unitType, buildingId } = message;
      const playerData = this.state.players.get(client.sessionId);
      const building = this.state.buildings.get(buildingId);
      
      if (!playerData || !building || building.owner !== client.sessionId) return;
      
      // Check if building is complete
      if (!building.isComplete) return;
      
      // Check if player has enough resources
      // TODO: Add resource cost checks
      
      // Create new unit
      const unitId = `unit_${uuidv4()}`;
      const unit = new Unit(
        unitId,
        unitType,
        client.sessionId,
        building.position.x + 1, // Spawn next to building
        building.position.y + 1,
        50 // Default health
      );
      
      // Add unit to state
      this.state.units.set(unitId, unit);
      
      // TODO: Deduct resources
    });
    
    // Handle unit movement
    this.onMessage("move_unit", (client, message) => {
      const { unitId, x, y } = message;
      const unit = this.state.units.get(unitId);
      
      if (!unit || unit.owner !== client.sessionId) return;
      
      unit.position.x = x;
      unit.position.y = y;
      unit.targetId = null; // Clear any attack target
    });
    
    // Handle unit attack
    this.onMessage("attack", (client, message) => {
      const { unitId, targetId } = message;
      const unit = this.state.units.get(unitId);
      
      if (!unit || unit.owner !== client.sessionId) return;
      
      // Set attack target
      unit.targetId = targetId;
    });
  }
  
  onJoin(client, options) {
    console.log(client.sessionId, "joined!");
    
    // Create player data
    const playerData = new PlayerData();
    
    // Create hero for the player
    const hero = new Hero(
      `hero_${client.sessionId}`,
      client.sessionId,
      50 + Math.floor(Math.random() * 20), // Random position near human base
      50 + Math.floor(Math.random() * 20),
      100
    );
    
    // Add some basic abilities to the hero
    hero.abilities.push({ name: "heal", cooldown: 30, currentCooldown: 0 });
    
    // Set the hero and add player to game state
    playerData.hero = hero;
    this.state.players.set(client.sessionId, playerData);
    
    // Broadcast player join event
    this.broadcast("player_joined", { id: client.sessionId });
  }
  
  onLeave(client, consented) {
    console.log(client.sessionId, "left!");
    
    // Mark player as disconnected but keep their data
    const playerData = this.state.players.get(client.sessionId);
    if (playerData) {
      playerData.isConnected = false;
      
      // Allow a grace period for reconnection
      this.clock.setTimeout(() => {
        if (playerData.isConnected === false) {
          // If player hasn't reconnected after 30 seconds, remove them
          this.state.players.delete(client.sessionId);
          
          // Remove player's buildings and units
          this.removePlayerEntities(client.sessionId);
        }
      }, 30000);
    }
    
    // Broadcast player leave event
    this.broadcast("player_left", { id: client.sessionId });
  }
  
  removePlayerEntities(playerId) {
    // Remove all buildings owned by this player
    this.state.buildings.forEach((building, id) => {
      if (building.owner === playerId) {
        this.state.buildings.delete(id);
      }
    });
    
    // Remove all units owned by this player
    this.state.units.forEach((unit, id) => {
      if (unit.owner === playerId) {
        this.state.units.delete(id);
      }
    });
  }
  
  runAILogic() {
    // Simple AI logic to attack human base and players
    
    // Count existing AI units
    let aiUnitCount = 0;
    this.state.units.forEach(unit => {
      if (unit.owner === "ai") {
        aiUnitCount++;
      }
    });
    
    // Spawn new units if below threshold
    const maxAiUnits = 10 + Math.floor(this.state.gameTime / 300) * 5; // Scale up over time
    
    if (aiUnitCount < maxAiUnits) {
      this.spawnAIUnits(maxAiUnits - aiUnitCount);
    }
    
    // Direct existing AI units
    this.state.units.forEach(unit => {
      if (unit.owner === "ai" && !unit.targetId) {
        // Find a target for this AI unit
        const target = this.findAITarget(unit);
        if (target) {
          unit.targetId = target.id;
        }
      }
    });
  }
  
  spawnAIUnits(count) {
    // Find AI buildings to spawn from
    const aiBuildings = [];
    this.state.buildings.forEach(building => {
      if (building.owner === "ai" && building.isComplete) {
        aiBuildings.push(building);
      }
    });
    
    if (aiBuildings.length === 0) return;
    
    // Spawn units from random AI buildings
    for (let i = 0; i < count; i++) {
      const building = aiBuildings[Math.floor(Math.random() * aiBuildings.length)];
      
      // Select unit type based on game time
      let unitType = "grunt";
      if (this.state.gameTime > 1800) { // After 30 minutes, spawn powerful units
        unitType = Math.random() > 0.7 ? "tank" : "grunt";
      } else if (this.state.gameTime > 900) { // After 15 minutes, mix in some better units
        unitType = Math.random() > 0.5 ? "scout" : "grunt";
      }
      
      const unitId = `ai_unit_${uuidv4()}`;
      const unit = new Unit(
        unitId,
        unitType,
        "ai",
        building.position.x + Math.floor(Math.random() * 3) - 1,
        building.position.y + Math.floor(Math.random() * 3) - 1,
        50
      );
      
      this.state.units.set(unitId, unit);
    }
  }
  
  findAITarget(aiUnit) {
    // Target priority: Heroes > Units > Buildings
    
    // Try to find a hero to attack
    let closestDistance = Infinity;
    let closestTarget = null;
    
    // Check for player heroes
    this.state.players.forEach(playerData => {
      if (playerData.isConnected && playerData.hero) {
        const distance = this.calculateDistance(
          aiUnit.position.x, aiUnit.position.y,
          playerData.hero.position.x, playerData.hero.position.y
        );
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestTarget = { id: playerData.hero.id, type: "hero" };
        }
      }
    });
    
    // Check for player units
    this.state.units.forEach(unit => {
      if (unit.owner !== "ai") {
        const distance = this.calculateDistance(
          aiUnit.position.x, aiUnit.position.y,
          unit.position.x, unit.position.y
        );
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestTarget = { id: unit.id, type: "unit" };
        }
      }
    });
    
    // If no units or heroes nearby, target human base
    if (!closestTarget || closestDistance > 20) {
      // Find human base
      const humanBase = this.findHumanBase();
      if (humanBase) {
        closestTarget = { id: humanBase.id, type: "building" };
      }
    }
    
    return closestTarget;
  }
  
  findHumanBase() {
    // Find the human headquarters
    let humanBase = null;
    
    this.state.buildings.forEach(building => {
      if (building.owner === "human" && building.type === "headquarters") {
        humanBase = building;
      }
    });
    
    return humanBase;
  }
  
  calculateDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  
  endGame() {
    // Determine winner based on base health
    let winner = null;
    
    if (this.state.humanBaseHealth <= 0) {
      winner = "ai";
    } else if (this.state.aiBaseHealth <= 0) {
      winner = "human";
    } else {
      // Time ran out, compare base health
      if (this.state.humanBaseHealth > this.state.aiBaseHealth) {
        winner = "human";
      } else if (this.state.aiBaseHealth > this.state.humanBaseHealth) {
        winner = "ai";
      } else {
        winner = "draw";
      }
    }
    
    // Broadcast game end event
    this.broadcast("game_over", { 
      winner,
      humanBaseHealth: this.state.humanBaseHealth,
      aiBaseHealth: this.state.aiBaseHealth,
      gameTime: this.state.gameTime
    });
    
    // Keep the room open for a while so clients can see the results
    this.clock.setTimeout(() => {
      this.disconnect();
    }, 10000);
  }
}

module.exports = { GameRoom };  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\server\schema\GameState.js 
======================================== 
 
const { Schema, MapSchema, ArraySchema, type } = require('@colyseus/schema');

class Position extends Schema {
  constructor(x = 0, y = 0) {
    super();
    this.x = x;
    this.y = y;
  }

  @type("number") x = 0;
  @type("number") y = 0;
}

class Ability extends Schema {
  constructor(name = "", cooldown = 0) {
    super();
    this.name = name;
    this.cooldown = cooldown;
    this.currentCooldown = 0;
  }

  @type("string") name = "";
  @type("number") cooldown = 0;
  @type("number") currentCooldown = 0;
}

class Hero extends Schema {
  constructor(id = "", owner = "", x = 0, y = 0, health = 100) {
    super();
    this.id = id;
    this.owner = owner;
    this.position = new Position(x, y);
    this.health = health;
    this.abilities = new ArraySchema();
  }

  @type("string") id = "";
  @type("string") owner = "";
  @type(Position) position = new Position();
  @type("number") health = 100;
  @type([Ability]) abilities = new ArraySchema();
}

class Building extends Schema {
  constructor(id = "", type = "", owner = "", x = 0, y = 0, health = 200) {
    super();
    this.id = id;
    this.type = type;
    this.owner = owner;
    this.position = new Position(x, y);
    this.health = health;
    this.isComplete = false;
    this.buildProgress = 0;
  }

  @type("string") id = "";
  @type("string") type = "";
  @type("string") owner = "";
  @type(Position) position = new Position();
  @type("number") health = 200;
  @type("boolean") isComplete = false;
  @type("number") buildProgress = 0;
}

class Unit extends Schema {
  constructor(id = "", type = "", owner = "", x = 0, y = 0, health = 50) {
    super();
    this.id = id;
    this.type = type;
    this.owner = owner;
    this.position = new Position(x, y);
    this.health = health;
    this.targetId = null;
  }

  @type("string") id = "";
  @type("string") type = "";
  @type("string") owner = "";
  @type(Position) position = new Position();
  @type("number") health = 50;
  @type("string") targetId = null;
}

class Resources extends Schema {
  constructor(wood = 100, stone = 50, food = 200) {
    super();
    this.wood = wood;
    this.stone = stone;
    this.food = food;
  }

  @type("number") wood = 100;
  @type("number") stone = 50;
  @type("number") food = 200;
}

class PlayerData extends Schema {
  constructor() {
    super();
    this.hero = new Hero();
    this.resources = new Resources();
    this.isConnected = true;
  }

  @type(Hero) hero = new Hero();
  @type(Resources) resources = new Resources();
  @type("boolean") isConnected = true;
}

class GameState extends Schema {
  constructor() {
    super();
    this.players = new MapSchema();
    this.buildings = new MapSchema();
    this.units = new MapSchema();
    this.humanBaseHealth = 1000;
    this.aiBaseHealth = 1000;
    this.gameTime = 0;
    this.map = new ArraySchema();
  }

  @type({ map: PlayerData }) players = new MapSchema();
  @type({ map: Building }) buildings = new MapSchema();
  @type({ map: Unit }) units = new MapSchema();
  @type("number") humanBaseHealth = 1000;
  @type("number") aiBaseHealth = 1000;
  @type("number") gameTime = 0; // in seconds
  @type(["number"]) map = new ArraySchema(); // tile data
}

module.exports = { 
  GameState, 
  PlayerData, 
  Hero, 
  Building, 
  Unit, 
  Position, 
  Ability, 
  Resources 
};  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\index.html 
======================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massive RTS Game</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-overlay" class="ui-overlay">
            <div id="resources-container" class="ui-panel">
                <!-- Resources will be displayed here -->
            </div>
            <div id="selection-info" class="ui-panel">
                <!-- Selection info will be displayed here -->
            </div>
            <div id="notification" class="ui-notification">
                <!-- Notifications will be displayed here -->
            </div>
            <div id="game-time" class="ui-game-time">
                <!-- Game time will be displayed here -->
            </div>
            <div id="game-over" class="ui-game-over">
                <!-- Game over screen will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Game script (bundled) -->
    <script src="/js/client.bundle.js"></script>
</body>
</html>  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\styles.css 
======================================== 
 
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #222;
    color: #fff;
    overflow: hidden;
}

.game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    background-color: #000;
}

.ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allow clicks to pass through to canvas */
}

.ui-panel {
    pointer-events: auto; /* Make panels clickable */
    background-color: rgba(0, 0, 0, 0.7);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
    color: #fff;
}

#resources-container {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 200px;
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.resource-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 5px;
    border-bottom: 1px solid #333;
}

#selection-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 300px;
    min-height: 100px;
}

.selection-empty {
    font-style: italic;
    color: #999;
    text-align: center;
    padding: 10px;
}

.selection-header {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 5px;
    color: #4a90e2;
    border-bottom: 1px solid #4a90e2;
    padding-bottom: 3px;
}

.selection-stats {
    margin-bottom: 5px;
    font-size: 14px;
}

.selection-actions {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 10px;
}

.selection-actions button {
    background-color: #2a6496;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
    font-size: 12px;
    transition: background-color 0.2s;
}

.selection-actions button:hover {
    background-color: #3a7db5;
}

.selection-entity {
    margin-bottom: 10px;
    padding-bottom: 10px;
    border-bottom: 1px solid #444;
}

.ui-notification {
    position: absolute;
    top: 50px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.8);
    color: #fff;
    padding: 10px 20px;
    border-radius: 4px;
    pointer-events: none;
    display: none;
    max-width: 80%;
    text-align: center;
}

.ui-game-time {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: #fff;
    padding: 5px 15px;
    border-radius: 4px;
    font-size: 20px;
    font-weight: bold;
    font-family: monospace;
}

.ui-game-over {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.8);
    color: #fff;
    pointer-events: auto;
}

.ui-game-over h2 {
    font-size: 48px;
    margin-bottom: 20px;
    color: #4a90e2;
}

.ui-game-over p {
    font-size: 24px;
    margin-bottom: 30px;
}

.game-stats {
    margin: 20px 0;
    font-size: 18px;
    font-family: monospace;
    background-color: rgba(0, 0, 0, 0.5);
    padding: 15px;
    border-radius: 4px;
    min-width: 300px;
}

.game-stats div {
    margin: 5px 0;
}

#play-again {
    background-color: #4a90e2;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
    transition: background-color 0.2s;
}

#play-again:hover {
    background-color: #357ab8;
}  
 
 
======================================== 
FILE: package.json 
======================================== 
 
{
  "name": "massive-rts",
  "version": "0.1.0",
  "description": "A browser-based RTS game with massively multiplayer capabilities",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "build:server": "npx webpack --config webpack.server.config.js",
    "build:client": "webpack --config webpack.client.config.js",
    "build": "npm run build:server && npm run build:client",
    "client": "http-server -c-1 -p 8080",
    "postinstall": "npm run build",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "rts",
    "game",
    "multiplayer",
    "browser",
    "html5",
    "canvas"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@colyseus/monitor": "^0.15.0",
    "@colyseus/schema": "^2.0.25",
    "canvas": "^3.1.0",
    "colyseus": "^0.15.13",
    "colyseus.js": "^0.15.14",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "uuid": "^9.0.1",
    "webpack": "^5.90.3",
    "webpack-cli": "^5.1.4",
    "webpack-node-externals": "^3.0.0",
    "@babel/core": "^7.24.0",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/plugin-proposal-decorators": "^7.24.0",
    "@babel/plugin-transform-private-methods": "^7.22.5",
    "@babel/plugin-transform-private-property-in-object": "^7.22.11", 
    "@babel/preset-env": "^7.24.0",
    "babel-loader": "^9.1.3",
    "css-loader": "^6.10.0",
    "file-loader": "^6.2.0",
    "style-loader": "^3.3.4"
  },
  "devDependencies": {
    "http-server": "^14.1.1",
    "nodemon": "^3.0.1"
  }
}
 
 
 
======================================== 
FILE: generate_terrain_tiles.js 
======================================== 
 
/**
 * Isometric Terrain Tile Generator
 * 
 * This script generates basic isometric terrain tiles (grass, mountain, water)
 * as PNG files for use in an isometric game.
 * 
 * Dependencies:
 * - Node.js
 * - canvas npm package (install with: npm install canvas)
 * 
 * Usage:
 * 1. Install dependencies: npm install canvas
 * 2. Run script: node generate_terrain_tiles.js
 * 3. Check current directory for generated PNG files
 */

const fs = require('fs');
const { createCanvas } = require('canvas');

// Configuration
const TILE_WIDTH = 128;
const TILE_HEIGHT = 64;
const OUTPUT_DIR = './';

// Define terrain types with their properties
const terrainTypes = [
    {
        name: 'grass',
        baseColor: '#7CBA3D',
        patternColor: '#8BC34A',
        patternType: 'noise'
    },
    {
        name: 'mountain',
        baseColor: '#8D6E63',
        patternColor: '#6D4C41',
        patternType: 'rocky'
    },
    {
        name: 'water',
        baseColor: '#4B93D1',
        patternColor: '#64B5F6',
        patternType: 'waves'
    },
    {
        name: 'forest',
        baseColor: '#2E7D32',
        patternColor: '#1B5E20',
        patternType: 'trees'
    },
    {
        name: 'sand',
        baseColor: '#FDD835',
        patternColor: '#F9A825',
        patternType: 'noise'
    }
];

/**
 * Main function to generate all terrain tiles
 */
function generateTerrainTiles() {
    console.log('Generating isometric terrain tiles...');
    
    // Create output directory if it doesn't exist
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }
    
    // Generate each terrain type
    terrainTypes.forEach(terrain => {
        generateTile(terrain);
    });
    
    console.log('Tile generation complete! Files saved to:', OUTPUT_DIR);
}

/**
 * Generate a single terrain tile
 * @param {Object} terrain - Terrain configuration object
 */
function generateTile(terrain) {
    console.log(`Generating ${terrain.name} tile...`);
    
    // Create canvas with specified dimensions
    const canvas = createCanvas(TILE_WIDTH, TILE_HEIGHT);
    const ctx = canvas.getContext('2d');
    
    // Clear canvas with transparency
    ctx.clearRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw the isometric diamond shape
    drawIsometricTile(ctx, terrain);
    
    // Save the canvas as a PNG file
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(`${OUTPUT_DIR}${terrain.name}.png`, buffer);
    
    console.log(`✓ ${terrain.name}.png created`);
}

/**
 * Draw an isometric tile with the specified terrain properties
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawIsometricTile(ctx, terrain) {
    // Draw the diamond shape
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, 0);              // Top point
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);    // Right point
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);    // Bottom point
    ctx.lineTo(0, TILE_HEIGHT / 2);             // Left point
    ctx.closePath();
    
    // Fill with base color
    ctx.fillStyle = terrain.baseColor;
    ctx.fill();
    
    // Add pattern based on terrain type
    switch (terrain.patternType) {
        case 'noise':
            drawNoisePattern(ctx, terrain);
            break;
        case 'rocky':
            drawRockyPattern(ctx, terrain);
            break;
        case 'waves':
            drawWavePattern(ctx, terrain);
            break;
        case 'trees':
            drawTreePattern(ctx, terrain);
            break;
    }
    
    // Add shading for 3D effect
    addShading(ctx);
    
    // Add border
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
}

/**
 * Draw a noise pattern (for grass and sand)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawNoisePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    ctx.fillStyle = terrain.patternColor;
    
    // Create a noise pattern with small dots
    for (let i = 0; i < 500; i++) {
        const x = Math.random() * TILE_WIDTH;
        const y = Math.random() * TILE_HEIGHT;
        const size = Math.random() * 1.5 + 0.5;
        
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

/**
 * Draw a rocky pattern (for mountains)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawRockyPattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Draw mountain peak
    const gradient = ctx.createLinearGradient(
        TILE_WIDTH / 2, 0,
        TILE_WIDTH / 2, TILE_HEIGHT
    );
    gradient.addColorStop(0, terrain.patternColor);
    gradient.addColorStop(1, terrain.baseColor);
    
    ctx.fillStyle = gradient;
    
    // Draw a triangular mountain shape
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 4);
    ctx.lineTo(TILE_WIDTH * 0.7, TILE_HEIGHT * 0.7);
    ctx.lineTo(TILE_WIDTH * 0.3, TILE_HEIGHT * 0.7);
    ctx.closePath();
    ctx.fill();
    
    // Add some rocky details
    ctx.fillStyle = terrain.patternColor;
    for (let i = 0; i < 15; i++) {
        const x = TILE_WIDTH * 0.3 + Math.random() * (TILE_WIDTH * 0.4);
        const y = TILE_HEIGHT * 0.4 + Math.random() * (TILE_HEIGHT * 0.3);
        const size = 2 + Math.random() * 5;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y - size / 2);
        ctx.lineTo(x + size * 1.5, y);
        ctx.lineTo(x + size, y + size / 2);
        ctx.closePath();
        ctx.fill();
    }
    
    // Add snow cap
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 4);
    ctx.lineTo(TILE_WIDTH / 2 + 10, TILE_HEIGHT / 4 + 10);
    ctx.lineTo(TILE_WIDTH / 2 - 10, TILE_HEIGHT / 4 + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

/**
 * Draw a wave pattern (for water)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawWavePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Create a gradient for water depth
    const gradient = ctx.createLinearGradient(
        0, TILE_HEIGHT / 2,
        TILE_WIDTH, TILE_HEIGHT / 2
    );
    gradient.addColorStop(0, terrain.baseColor);
    gradient.addColorStop(0.5, terrain.patternColor);
    gradient.addColorStop(1, terrain.baseColor);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw wave lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 8; i++) {
        const yPos = TILE_HEIGHT * 0.3 + i * (TILE_HEIGHT * 0.5 / 8);
        
        ctx.beginPath();
        ctx.moveTo(TILE_WIDTH * 0.3, yPos);
        
        // Create a wavy line
        for (let x = 0; x < TILE_WIDTH * 0.4; x += 5) {
            ctx.lineTo(
                TILE_WIDTH * 0.3 + x,
                yPos + Math.sin(x * 0.1) * 2
            );
        }
        
        ctx.stroke();
    }
    
    ctx.restore();
}

/**
 * Draw a tree pattern (for forests)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawTreePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Draw base gradient
    const gradient = ctx.createLinearGradient(
        0, 0,
        TILE_WIDTH, TILE_HEIGHT
    );
    gradient.addColorStop(0, terrain.baseColor);
    gradient.addColorStop(1, terrain.patternColor);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw tree trunks
    ctx.fillStyle = '#795548';
    
    for (let i = 0; i < 10; i++) {
        const x = 15 + Math.random() * (TILE_WIDTH - 30);
        const y = 10 + Math.random() * (TILE_HEIGHT - 20);
        
        ctx.fillRect(x, y, 3, 6);
    }
    
    // Draw tree tops
    ctx.fillStyle = terrain.patternColor;
    
    for (let i = 0; i < 10; i++) {
        const x = 15 + Math.random() * (TILE_WIDTH - 30);
        const y = 8 + Math.random() * (TILE_HEIGHT - 20);
        
        ctx.beginPath();
        ctx.arc(x + 1, y, 6, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

/**
 * Add shading to create a 3D effect
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 */
function addShading(ctx) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Add highlight on top-left edge
    const highlightGradient = ctx.createLinearGradient(
        0, TILE_HEIGHT / 2,
        TILE_WIDTH / 2, 0
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = highlightGradient;
    ctx.beginPath();
    ctx.moveTo(0, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH / 2, 0);
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT / 2);
    ctx.closePath();
    ctx.fill();
    
    // Add shadow on bottom-right edge
    const shadowGradient = ctx.createLinearGradient(
        TILE_WIDTH / 2, TILE_HEIGHT / 2,
        TILE_WIDTH, TILE_HEIGHT / 2
    );
    shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
    
    ctx.fillStyle = shadowGradient;
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

/**
 * Helper function to clip the canvas to the diamond shape
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 */
function clipToDiamond(ctx) {
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, 0);              // Top point
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);    // Right point
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);    // Bottom point
    ctx.lineTo(0, TILE_HEIGHT / 2);             // Left point
    ctx.closePath();
    ctx.clip();
}

// Run the generator
generateTerrainTiles();  
 
 
======================================== 
FILE: Renderer.js 
======================================== 
 
renderEntities() {
    this.game.entities.forEach(entity => {
        if (!this.camera.isVisible(entity.x, entity.y, entity.width, entity.height)) {
            return;
        }
        const isoX = (entity.x - entity.y) / 2;
        const isoY = (entity.x + entity.y) / 4;
        const screenPos = this.camera.worldToScreen(isoX, isoY);
        // Proceed with existing rendering logic using screenPos.x, screenPos.y
        if (entity.image) {
            this.ctx.drawImage(entity.image, screenPos.x, screenPos.y);
        } else {
            this.ctx.fillStyle = entity.isPlayerControlled ? Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            this.ctx.fillRect(screenPos.x, screenPos.y, entity.width * this.camera.zoom, entity.height * this.camera.zoom);
        }
        // Add any additional rendering (e.g., selection highlights, health bars)
    });
}  
 
 
======================================== 
FILE: webpack.client.config.js 
======================================== 
 
const path = require('path');

module.exports = {
  mode: 'development',
  entry: './src/index.js', // Main client entry point
  output: {
    path: path.resolve(__dirname, 'public/js'),
    filename: 'client.bundle.js',
    publicPath: '/js/'
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: [
              ['@babel/plugin-proposal-decorators', { legacy: true }],
              ['@babel/plugin-proposal-class-properties', { loose: true }],
              ['@babel/plugin-transform-private-methods', { loose: true }],
              ['@babel/plugin-transform-private-property-in-object', { loose: true }]
            ]
          }
        }
      },
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.(png|jpg|gif|svg)$/,
        use: [
          {
            loader: 'file-loader',
            options: {
              name: '[name].[ext]',
              outputPath: '../images/'
            }
          }
        ]
      }
    ]
  },
  resolve: {
    extensions: ['.js'],
    fallback: {
      "buffer": false,
      "crypto": false,
      "fs": false,
      "path": false,
      "stream": false,
      "zlib": false
    }
  },
  devtool: 'source-map',
  performance: {
    hints: false,
    maxEntrypointSize: 1024000,
    maxAssetSize: 1024000
  }
};  
 
 
======================================== 
FILE: webpack.server.config.js 
======================================== 
 
const path = require('path');
const nodeExternals = require('webpack-node-externals');

module.exports = {
  target: 'node',
  mode: 'development',
  entry: './server/server.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'server.bundle.js'
  },
  externals: [nodeExternals({
    // Include Colyseus and other necessary packages in the bundle
    allowlist: ['colyseus', '@colyseus/schema', 'express', 'cors', '@colyseus/monitor']
  })],
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: ['@babel/preset-env'],
            plugins: [
              ['@babel/plugin-proposal-decorators', { legacy: true }],
              ['@babel/plugin-proposal-class-properties', { loose: true }],
              ['@babel/plugin-transform-private-methods', { loose: true }],
              ['@babel/plugin-transform-private-property-in-object', { loose: true }]
            ]
          }
        }
      }
    ]
  },
  node: {
    __dirname: false
  },
  resolve: {
    extensions: ['.js']
  },
  performance: {
    hints: false,
    maxEntrypointSize: 1024000,
    maxAssetSize: 1024000
  }
};  
 
