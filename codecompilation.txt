Massive RTS Game - Code Compilation 
Created: Tue 03/04/2025  8:15:55.51 
======================================== 
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Building.js 
======================================== 
 
/**
 * Building class for player bases and other structures
 */
class Building extends Entity {
  /**
   * Initialize a building
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width of the building
   * @param {number} height - Height of the building
   * @param {boolean} isPlayerControlled - Whether this building is controlled by the player
   * @param {string} buildingType - Type of building (e.g., 'BASE', 'BARRACKS')
   * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
   */
  constructor(x, y, width, height, isPlayerControlled = false, buildingType = 'BASE', playerColor = 'red') {
    super(x, y, width, height, isPlayerControlled);
    
    console.log(`Creating building: ${buildingType} at (${x}, ${y}) with color ${playerColor}`);
    
    // Building type and appearance
    this.buildingType = buildingType;
    this.playerColor = playerColor;
    this.image = null;
    this.loadImage();
    
    // Apply attributes based on building type
    const attributes = Config.BUILDING_ATTRIBUTES[buildingType] || Config.BUILDING_ATTRIBUTES.BASE;
    
    // Building properties
    this.productionRate = attributes.productionRate || 0;
    this.productionType = attributes.productionType || null;
    this.productionProgress = 0;
    this.productionQueue = [];
    
    // Health and stats
    this.health = attributes.health || 500;
    this.maxHealth = attributes.health || 500;
  }
  
  /**
   * Load the building image based on player color and building type
   */
  loadImage() {
    const imagePath = `/images/buildings/${this.playerColor}_${this.buildingType.toLowerCase()}.svg`;
    console.log(`Loading building image: ${imagePath}`);
    this.image = new Image();
    this.image.src = imagePath;
    this.image.onerror = (e) => {
      console.error(`Failed to load building image: ${imagePath}`, e);
      // Fallback to a colored rectangle
    };
    this.image.onload = () => {
      console.log(`Successfully loaded building image: ${imagePath}`);
    };
  }
  
  /**
   * Set the player color for this building
   */
  setPlayerColor(color) {
    this.playerColor = color;
    this.loadImage();
  }
  
  /**
   * Update building state
   */
  update(deltaTime, game) {
    // Handle production if this building produces units
    if (this.productionRate > 0 && this.productionQueue.length > 0) {
      this.updateProduction(deltaTime, game);
    }
  }
  
  /**
   * Update production progress
   */
  updateProduction(deltaTime, game) {
    // Increase production progress
    this.productionProgress += (this.productionRate * deltaTime) / 1000;
    
    // Check if production is complete
    if (this.productionProgress >= 1) {
      this.completeProduction(game);
      this.productionProgress = 0;
    }
  }
  
  /**
   * Complete production of a unit
   */
  completeProduction(game) {
    if (this.productionQueue.length === 0) return;
    
    // Get the unit type from the queue
    const unitType = this.productionQueue.shift();
    
    // Calculate spawn position (near the building)
    const spawnX = this.x + this.width + 10;
    const spawnY = this.y + this.height / 2;
    
    // Create the unit
    const unit = new Unit(
      spawnX,
      spawnY,
      Config.UNIT_SIZE,
      Config.UNIT_SIZE,
      this.isPlayerControlled,
      unitType,
      this.playerColor
    );
    
    // Set the player ID
    unit.playerId = this.playerId;
    
    // Add the unit to the game
    game.entities.push(unit);
    
    console.log(`Building produced a ${unitType}`);
  }
  
  /**
   * Queue a unit for production
   */
  queueUnit(unitType) {
    this.productionQueue.push(unitType);
    console.log(`Added ${unitType} to production queue`);
  }
  
  /**
   * Take damage from an attacker
   */
  takeDamage(amount, attacker) {
    this.health -= amount;
    console.log(`Building took ${amount} damage, health: ${this.health}`);
    
    // If health drops to 0 or below, destroy the building
    if (this.health <= 0) {
      this.die();
    }
  }
  
  /**
   * Handle building destruction
   */
  die() {
    console.log('Building destroyed');
    // In a real implementation, we would remove the building from the game
    // and possibly play a destruction animation
  }
  
  /**
   * Convert building to a network-friendly format
   */
  toNetworkData() {
    const data = super.toNetworkData();
    return {
      ...data,
      buildingType: this.buildingType,
      playerColor: this.playerColor,
      productionRate: this.productionRate,
      productionType: this.productionType,
      productionProgress: this.productionProgress,
      productionQueue: this.productionQueue
    };
  }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Entity.js 
======================================== 
 
/**
 * Base class for all game entities (units, buildings, etc.)
 */
class Entity {
    /**
     * Initialize an entity
     */
    constructor(x, y, width, height, isPlayerControlled = false) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.isPlayerControlled = isPlayerControlled;
        this.isSelected = false;
        this.health = 100;
        this.maxHealth = 100;
        
        // Multiplayer properties
        this.id = null; // Server-assigned ID
        this.playerId = null; // ID of the player who owns this entity
        this.serverX = null; // Position from server for interpolation
        this.serverY = null; // Position from server for interpolation
    }
    
    /**
     * Update entity state
     */
    update(deltaTime, game) {
        // Base entity doesn't do anything in update
        // This method should be overridden by subclasses
    }
    
    /**
     * Check if this entity collides with another entity
     */
    collidesWith(otherEntity) {
        return (
            this.x < otherEntity.x + otherEntity.width &&
            this.x + this.width > otherEntity.x &&
            this.y < otherEntity.y + otherEntity.height &&
            this.y + this.height > otherEntity.y
        );
    }
    
    /**
     * Check if this entity contains a point
     */
    containsPoint(x, y) {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
    
    /**
     * Take damage
     */
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0;
            this.die();
        }
    }
    
    /**
     * Entity death
     */
    die() {
        // This method should be overridden by subclasses
        console.log('Entity died');
    }
    
    /**
     * Get the center position of the entity
     */
    getCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    
    /**
     * Calculate distance to another entity or point
     */
    distanceTo(target) {
        let targetX, targetY;
        
        if (target instanceof Entity) {
            const targetCenter = target.getCenter();
            targetX = targetCenter.x;
            targetY = targetCenter.y;
        } else {
            targetX = target.x;
            targetY = target.y;
        }
        
        const center = this.getCenter();
        const dx = targetX - center.x;
        const dy = targetY - center.y;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Convert entity to a network-friendly format
     */
    toNetworkData() {
        return {
            id: this.id,
            type: this.constructor.name.toLowerCase(),
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            health: this.health,
            playerId: this.playerId,
            isPlayerControlled: this.isPlayerControlled
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Unit.js 
======================================== 
 
/**
 * Unit class for player and AI controlled units
 */
class Unit extends Entity {
    /**
     * Initialize a unit
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width of the unit
     * @param {number} height - Height of the unit
     * @param {boolean} isPlayerControlled - Whether this unit is controlled by the player
     * @param {string} unitType - Type of unit (e.g., 'SOLDIER')
     * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
     */
    constructor(x, y, width, height, isPlayerControlled = false, unitType = 'SOLDIER', playerColor = 'red') {
        super(x, y, width, height, isPlayerControlled);
        
        // Unit type and appearance
        this.unitType = unitType;
        this.playerColor = playerColor;
        this.image = null;
        this.loadImage();
        
        // Apply attributes based on unit type
        const attributes = Config.UNIT_ATTRIBUTES[unitType] || Config.UNIT_ATTRIBUTES.SOLDIER;
        
        // Movement properties
        this.speed = attributes.speed || Config.UNIT_SPEED;
        this.targetX = null;
        this.targetY = null;
        this.isMoving = false;
        
        // Combat properties
        this.attackRange = attributes.attackRange || 50;
        this.attackDamage = attributes.attackDamage || 10;
        this.attackCooldown = attributes.attackCooldown || 1000; // ms
        this.lastAttackTime = 0;
        this.targetEntity = null;
        
        // Health and stats
        this.health = attributes.health || 100;
        this.maxHealth = attributes.health || 100;
        this.level = 1;
        this.experience = 0;
    }
    
    /**
     * Load the unit image based on player color and unit type
     */
    loadImage() {
        const imagePath = `/images/units/${this.playerColor}_${this.unitType.toLowerCase()}.svg`;
        this.image = new Image();
        this.image.src = imagePath;
        this.image.onerror = () => {
            console.error(`Failed to load unit image: ${imagePath}`);
            // Fallback to default image if available
            this.image.src = '/images/units/red_soldier.svg';
        };
    }
    
    /**
     * Set the player color for this unit
     */
    setPlayerColor(color) {
        this.playerColor = color;
        this.loadImage();
    }
    
    /**
     * Update unit state
     */
    update(deltaTime, game) {
        // Handle movement if we have a target
        if (this.isMoving && this.targetX !== null && this.targetY !== null) {
            this.moveTowardsTarget(deltaTime);
        }
        
        // Handle combat if we have a target entity
        if (this.targetEntity) {
            this.updateCombat(deltaTime, game);
        }
    }
    
    /**
     * Move towards the target position
     */
    moveTowardsTarget(deltaTime) {
        // Calculate direction to target
        const center = this.getCenter();
        const dx = this.targetX - center.x;
        const dy = this.targetY - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If we're close enough to the target, stop moving
        if (distance < 5) {
            this.isMoving = false;
            this.targetX = null;
            this.targetY = null;
            return;
        }
        
        // Normalize direction and apply speed
        const moveSpeed = this.speed * (deltaTime / 1000);
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;
        
        // Calculate new position
        const newX = this.x + normalizedDx * moveSpeed;
        const newY = this.y + normalizedDy * moveSpeed;
        
        // Ensure the unit stays within map boundaries
        const mapWidth = Config.MAP_WIDTH * Config.TILE_SIZE;
        const mapHeight = Config.MAP_HEIGHT * Config.TILE_SIZE;
        
        this.x = Math.max(0, Math.min(newX, mapWidth - this.width));
        this.y = Math.max(0, Math.min(newY, mapHeight - this.height));
    }
    
    /**
     * Set a movement target
     */
    setTarget(x, y) {
        this.targetX = x;
        this.targetY = y;
        this.isMoving = true;
    }
    
    /**
     * Update combat state
     */
    updateCombat(deltaTime, game) {
        // Check if target is still valid
        if (!this.targetEntity || this.targetEntity.health <= 0) {
            this.targetEntity = null;
            return;
        }
        
        // Calculate distance to target
        const center = this.getCenter();
        const targetCenter = this.targetEntity.getCenter();
        const dx = targetCenter.x - center.x;
        const dy = targetCenter.y - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If target is out of range, move towards it
        if (distance > this.attackRange) {
            this.setTarget(targetCenter.x, targetCenter.y);
            return;
        }
        
        // If we're in range and attack cooldown is over, attack
        const now = Date.now();
        if (now - this.lastAttackTime >= this.attackCooldown) {
            this.attack(this.targetEntity);
            this.lastAttackTime = now;
        }
    }
    
    /**
     * Attack a target entity
     */
    attack(target) {
        console.log(`Unit attacking target for ${this.attackDamage} damage`);
        target.takeDamage(this.attackDamage, this);
    }
    
    /**
     * Take damage from an attacker
     */
    takeDamage(amount, attacker) {
        this.health -= amount;
        console.log(`Unit took ${amount} damage, health: ${this.health}`);
        
        // If health drops to 0 or below, die
        if (this.health <= 0) {
            this.die();
            
            // Give experience to the attacker if it's a unit
            if (attacker instanceof Unit) {
                attacker.gainExperience(this.level * 10);
            }
        }
    }
    
    /**
     * Gain experience points
     */
    gainExperience(amount) {
        this.experience += amount;
        console.log(`Unit gained ${amount} experience, total: ${this.experience}`);
        
        // Check for level up (simple formula: 100 * current level)
        const experienceNeeded = this.level * 100;
        if (this.experience >= experienceNeeded) {
            this.levelUp();
        }
    }
    
    /**
     * Level up the unit
     */
    levelUp() {
        this.level++;
        this.experience = 0;
        
        // Increase stats
        this.maxHealth += 20;
        this.health = this.maxHealth;
        this.attackDamage += 5;
        
        console.log(`Unit leveled up to level ${this.level}`);
    }
    
    /**
     * Handle unit death
     */
    die() {
        console.log('Unit died');
        // In a real implementation, we would remove the unit from the game
        // and possibly play a death animation
    }
    
    /**
     * Convert unit to a network-friendly format
     */
    toNetworkData() {
        const data = super.toNetworkData();
        return {
            ...data,
            unitType: this.unitType,
            playerColor: this.playerColor,
            speed: this.speed,
            attackRange: this.attackRange,
            attackDamage: this.attackDamage,
            attackCooldown: this.attackCooldown,
            level: this.level,
            experience: this.experience,
            targetX: this.targetX,
            targetY: this.targetY,
            isMoving: this.isMoving
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Camera.js 
======================================== 
 
/**
 * Camera class for handling viewport and map navigation
 */
class Camera {
    /**
     * Initialize the camera
     */
    constructor() {
        // Camera position (top-left corner of the viewport in world coordinates)
        this.x = 25 * 32; // Start at the human base (25, 75)
        this.y = 75 * 32;
        
        // Camera dimensions (viewport size)
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Camera zoom level
        this.zoom = Config.ZOOM_DEFAULT;
        
        console.log(`Camera initialized at position (${this.x}, ${this.y}) with zoom ${this.zoom}`);
        
        this.maxX = Config.MAP_WIDTH * Config.TILE_SIZE - this.width;
        this.maxY = Config.MAP_HEIGHT * Config.TILE_SIZE - this.height;
    }

    /**
     * Move the camera by the specified delta
     */
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.clampPosition();
    }

    /**
     * Set the camera position directly
     */
    setPosition(x, y) {
        this.x = x;
        this.y = y;
        this.clampPosition();
    }

    /**
     * Center the camera on a specific world position
     */
    centerOn(worldX, worldY) {
        // Calculate the position to center the camera on the given world coordinates
        this.x = worldX - (this.width / this.zoom / 2);
        this.y = worldY - (this.height / this.zoom / 2);
        
        // Ensure camera stays within map boundaries
        this.clampPosition();
    }

    /**
     * Ensure camera stays within map boundaries
     */
    clampPosition() {
        const effectiveMaxX = (Config.MAP_WIDTH * Config.TILE_SIZE) - (this.width / this.zoom);
        const effectiveMaxY = (Config.MAP_HEIGHT * Config.TILE_SIZE) - (this.height / this.zoom);
        
        this.x = Math.max(0, Math.min(this.x, effectiveMaxX));
        this.y = Math.max(0, Math.min(this.y, effectiveMaxY));
    }

    /**
     * Convert world coordinates to screen coordinates
     */
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }

    /**
     * Convert screen coordinates to world coordinates
     */
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX / this.zoom) + this.x,
            y: (screenY / this.zoom) + this.y
        };
    }

    /**
     * Check if a world position is visible on screen
     */
    isVisible(worldX, worldY, width, height) {
        return (
            worldX + width > this.x &&
            worldX < this.x + (this.width / this.zoom) &&
            worldY + height > this.y &&
            worldY < this.y + (this.height / this.zoom)
        );
    }

    /**
     * Update camera dimensions when window is resized
     */
    updateDimensions() {
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        this.maxX = Config.MAP_WIDTH * Config.TILE_SIZE - (this.width / this.zoom);
        this.maxY = Config.MAP_HEIGHT * Config.TILE_SIZE - (this.height / this.zoom);
        this.clampPosition();
    }
    
    /**
     * Zoom the camera centered on a specific screen position
     */
    zoomAt(deltaZoom, screenX, screenY) {
        // Get world position before zoom
        const worldX = (screenX / this.zoom) + this.x;
        const worldY = (screenY / this.zoom) + this.y;
        
        // Adjust zoom level
        const oldZoom = this.zoom;
        this.zoom += deltaZoom;
        this.zoom = Math.max(Config.ZOOM_MIN, Math.min(Config.ZOOM_MAX, this.zoom));
        
        // If zoom didn't change, exit early
        if (oldZoom === this.zoom) return;
        
        // Adjust camera position to keep the point under the mouse in the same position
        this.x = worldX - (screenX / this.zoom);
        this.y = worldY - (screenY / this.zoom);
        
        // Update max bounds and clamp position
        this.maxX = Config.MAP_WIDTH * Config.TILE_SIZE - (this.width / this.zoom);
        this.maxY = Config.MAP_HEIGHT * Config.TILE_SIZE - (this.height / this.zoom);
        this.clampPosition();
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Config.js 
======================================== 
 
/**
 * Game configuration constants
 */
class Config {
    // Canvas and rendering
    static CANVAS_WIDTH = window.innerWidth;
    static CANVAS_HEIGHT = window.innerHeight;
    
    // Map settings
    static MAP_WIDTH = 100; // Number of tiles horizontally
    static MAP_HEIGHT = 100; // Number of tiles vertically
    static TILE_SIZE = 32; // Size of each tile in pixels
    
    // Camera settings
    static CAMERA_SPEED = 10; // Camera movement speed
    static CAMERA_EDGE_THRESHOLD = 50; // Pixels from edge to trigger camera movement
    static ZOOM_MIN = 0.5; // Minimum zoom level (50%)
    static ZOOM_MAX = 2.0; // Maximum zoom level (200%)
    static ZOOM_SPEED = 0.1; // How much to zoom per mouse wheel tick
    static ZOOM_DEFAULT = 1.0; // Default zoom level (100%)
    
    // Unit settings
    static UNIT_SPEED = 2; // Movement speed of units
    static UNIT_SIZE = 32; // Size of units in pixels
    static UNIT_ATTRIBUTES = {
        SOLDIER: {
            health: 100,
            attackDamage: 10,
            attackRange: 50,
            attackCooldown: 1000,
            speed: 2
        }
    };
    
    // Building settings
    static BUILDING_ATTRIBUTES = {
        BASE: {
            health: 1000,
            productionRate: 0.1, // Units per second
            productionType: 'SOLDIER'
        },
        BARRACKS: {
            health: 500,
            productionRate: 0.2,
            productionType: 'SOLDIER'
        }
    };
    
    // Player settings
    static PLAYER_COLORS = [
        'red',
        'blue',
        'green',
        'yellow'
    ];
    
    // Colors
    static COLORS = {
        GRASS: '#3a8c3a',
        WATER: '#4286f4',
        SAND: '#e6d56e',
        MOUNTAIN: '#7a7a7a',
        FOREST: '#1f5e1f',
        PLAYER_UNIT: '#0000ff',
        ENEMY_UNIT: '#ff0000',
        SELECTION: '#ffffff',
        GRID: 'rgba(0, 0, 0, 0.2)'
    };
    
    // Debug settings
    static DEBUG_MODE = true; // Enable/disable debug information
    static SHOW_GRID = true; // Show grid lines
    
    // Update the canvas dimensions when the window is resized
    static updateDimensions() {
        this.CANVAS_WIDTH = window.innerWidth;
        this.CANVAS_HEIGHT = window.innerHeight;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Game.js 
======================================== 
 
/**
 * Main game class that coordinates all game components
 */
class Game {
    /**
     * Initialize the game
     */
    constructor() {
        // Get canvas and context
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Set canvas dimensions
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        
        // Initialize game components
        this.camera = new Camera();
        this.map = new Map();
        this.renderer = new Renderer(this);
        this.inputHandler = new InputHandler(this);
        this.multiplayer = new Multiplayer(this);
        
        // Game state
        this.entities = [];
        this.selectedEntities = [];
        this.running = false;
        this.lastFrameTime = 0;
        this.fps = 0;
        
        // Multiplayer state
        this.playerId = null;
    }
    
    /**
     * Start the game
     */
    start() {
        // Initialize multiplayer
        this.multiplayer = new Multiplayer(this);
        this.multiplayer.connect();
        
        // Start the game loop
        this.running = true;
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * Main game loop
     */
    gameLoop(timestamp) {
        // Calculate delta time and FPS
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;
        this.fps = 1000 / deltaTime;
        
        // Update game state
        this.update(deltaTime);
        
        // Render the game
        this.renderer.render();
        
        // Continue the game loop
        if (this.running) {
            requestAnimationFrame(this.gameLoop.bind(this));
        }
    }
    
    /**
     * Update game state
     */
    update(deltaTime) {
        // Update input handler
        this.inputHandler.update();
        
        // Update multiplayer
        this.multiplayer.update(deltaTime);
        
        // Update all entities
        for (const entity of this.entities) {
            entity.update(deltaTime, this);
        }
    }
    
    /**
     * Process entities received from the server
     */
    processServerEntities(serverEntities) {
        if (!serverEntities) return;
        
        console.log('Processing server entities:', Object.keys(serverEntities).length);
        console.log('Entity types:', Object.values(serverEntities).map(e => e.type).join(', '));
        
        // Clear existing entities if this is a full update
        if (this.entities.length === 0) {
            this.entities = [];
        }
        
        // Process each entity from the server
        Object.values(serverEntities).forEach(serverEntity => {
            console.log(`Processing entity: ${serverEntity.id}, type: ${serverEntity.type}, position: (${serverEntity.x}, ${serverEntity.y})`);
            
            // Check if this entity already exists
            let entity = this.entities.find(e => e.id === serverEntity.id);
            
            if (!entity) {
                // Create a new entity based on its type
                if (serverEntity.type === 'unit') {
                    entity = new Unit(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.playerId,
                        serverEntity.unitType,
                        serverEntity.playerColor
                    );
                } else if (serverEntity.type === 'building') {
                    console.log(`Creating building: ${serverEntity.buildingType} at (${serverEntity.x}, ${serverEntity.y}) with color ${serverEntity.playerColor}`);
                    entity = new Building(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.playerId,
                        serverEntity.buildingType,
                        serverEntity.playerColor
                    );
                }
                
                if (entity) {
                    // Set additional properties
                    entity.id = serverEntity.id;
                    entity.playerId = serverEntity.playerId;
                    entity.health = serverEntity.health;
                    entity.maxHealth = serverEntity.maxHealth;
                    
                    // Add to entities array
                    this.entities.push(entity);
                    console.log(`Added new ${serverEntity.type} from server:`, entity);
                }
            } else {
                // Update existing entity
                if (serverEntity.type === 'unit') {
                    // Only update position for units, not buildings
                    entity.x = serverEntity.x;
                    entity.y = serverEntity.y;
                    entity.targetX = serverEntity.targetX;
                    entity.targetY = serverEntity.targetY;
                    entity.isMoving = serverEntity.isMoving;
                }
                
                // Update health for all entities
                entity.health = serverEntity.health;
                entity.maxHealth = serverEntity.maxHealth;
            }
        });
        
        console.log(`Total entities after processing: ${this.entities.length}`);
    }
    
    /**
     * Handle entity selection
     */
    handleEntitySelection(worldX, worldY) {
        let entitySelected = false;
        
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Check if any entity was clicked
        for (const entity of this.entities) {
            if (
                worldX >= entity.x &&
                worldX <= entity.x + entity.width &&
                worldY >= entity.y &&
                worldY <= entity.y + entity.height
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    continue;
                }
                
                // Select this entity
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitySelected = true;
                break; // Only select one entity for now
            }
        }
        
        // If no entity was selected, this might be a map click
        if (!entitySelected) {
            // Get the tile at this position
            const tileX = Math.floor(worldX / Config.TILE_SIZE);
            const tileY = Math.floor(worldY / Config.TILE_SIZE);
            console.log(`Clicked on tile: (${tileX}, ${tileY})`);
        }
    }
    
    /**
     * Select entities within a box
     */
    selectEntitiesInBox(startX, startY, endX, endY) {
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle
        const selectionRect = {
            x: Math.min(startX, endX),
            y: Math.min(startY, endY),
            width: Math.abs(endX - startX),
            height: Math.abs(endY - startY)
        };
        
        // Select all entities within the selection rectangle
        for (const entity of this.entities) {
            if (
                entity.x + entity.width >= selectionRect.x &&
                entity.x <= selectionRect.x + selectionRect.width &&
                entity.y + entity.height >= selectionRect.y &&
                entity.y <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    continue;
                }
                
                entity.isSelected = true;
                this.selectedEntities.push(entity);
            }
        }
    }
    
    /**
     * Deselect all entities
     */
    deselectAll() {
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
    }
    
    /**
     * Handle area selection
     */
    handleAreaSelection(startPos, endPos) {
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle
        const selectionRect = {
            x: Math.min(startPos.x, endPos.x),
            y: Math.min(startPos.y, endPos.y),
            width: Math.abs(endPos.x - startPos.x),
            height: Math.abs(endPos.y - startPos.y)
        };
        
        // Select all entities within the selection rectangle
        for (const entity of this.entities) {
            if (
                entity.x + entity.width >= selectionRect.x &&
                entity.x <= selectionRect.x + selectionRect.width &&
                entity.y + entity.height >= selectionRect.y &&
                entity.y <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    continue;
                }
                
                entity.isSelected = true;
                this.selectedEntities.push(entity);
            }
        }
    }
    
    /**
     * Handle command (right-click)
     */
    handleCommand(worldX, worldY) {
        if (this.selectedEntities.length === 0) return;

        // Get IDs of selected units for multiplayer
        const selectedUnitIds = this.selectedEntities
            .filter(entity => entity instanceof Unit)
            .map(entity => entity.id);
        
        if (selectedUnitIds.length > 0) {
            // Send movement command to server
            this.multiplayer.moveUnits(selectedUnitIds, worldX, worldY);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        this.renderer.handleResize();
    }
    
    /**
     * Create a test player unit
     */
    createTestUnit() {
        // In multiplayer mode, units are created by the server
        if (this.multiplayer && this.multiplayer.connected) {
            // Find the player's base
            const playerBase = this.entities.find(entity => 
                entity.buildingType === 'BASE' && 
                entity.playerId === this.playerId
            );
            
            if (playerBase) {
                // Create unit near the player's base
                const spawnX = playerBase.x + playerBase.width + 10;
                const spawnY = playerBase.y + playerBase.height / 2;
                
                console.log(`Creating unit near player base at (${spawnX}, ${spawnY})`);
                this.multiplayer.createUnit(spawnX, spawnY, true, 'SOLDIER');
            } else {
                // Fallback to center of map if no base found
                const centerX = Config.MAP_WIDTH * Config.TILE_SIZE / 2;
                const centerY = Config.MAP_HEIGHT * Config.TILE_SIZE / 2;
                
                console.log(`No player base found, creating unit at center (${centerX}, ${centerY})`);
                this.multiplayer.createUnit(centerX, centerY, true, 'SOLDIER');
            }
            return;
        }
        
        // For single player testing only
        const unit = new Unit(
            Config.MAP_WIDTH * Config.TILE_SIZE / 2,
            Config.MAP_HEIGHT * Config.TILE_SIZE / 2,
            Config.UNIT_SIZE,
            Config.UNIT_SIZE,
            true,
            'SOLDIER',
            'red'
        );
        this.entities.push(unit);
    }
    
    /**
     * Create a unit at the specified position
     */
    createUnitAt(x, y) {
        if (this.multiplayer && this.multiplayer.connected) {
            this.multiplayer.createUnit(x, y, true, 'SOLDIER');
        } else {
            const unit = new Unit(
                x,
                y,
                Config.UNIT_SIZE,
                Config.UNIT_SIZE,
                true,
                'SOLDIER',
                'blue'
            );
            this.entities.push(unit);
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\InputHandler.js 
======================================== 
 
/**
 * Handles user input (keyboard, mouse) for game interaction
 */
class InputHandler {
    /**
     * Initialize input handler and set up event listeners
     */
    constructor(game) {
        this.game = game;
        this.camera = game.camera;
        this.canvas = game.canvas;
        
        this.keys = {}; // Track pressed keys
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseDown = false;
        this.rightMouseDown = false;
        this.middleMouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.selectionStartX = 0;
        this.selectionStartY = 0;
        this.selectionEndX = 0;
        this.selectionEndY = 0;
        this.isSelecting = false;
        
        // Minimap element
        this.minimapElement = document.getElementById('minimap');
        
        // Bind event handlers
        this.setupEventListeners();
    }
    
    /**
     * Set up all event listeners
     */
    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        window.addEventListener('keyup', this.handleKeyUp.bind(this));
        
        // Mouse events
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
        this.canvas.addEventListener('wheel', this.handleMouseWheel.bind(this));
        
        // Prevent context menu from appearing on right-click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Minimap events
        this.minimapElement.addEventListener('mousedown', this.handleMinimapClick.bind(this));
        this.minimapElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Window resize event
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Handle key down events
     */
    handleKeyDown(e) {
        this.keys[e.key] = true;
        
        // Handle specific key presses
        switch (e.key) {
            case 'Escape':
                // Deselect all units
                this.game.deselectAll();
                break;
        }
        
        // Handle camera movement with arrow keys
        this.updateCameraFromKeys();
    }
    
    /**
     * Handle key up events
     */
    handleKeyUp(e) {
        this.keys[e.code] = false;
    }
    
    /**
     * Handle mouse down events
     */
    handleMouseDown(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = true;
            this.selectionStartX = e.clientX;
            this.selectionStartY = e.clientY;
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
            this.isSelecting = true;
            
            // Check if clicked on an entity
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            this.game.handleEntitySelection(worldPos.x, worldPos.y);
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = true;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = true;
            e.preventDefault(); // Prevent default middle-click behavior
        }
    }
    
    /**
     * Handle mouse up events
     */
    handleMouseUp(e) {
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = false;
            
            if (this.isSelecting) {
                // Finalize selection box
                const startWorld = this.camera.screenToWorld(this.selectionStartX, this.selectionStartY);
                const endWorld = this.camera.screenToWorld(this.selectionEndX, this.selectionEndY);
                this.game.selectEntitiesInBox(startWorld.x, startWorld.y, endWorld.x, endWorld.y);
                this.isSelecting = false;
            }
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = false;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = false;
        }
    }
    
    /**
     * Handle mouse movement
     */
    handleMouseMove(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        
        // Update selection box if selecting
        if (this.isSelecting) {
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
        }
        
        // Handle middle mouse panning
        if (this.middleMouseDown) {
            const deltaX = this.lastMouseX - e.clientX;
            const deltaY = this.lastMouseY - e.clientY;
            
            // Move camera based on mouse movement
            this.camera.move(deltaX / this.camera.zoom, deltaY / this.camera.zoom);
        }
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Handle camera movement when mouse is near screen edges
        this.updateCameraFromMouse();
    }
    
    /**
     * Handle mouse wheel events for zooming
     */
    handleMouseWheel(e) {
        e.preventDefault();
        
        // Determine zoom direction
        const deltaZoom = e.deltaY < 0 ? Config.ZOOM_SPEED : -Config.ZOOM_SPEED;
        
        // Zoom at the mouse position
        this.camera.zoomAt(deltaZoom, e.clientX, e.clientY);
    }
    
    /**
     * Handle right click events
     */
    handleRightClick(e) {
        e.preventDefault(); // Prevent context menu
        
        // If we have selected entities, issue a command
        if (this.game.selectedEntities.length > 0) {
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            this.game.handleCommand(worldPos.x, worldPos.y);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        Config.updateDimensions();
        this.camera.updateDimensions();
        this.game.handleResize();
    }
    
    /**
     * Update camera position based on keyboard input
     */
    updateCameraFromKeys() {
        let dx = 0;
        let dy = 0;
        
        if (this.keys['ArrowUp'] || this.keys['w']) dy -= Config.CAMERA_SPEED;
        if (this.keys['ArrowDown'] || this.keys['s']) dy += Config.CAMERA_SPEED;
        if (this.keys['ArrowLeft'] || this.keys['a']) dx -= Config.CAMERA_SPEED;
        if (this.keys['ArrowRight'] || this.keys['d']) dx += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update camera position when mouse is near screen edges
     */
    updateCameraFromMouse() {
        let dx = 0;
        let dy = 0;
        const threshold = Config.CAMERA_EDGE_THRESHOLD;
        
        // Move camera if mouse is near the edges
        if (this.mouseX < threshold) dx -= Config.CAMERA_SPEED;
        if (this.mouseX > Config.CANVAS_WIDTH - threshold) dx += Config.CAMERA_SPEED;
        if (this.mouseY < threshold) dy -= Config.CAMERA_SPEED;
        if (this.mouseY > Config.CANVAS_HEIGHT - threshold) dy += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {
        this.updateCameraFromKeys();
        this.updateCameraFromMouse();
    }
    
    /**
     * Get the current selection box in screen coordinates
     */
    getSelectionBox() {
        if (!this.isSelecting) return null;
        
        return {
            x: Math.min(this.selectionStartX, this.selectionEndX),
            y: Math.min(this.selectionStartY, this.selectionEndY),
            width: Math.abs(this.selectionEndX - this.selectionStartX),
            height: Math.abs(this.selectionEndY - this.selectionStartY)
        };
    }
    
    /**
     * Handle minimap clicks
     */
    handleMinimapClick(e) {
        e.stopPropagation(); // Prevent event from bubbling to canvas
        
        // Get minimap dimensions
        const minimapRect = this.minimapElement.getBoundingClientRect();
        
        // Calculate relative position within minimap (0-1)
        const relativeX = (e.clientX - minimapRect.left) / minimapRect.width;
        const relativeY = (e.clientY - minimapRect.top) / minimapRect.height;
        
        // Convert to world coordinates
        const worldX = relativeX * Config.MAP_WIDTH * Config.TILE_SIZE;
        const worldY = relativeY * Config.MAP_HEIGHT * Config.TILE_SIZE;
        
        // Left click - move camera to this position
        if (e.button === 0) {
            // Center camera on clicked position
            this.camera.centerOn(worldX, worldY);
        }
        // Right click - move selected units to this position
        else if (e.button === 2) {
            if (this.game.selectedEntities.length > 0) {
                this.game.handleCommand(worldX, worldY);
            }
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Multiplayer.js 
======================================== 
 
/**
 * Multiplayer class for handling client-side networking
 */
class Multiplayer {
    /**
     * Initialize the multiplayer system
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        this.socket = null;
        this.playerId = null;
        this.connected = false;
        this.serverEntities = {}; // Entities from the server
        this.pendingCommands = []; // Commands waiting to be sent
        this.lastServerUpdate = 0;
        
        // Bind methods
        this.onConnect = this.onConnect.bind(this);
        this.onDisconnect = this.onDisconnect.bind(this);
        this.onGameState = this.onGameState.bind(this);
        this.onGameUpdate = this.onGameUpdate.bind(this);
        this.onPlayerJoined = this.onPlayerJoined.bind(this);
        this.onPlayerLeft = this.onPlayerLeft.bind(this);
        this.onUnitCreated = this.onUnitCreated.bind(this);
        this.onUnitsMoved = this.onUnitsMoved.bind(this);
        this.onEntityRemoved = this.onEntityRemoved.bind(this);
    }
    
    /**
     * Connect to the game server
     */
    connect() {
        // Connect to the server on the same host and port
        // Since we're serving the client from the same server
        const serverUrl = window.location.origin;
        
        console.log(`Connecting to game server at ${serverUrl}`);
        
        // Create socket connection
        this.socket = io(serverUrl);
        
        // Set up event handlers
        this.socket.on('connect', this.onConnect);
        this.socket.on('disconnect', this.onDisconnect);
        this.socket.on('gameState', this.onGameState);
        this.socket.on('gameUpdate', this.onGameUpdate);
        this.socket.on('playerJoined', this.onPlayerJoined);
        this.socket.on('playerLeft', this.onPlayerLeft);
        this.socket.on('unitCreated', this.onUnitCreated);
        this.socket.on('unitsMoved', this.onUnitsMoved);
        this.socket.on('entityRemoved', this.onEntityRemoved);
    }
    
    /**
     * Disconnect from the game server
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.connected = false;
    }
    
    /**
     * Handle connection to the server
     */
    onConnect() {
        console.log('Connected to game server');
        this.connected = true;
        
        // Process any pending commands
        this.processPendingCommands();
    }
    
    /**
     * Handle disconnection from the server
     */
    onDisconnect() {
        console.log('Disconnected from game server');
        this.connected = false;
    }
    
    /**
     * Handle initial game state from server
     */
    onGameState(data) {
        console.log('Received initial game state from server');
        this.playerId = data.playerId;
        this.game.playerId = data.playerId;
        
        // Set the map from server data
        if (data.gameState && data.gameState.map) {
            console.log('Setting map from server data');
            this.game.map.setMapFromServer(data.gameState.map);
        } else {
            console.error('No map data received from server');
        }
        
        // Process entities from server data
        if (data.gameState && data.gameState.entities) {
            console.log('Processing entities from server data');
            this.game.processServerEntities(data.gameState.entities);
            
            // Create initial unit after entities are processed
            console.log('Creating initial unit for player');
            this.createInitialUnit();
        }
    }
    
    /**
     * Create an initial unit for the player near their base
     */
    createInitialUnit() {
        // Find the player's base
        const playerBase = this.game.entities.find(entity => 
            entity.buildingType === 'BASE' && 
            entity.playerId === this.playerId
        );
        
        if (playerBase) {
            // Create unit directly adjacent to the player's base
            // Use a fixed offset that ensures the unit is in a valid position
            const offsetX = 64; // 2 tiles to the right
            
            // Calculate spawn position relative to the base
            const spawnX = playerBase.x + playerBase.width + offsetX;
            const spawnY = playerBase.y + (playerBase.height / 2);
            
            console.log(`Creating initial unit adjacent to player base at (${spawnX}, ${spawnY})`);
            
            // Create the unit directly without setTimeout
            this.createUnit(spawnX, spawnY, true, 'SOLDIER');
        } else {
            console.error('Could not find player base to spawn initial unit');
            
            // Fallback to center of map if no base found
            const centerX = Config.MAP_WIDTH * Config.TILE_SIZE / 2;
            const centerY = Config.MAP_HEIGHT * Config.TILE_SIZE / 2;
            
            console.log(`No player base found, creating unit at center (${centerX}, ${centerY})`);
            this.createUnit(centerX, centerY, true, 'SOLDIER');
        }
    }
    
    /**
     * Handle game state updates from server
     */
    onGameUpdate(data) {
        this.lastServerUpdate = Date.now();
        
        // Store previous positions before updating
        this.game.entities.forEach(entity => {
            if (entity.type === 'unit') {
                // Store current position as previous position
                entity.prevX = entity.x;
                entity.prevY = entity.y;
                
                // Initialize interpolation time
                entity.interpolationStartTime = Date.now();
            }
        });
        
        // Update entities from server data
        this.game.processServerEntities(data.entities);
        
        // Store server positions for interpolation
        this.game.entities.forEach(entity => {
            if (entity.type === 'unit') {
                // Store server position for interpolation
                entity.serverX = entity.x;
                entity.serverY = entity.y;
                
                // Restore current position to previous position for smooth interpolation
                if (entity.prevX !== undefined && entity.prevY !== undefined) {
                    entity.x = entity.prevX;
                    entity.y = entity.prevY;
                }
            }
        });
    }
    
    /**
     * Handle new player joining
     */
    onPlayerJoined(data) {
        console.log('Player joined:', data.player);
        // Could show a notification or update player list
    }
    
    /**
     * Handle player leaving
     */
    onPlayerLeft(data) {
        console.log('Player left:', data.playerId);
        // Could show a notification or update player list
    }
    
    /**
     * Handle new unit creation
     */
    onUnitCreated(data) {
        console.log('Unit created:', data.unit);
        // Process the new unit using the same method
        this.game.processServerEntities({ [data.unit.id]: data.unit });
    }
    
    /**
     * Handle units being moved
     */
    onUnitsMoved(data) {
        const { unitIds, targetX, targetY } = data;
        
        unitIds.forEach(unitId => {
            const unit = this.game.entities.find(e => e.id === unitId);
            if (unit) {
                unit.moveTo(targetX, targetY);
            }
        });
    }
    
    /**
     * Handle entity removal
     */
    onEntityRemoved(data) {
        const entityIndex = this.game.entities.findIndex(e => e.id === data.entityId);
        if (entityIndex !== -1) {
            this.game.entities.splice(entityIndex, 1);
        }
    }
    
    /**
     * Create an entity from server data
     */
    createEntityFromServer(entityData) {
        // This method is now deprecated in favor of processServerEntities
        console.warn('createEntityFromServer is deprecated, use processServerEntities instead');
        
        if (entityData.type === 'unit') {
            const unit = new Unit(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.unitType || 'SOLDIER',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            unit.id = entityData.id;
            unit.playerId = entityData.playerId;
            
            // Set unit attributes from server data
            if (entityData.health !== undefined) unit.health = entityData.health;
            if (entityData.maxHealth !== undefined) unit.maxHealth = entityData.maxHealth;
            if (entityData.attackDamage !== undefined) unit.attackDamage = entityData.attackDamage;
            if (entityData.attackRange !== undefined) unit.attackRange = entityData.attackRange;
            if (entityData.attackCooldown !== undefined) unit.attackCooldown = entityData.attackCooldown;
            if (entityData.speed !== undefined) unit.speed = entityData.speed;
            if (entityData.level !== undefined) unit.level = entityData.level;
            if (entityData.experience !== undefined) unit.experience = entityData.experience;
            
            // Set movement properties
            if (entityData.targetX !== undefined) unit.targetX = entityData.targetX;
            if (entityData.targetY !== undefined) unit.targetY = entityData.targetY;
            if (entityData.isMoving !== undefined) unit.isMoving = entityData.isMoving;
            
            // Add to game entities
            this.game.entities.push(unit);
            return unit;
        } else if (entityData.type === 'building') {
            const building = new Building(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.buildingType || 'BASE',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            building.id = entityData.id;
            building.playerId = entityData.playerId;
            
            // Set building attributes from server data
            if (entityData.health !== undefined) building.health = entityData.health;
            if (entityData.maxHealth !== undefined) building.maxHealth = entityData.maxHealth;
            
            // Add to game entities
            this.game.entities.push(building);
            return building;
        }
        
        return null;
    }
    
    /**
     * Create a new unit
     */
    createUnit(x, y, isPlayerControlled, unitType = 'SOLDIER') {
        if (!this.connected) {
            console.error('Cannot create unit: not connected to server');
            return;
        }
        
        this.socket.emit('createUnit', {
            x,
            y,
            isPlayerControlled,
            unitType
        });
    }
    
    /**
     * Move units and send to server
     */
    moveUnits(unitIds, targetX, targetY) {
        if (!this.connected) {
            this.pendingCommands.push(() => this.moveUnits(unitIds, targetX, targetY));
            return;
        }
        
        this.socket.emit('moveUnits', {
            unitIds,
            targetX,
            targetY
        });
    }
    
    /**
     * Process any pending commands
     */
    processPendingCommands() {
        if (!this.connected) return;
        
        while (this.pendingCommands.length > 0) {
            const command = this.pendingCommands.shift();
            command();
        }
    }
    
    /**
     * Update method called each frame
     */
    update(deltaTime) {
        // Interpolate entity positions between server updates
        if (this.connected) {
            const currentTime = Date.now();
            
            this.game.entities.forEach(entity => {
                // Only interpolate units, not buildings
                if (entity.type === 'unit' && entity.serverX !== undefined && entity.serverY !== undefined) {
                    // Calculate interpolation progress
                    const interpolationDuration = 100; // ms, adjust based on server update frequency
                    const timeSinceUpdate = entity.interpolationStartTime ? 
                        currentTime - entity.interpolationStartTime : 0;
                    
                    // Calculate interpolation factor (0 to 1)
                    let t = Math.min(timeSinceUpdate / interpolationDuration, 1.0);
                    
                    // Apply easing function for smoother movement (ease-out)
                    t = 1 - Math.pow(1 - t, 2);
                    
                    // Apply interpolation
                    if (t < 1.0) {
                        // Interpolate between current position and server position
                        entity.x = entity.prevX + (entity.serverX - entity.prevX) * t;
                        entity.y = entity.prevY + (entity.serverY - entity.prevY) * t;
                    } else {
                        // Reached target position
                        entity.x = entity.serverX;
                        entity.y = entity.serverY;
                    }
                    
                    // If unit is not moving, ensure it's exactly at the server position
                    if (!entity.isMoving && t >= 1.0) {
                        entity.x = entity.serverX;
                        entity.y = entity.serverY;
                    }
                }
            });
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Renderer.js 
======================================== 
 
/**
 * Handles all rendering operations for the game
 */
class Renderer {
    /**
     * Initialize the renderer
     */
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        this.ctx = game.ctx;
        this.camera = game.camera;
        this.map = game.map;
        
        // Preload images
        this.preloadImages();
    }
    
    /**
     * Preload unit and building images for different player colors
     */
    preloadImages() {
        // Preload soldier images for each player color
        Config.PLAYER_COLORS.forEach(color => {
            // Preload unit images
            const unitImg = new Image();
            unitImg.src = `/images/units/${color}_soldier.svg`;
            
            // Preload building images
            const baseImg = new Image();
            baseImg.src = `/images/buildings/${color}_base.svg`;
        });
    }
    
    /**
     * Clear the canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    /**
     * Render the entire game scene
     */
    render() {
        this.clear();
        
        // Render map tiles
        this.renderMap();
        
        // Render entities (units, buildings)
        this.renderEntities();
        
        // Render UI elements
        this.renderUI();
        
        // Render debug information if enabled
        if (Config.DEBUG_MODE) {
            this.renderDebugInfo();
        }
    }
    
    /**
     * Render the map tiles
     */
    renderMap() {
        // Calculate visible tile range based on camera position and zoom
        const startCol = Math.floor(this.camera.x / Config.TILE_SIZE);
        const endCol = Math.min(
            startCol + Math.ceil((this.camera.width / this.camera.zoom) / Config.TILE_SIZE) + 1,
            Config.MAP_WIDTH
        );
        
        const startRow = Math.floor(this.camera.y / Config.TILE_SIZE);
        const endRow = Math.min(
            startRow + Math.ceil((this.camera.height / this.camera.zoom) / Config.TILE_SIZE) + 1,
            Config.MAP_HEIGHT
        );
        
        // Render only visible tiles
        for (let row = startRow; row < endRow; row++) {
            for (let col = startCol; col < endCol; col++) {
                const tile = this.map.getTile(col, row);
                if (!tile) continue;
                
                const worldX = col * Config.TILE_SIZE;
                const worldY = row * Config.TILE_SIZE;
                
                // Convert world coordinates to screen coordinates
                const screenPos = this.camera.worldToScreen(worldX, worldY);
                
                // Calculate tile size with zoom
                const tileSize = Config.TILE_SIZE * this.camera.zoom;
                
                // Draw the tile
                this.ctx.fillStyle = this.getTileColor(tile.type);
                this.ctx.fillRect(
                    screenPos.x,
                    screenPos.y,
                    tileSize,
                    tileSize
                );
                
                // Draw grid lines if enabled
                if (Config.SHOW_GRID) {
                    this.ctx.strokeStyle = Config.COLORS.GRID;
                    this.ctx.strokeRect(
                        screenPos.x,
                        screenPos.y,
                        tileSize,
                        tileSize
                    );
                }
            }
        }
    }
    
    /**
     * Get color for a tile type
     */
    getTileColor(tileType) {
        switch (tileType) {
            case 'grass': return Config.COLORS.GRASS;
            case 'water': return Config.COLORS.WATER;
            case 'sand': return Config.COLORS.SAND;
            case 'mountain': return Config.COLORS.MOUNTAIN;
            case 'forest': return Config.COLORS.FOREST;
            default: return Config.COLORS.GRASS;
        }
    }
    
    /**
     * Render all entities
     */
    renderEntities() {
        console.log(`Rendering ${this.game.entities.length} entities`);
        
        // Render all entities that are in the visible area
        for (const entity of this.game.entities) {
            console.log(`Entity: ${entity.constructor.name}, position: (${entity.x}, ${entity.y})`);
            
            // Skip entities outside the visible area
            if (!this.camera.isVisible(
                entity.x,
                entity.y,
                entity.width,
                entity.height
            )) {
                console.log(`Entity at (${entity.x}, ${entity.y}) is not visible`);
                continue;
            }
            
            // Convert world coordinates to screen coordinates
            const screenPos = this.camera.worldToScreen(entity.x, entity.y);
            
            // Calculate entity size with zoom
            const width = entity.width * this.camera.zoom;
            const height = entity.height * this.camera.zoom;
            
            // Draw the entity based on its type
            if (entity.constructor.name === 'Unit' || entity instanceof Unit) {
                this.renderUnit(entity, screenPos, width, height);
            } else if (entity.constructor.name === 'Building' || entity.buildingType) {
                this.renderBuilding(entity, screenPos, width, height);
            } else {
                // Fallback for other entity types
                console.log(`Using fallback rendering for entity type: ${entity.constructor.name}`);
                this.ctx.fillStyle = entity.isPlayerControlled ? 
                    Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
                    
                this.ctx.fillRect(
                    screenPos.x,
                    screenPos.y,
                    width,
                    height
                );
            }
            
            // Draw selection highlight if entity is selected
            if (entity.isSelected) {
                this.ctx.strokeStyle = Config.COLORS.SELECTION;
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(
                    screenPos.x - 2,
                    screenPos.y - 2,
                    width + 4,
                    height + 4
                );
                this.ctx.lineWidth = 1;
            }
        }
    }
    
    /**
     * Render a unit with its image and health bar
     */
    renderUnit(unit, screenPos, width, height) {
        // Draw unit image if available
        if (unit.image && unit.image.complete) {
            this.ctx.drawImage(
                unit.image,
                screenPos.x,
                screenPos.y,
                width,
                height
            );
        } else {
            // Fallback to colored rectangle if image not loaded
            this.ctx.fillStyle = unit.isPlayerControlled ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
                
            this.ctx.fillRect(
                screenPos.x,
                screenPos.y,
                width,
                height
            );
        }
        
        // Draw health bar
        const healthBarWidth = width;
        const healthBarHeight = 4 * this.camera.zoom;
        const healthPercentage = unit.health / unit.maxHealth;
        
        // Health bar background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x,
            screenPos.y - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health bar fill
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x,
            screenPos.y - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Draw level indicator if level > 1
        if (unit.level > 1) {
            this.ctx.fillStyle = 'white';
            this.ctx.font = `${10 * this.camera.zoom}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                unit.level.toString(),
                screenPos.x + width / 2,
                screenPos.y + height + 12 * this.camera.zoom
            );
        }
    }
    
    /**
     * Render a building with its image and health bar
     */
    renderBuilding(building, screenPos, width, height) {
        console.log(`Rendering building: ${building.buildingType} at screen position (${screenPos.x}, ${screenPos.y}), world position (${building.x}, ${building.y})`);
        
        // Always draw a solid base rectangle first
        this.ctx.fillStyle = building.playerColor === 'red' ? 
            '#ff0000' : building.playerColor === 'blue' ? 
            '#0000ff' : '#888888';
            
        this.ctx.fillRect(
            screenPos.x,
            screenPos.y,
            width,
            height
        );
        
        // Draw building image if available
        if (building.image && building.image.complete) {
            console.log(`Drawing building image: ${building.playerColor}_${building.buildingType.toLowerCase()}.svg`);
            this.ctx.drawImage(
                building.image,
                screenPos.x,
                screenPos.y,
                width,
                height
            );
        }
        
        // Draw a border
        this.ctx.strokeStyle = '#000000';
        this.ctx.lineWidth = 2;
        this.ctx.strokeRect(
            screenPos.x,
            screenPos.y,
            width,
            height
        );
        
        // Draw health bar
        const healthPercentage = building.health / building.maxHealth;
        const healthBarWidth = width;
        const healthBarHeight = 5 * this.camera.zoom;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x,
            screenPos.y - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x,
            screenPos.y - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Determine the label based on player color
        let baseLabel = building.buildingType;
        if (building.buildingType === 'BASE') {
            baseLabel = building.playerColor === 'blue' ? 'Human Base' : 'AI Base';
        }
        
        // Draw building type text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = `${12 * this.camera.zoom}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(
            baseLabel,
            screenPos.x + width / 2,
            screenPos.y + height / 2
        );
    }
    
    /**
     * Get color for health bar based on percentage
     */
    getHealthColor(percentage) {
        if (percentage > 0.6) {
            return 'rgb(0, 255, 0)'; // Green
        } else if (percentage > 0.3) {
            return 'rgb(255, 255, 0)'; // Yellow
        } else {
            return 'rgb(255, 0, 0)'; // Red
        }
    }
    
    /**
     * Render UI elements
     */
    renderUI() {
        // Render selection box if dragging
        const selectionBox = this.game.inputHandler.getSelectionBox();
        if (selectionBox) {
            this.ctx.strokeStyle = Config.COLORS.SELECTION;
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
            
            // Semi-transparent fill
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.fillRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
        }
        
        // Render minimap
        this.renderMinimap();
        
        // Render selected unit info
        this.renderSelectedUnitInfo();
    }
    
    /**
     * Render the minimap
     */
    renderMinimap() {
        const minimapElement = document.getElementById('minimap');
        if (!minimapElement) return;
        
        // Create a canvas for the minimap if it doesn't exist
        if (!this.minimapCanvas) {
            this.minimapCanvas = document.createElement('canvas');
            this.minimapCanvas.width = 180; // Slightly smaller than the container
            this.minimapCanvas.height = 180;
            this.minimapCtx = this.minimapCanvas.getContext('2d');
            minimapElement.appendChild(this.minimapCanvas);
        }
        
        // Clear the minimap
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // Calculate scale factors
        const scaleX = this.minimapCanvas.width / (Config.MAP_WIDTH * Config.TILE_SIZE);
        const scaleY = this.minimapCanvas.height / (Config.MAP_HEIGHT * Config.TILE_SIZE);
        
        // Draw map tiles
        for (let row = 0; row < Config.MAP_HEIGHT; row++) {
            for (let col = 0; col < Config.MAP_WIDTH; col++) {
                const tile = this.map.getTile(col, row);
                if (!tile) continue;
                
                const x = col * Config.TILE_SIZE * scaleX;
                const y = row * Config.TILE_SIZE * scaleY;
                const width = Config.TILE_SIZE * scaleX;
                const height = Config.TILE_SIZE * scaleY;
                
                this.minimapCtx.fillStyle = this.getTileColor(tile.type);
                this.minimapCtx.fillRect(x, y, width, height);
            }
        }
        
        // Draw entities
        for (const entity of this.game.entities) {
            const x = entity.x * scaleX;
            const y = entity.y * scaleY;
            const width = entity.width * scaleX;
            const height = entity.height * scaleY;
            
            // Use the entity's playerColor property to determine the color
            if (entity.playerColor) {
                this.minimapCtx.fillStyle = entity.playerColor === 'blue' ? 
                    Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            } else {
                // Fallback to the old method if playerColor is not available
                this.minimapCtx.fillStyle = entity.isPlayerControlled ? 
                    Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            }
            this.minimapCtx.fillRect(x, y, width, height);
        }
        
        // Draw camera viewport rectangle
        const viewportX = this.camera.x * scaleX;
        const viewportY = this.camera.y * scaleY;
        const viewportWidth = (this.camera.width / this.camera.zoom) * scaleX;
        const viewportHeight = (this.camera.height / this.camera.zoom) * scaleY;
        
        this.minimapCtx.strokeStyle = 'white';
        this.minimapCtx.lineWidth = 1;
        this.minimapCtx.strokeRect(viewportX, viewportY, viewportWidth, viewportHeight);
    }
    
    /**
     * Render information about selected units
     */
    renderSelectedUnitInfo() {
        const selectedUnits = this.game.entities.filter(e => e.isSelected && e instanceof Unit);
        
        if (selectedUnits.length === 0) {
            return;
        }
        
        // If only one unit is selected, show detailed info
        if (selectedUnits.length === 1) {
            const unit = selectedUnits[0];
            const padding = 10;
            const lineHeight = 20;
            
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(
                this.canvas.width - 200 - padding,
                padding,
                200,
                150
            );
            
            this.ctx.fillStyle = 'white';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'left';
            
            let y = padding + lineHeight;
            
            this.ctx.fillText(`Unit Type: ${unit.unitType}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            this.ctx.fillText(`Level: ${unit.level}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            this.ctx.fillText(`Health: ${unit.health}/${unit.maxHealth}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            this.ctx.fillText(`Attack: ${unit.attackDamage}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            this.ctx.fillText(`Range: ${unit.attackRange}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            this.ctx.fillText(`Speed: ${unit.speed}`, this.canvas.width - 190, y);
            y += lineHeight;
            
            if (unit.level < 10) { // Max level cap
                const expNeeded = unit.level * 100;
                this.ctx.fillText(`XP: ${unit.experience}/${expNeeded}`, this.canvas.width - 190, y);
            }
        } else {
            // If multiple units are selected, show count
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            this.ctx.fillRect(
                this.canvas.width - 200 - 10,
                10,
                200,
                40
            );
            
            this.ctx.fillStyle = 'white';
            this.ctx.font = '14px Arial';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                `${selectedUnits.length} units selected`,
                this.canvas.width - 110,
                35
            );
        }
    }
    
    /**
     * Render debug information
     */
    renderDebugInfo() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'left';
        
        // Display FPS
        this.ctx.fillText(`FPS: ${this.game.fps.toFixed(1)}`, 10, 20);
        
        // Display camera position
        this.ctx.fillText(`Camera: (${this.camera.x.toFixed(0)}, ${this.camera.y.toFixed(0)})`, 10, 40);
        
        // Display zoom level
        this.ctx.fillText(`Zoom: ${(this.camera.zoom * 100).toFixed(0)}%`, 10, 60);
        
        // Display entity count
        this.ctx.fillText(`Entities: ${this.game.entities.length}`, 10, 80);
        
        // Display selected entities count
        const selectedCount = this.game.entities.filter(e => e.isSelected).length;
        this.ctx.fillText(`Selected: ${selectedCount}`, 10, 100);
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Map.js 
======================================== 
 
/**
 * Manages the game map
 */
class Map {
    /**
     * Initialize the map
     */
    constructor() {
        this.width = Config.MAP_WIDTH;
        this.height = Config.MAP_HEIGHT;
        this.tiles = [];
        
        // Initialize with empty tiles
        this.initializeEmptyTiles();
    }
    
    /**
     * Initialize empty tiles
     */
    initializeEmptyTiles() {
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                // Initialize with grass tiles as a fallback
                this.tiles[y][x] = new Tile('grass');
            }
        }
        console.log('Initialized empty map');
    }
    
    /**
     * Set the map data from the server
     */
    setMapFromServer(mapData) {
        console.log('Received map data from server', mapData ? 'valid' : 'invalid');
        
        if (!mapData || !Array.isArray(mapData) || mapData.length === 0) {
            console.error('Invalid map data from server');
            return;
        }
        
        this.height = mapData.length;
        this.width = mapData[0].length;
        
        console.log(`Setting map from server data: ${this.width}x${this.height}`);
        
        // Convert server map data to our tile format
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                if (!mapData[y] || !mapData[y][x]) {
                    console.error(`Missing tile data at ${x},${y}`);
                    this.tiles[y][x] = new Tile('grass');
                    continue;
                }
                
                const serverTile = mapData[y][x];
                this.tiles[y][x] = new Tile(serverTile.type || 'grass');
                this.tiles[y][x].walkable = serverTile.walkable !== undefined ? 
                    serverTile.walkable : 
                    (serverTile.type !== 'water' && serverTile.type !== 'mountain');
            }
        }
        
        console.log('Map set from server data');
    }
    
    /**
     * Get the tile at the specified coordinates
     */
    getTile(x, y) {
        // Check bounds
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
            return null;
        }
        
        // Check if tiles array is properly initialized
        if (!this.tiles || !this.tiles[y] || !this.tiles[y][x]) {
            console.warn(`Tile at ${x},${y} is not initialized`);
            return new Tile('grass'); // Return a default tile
        }
        
        return this.tiles[y][x];
    }
    
    /**
     * Check if a tile is walkable
     */
    isWalkable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.walkable;
    }
    
    /**
     * Check if a tile is buildable
     */
    isBuildable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.buildable;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Tile.js 
======================================== 
 
/**
 * Represents a single tile on the game map
 */
class Tile {
    /**
     * Initialize a tile
     */
    constructor(type = 'grass') {
        // Ensure valid tile type
        this.type = this.validateTileType(type);
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
        this.resourceType = this.getResourceType(this.type);
        this.resourceAmount = this.resourceType ? Math.floor(Math.random() * 500) + 500 : 0;
    }
    
    /**
     * Validate and normalize tile type
     */
    validateTileType(type) {
        const validTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        if (!type || typeof type !== 'string') {
            console.warn(`Invalid tile type: ${type}, defaulting to grass`);
            return 'grass';
        }
        
        const normalizedType = type.toLowerCase();
        
        if (!validTypes.includes(normalizedType)) {
            console.warn(`Unknown tile type: ${normalizedType}, defaulting to grass`);
            return 'grass';
        }
        
        return normalizedType;
    }
    
    /**
     * Determine if a tile type is walkable
     */
    isWalkable(type) {
        switch (type) {
            case 'water':
            case 'mountain':
                return false;
            case 'grass':
            case 'sand':
            case 'forest':
                return true;
            default:
                return true;
        }
    }
    
    /**
     * Determine if a tile type is buildable
     */
    isBuildable(type) {
        switch (type) {
            case 'grass':
            case 'sand':
                return true;
            case 'water':
            case 'mountain':
            case 'forest':
                return false;
            default:
                return false;
        }
    }
    
    /**
     * Get resource type for a tile if applicable
     */
    getResourceType(type) {
        switch (type) {
            case 'forest':
                return 'wood';
            case 'mountain':
                return 'stone';
            default:
                return null;
        }
    }
    
    /**
     * Extract resources from the tile
     */
    extractResource(amount) {
        if (!this.resourceType || this.resourceAmount <= 0) {
            return 0;
        }
        
        const extracted = Math.min(amount, this.resourceAmount);
        this.resourceAmount -= extracted;
        
        // If resources are depleted, change the tile type
        if (this.resourceAmount <= 0) {
            this.depleteResource();
        }
        
        return extracted;
    }
    
    /**
     * Handle resource depletion
     */
    depleteResource() {
        switch (this.resourceType) {
            case 'wood':
                this.type = 'grass';
                break;
            case 'stone':
                this.type = 'mountain';
                break;
            default:
                break;
        }
        
        this.resourceType = null;
        this.resourceAmount = 0;
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\utils\helpers.js 
======================================== 
 
/**
 * Utility functions for the game
 */

/**
 * Calculate distance between two points
 */
function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation between two values
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}

/**
 * Generate a random integer between min and max (inclusive)
 */
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Check if a point is inside a rectangle
 */
function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

/**
 * Check if two rectangles overlap
 */
function rectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h) {
    return (
        r1x < r2x + r2w &&
        r1x + r1w > r2x &&
        r1y < r2y + r2h &&
        r1y + r1h > r2y
    );
}

/**
 * Convert degrees to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Convert radians to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Calculate the angle between two points (in radians)
 */
function angleBetweenPoints(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
}

/**
 * Get a point on a circle given center, radius, and angle
 */
function pointOnCircle(centerX, centerY, radius, angleRadians) {
    return {
        x: centerX + radius * Math.cos(angleRadians),
        y: centerY + radius * Math.sin(angleRadians)
    };
}

/**
 * Shuffle an array (Fisher-Yates algorithm)
 */
function shuffleArray(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Format time in seconds to MM:SS format
 */
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Ease in-out function (smooth acceleration and deceleration)
 */
function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Get a random element from an array
 */
function randomArrayElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

/**
 * Check if a value is between min and max (inclusive)
 */
function isBetween(value, min, max) {
    return value >= min && value <= max;
}

/**
 * Calculate the Manhattan distance between two points
 */
function manhattanDistance(x1, y1, x2, y2) {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1);
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\index.html 
======================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massive RTS Game</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="resourcesPanel" class="panel">
                <!-- Resources will be displayed here -->
            </div>
            <div id="minimap" class="panel">
                <!-- Minimap will be displayed here -->
            </div>
            <div id="controlPanel" class="panel">
                <!-- Control buttons will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Game scripts -->
    <script src="/src/utils/helpers.js"></script>
    <script src="/src/map/Tile.js"></script>
    <script src="/src/map/Map.js"></script>
    <script src="/src/entities/Entity.js"></script>
    <script src="/src/entities/Unit.js"></script>
    <script src="/src/entities/Building.js"></script>
    <script src="/src/game/Config.js"></script>
    <script src="/src/game/Camera.js"></script>
    <script src="/src/game/InputHandler.js"></script>
    <script src="/src/game/Renderer.js"></script>
    <script src="/src/game/Multiplayer.js"></script>
    <script src="/src/game/Game.js"></script>
    <script>
        // Initialize the game when the window loads
        window.onload = function() {
            const game = new Game();
            game.start();
        };
    </script>
</body>
</html>  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\styles.css 
======================================== 
 
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #222;
    color: #fff;
    overflow: hidden;
}

.game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    background-color: #000;
}

.ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allow clicks to pass through to canvas */
}

.panel {
    pointer-events: auto; /* Make panels clickable */
    background-color: rgba(0, 0, 0, 0.7);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
}

#resourcesPanel {
    position: absolute;
    top: 10px;
    left: 220px;
    width: 200px;
}

#minimap {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    height: 200px;
}

#controlPanel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 200px;
}

.control-btn {
    display: block;
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 8px;
    background-color: #2a6496;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    text-align: center;
    transition: background-color 0.2s;
}

.control-btn:hover {
    background-color: #3a7db5;
}

.control-btn:active {
    background-color: #1a5486;
}  
 
 
======================================== 
FILE: package.json 
======================================== 
 
{
  "name": "massive-rts",
  "version": "0.1.0",
  "description": "A browser-based RTS game with massively multiplayer capabilities",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "client": "http-server -c-1 -p 8080",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "rts",
    "game",
    "multiplayer",
    "browser",
    "html5",
    "canvas"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "http-server": "^14.1.1",
    "nodemon": "^3.0.1"
  }
}  
 
