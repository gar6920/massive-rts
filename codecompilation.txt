Massive RTS Game - Code Compilation 
Created: Wed 03/05/2025 13:42:32.77 
======================================== 
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Building.js 
======================================== 
 
/**
 * Building class for player bases and other structures
 */
class Building extends Entity {
  /**
   * Initialize a building
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width of the building
   * @param {number} height - Height of the building
   * @param {boolean} isPlayerControlled - Whether this building is controlled by the player
   * @param {string} buildingType - Type of building (e.g., 'BASE', 'BARRACKS')
   * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
   */
  constructor(x, y, width, height, isPlayerControlled = false, buildingType = 'BASE', playerColor = 'red') {
    super(x, y, width, height, isPlayerControlled);
    
    console.log(`Creating building: ${buildingType} at (${x}, ${y}) with color ${playerColor}`);
    
    // Building type and appearance
    this.buildingType = buildingType;
    this.playerColor = playerColor;
    this.image = null;
    this.loadImage();
    
    // Apply attributes based on building type
    const attributes = Config.BUILDING_ATTRIBUTES[buildingType] || Config.BUILDING_ATTRIBUTES.BASE;
    
    // Building properties
    this.productionRate = attributes.productionRate || 0;
    this.productionType = attributes.productionType || null;
    this.productionProgress = 0;
    this.productionQueue = [];
    
    // Health and stats
    this.health = attributes.health || 500;
    this.maxHealth = attributes.health || 500;
  }
  
  /**
   * Load the building image based on player color and building type
   */
  loadImage() {
    const imagePath = `/images/buildings/${this.playerColor}_${this.buildingType.toLowerCase()}.png`;
    console.log(`Loading building image: ${imagePath}`);
    this.image = new Image();
    this.image.src = imagePath;
    this.image.onerror = (e) => {
      console.error(`Failed to load building image: ${imagePath}`, e);
      // Fallback to a colored rectangle
      console.log(`Attempting to load fallback image: /images/buildings/${this.buildingType.toLowerCase()}.png`);
      this.image.src = `/images/buildings/${this.buildingType.toLowerCase()}.png`;
    };
    this.image.onload = () => {
      console.log(`Successfully loaded building image: ${imagePath}`);
    };
  }
  
  /**
   * Set the player color for this building
   */
  setPlayerColor(color) {
    this.playerColor = color;
    this.loadImage();
  }
  
  /**
   * Update building state
   */
  update(deltaTime, game) {
    // Handle production if this building produces units
    if (this.productionRate > 0 && this.productionQueue.length > 0) {
      this.updateProduction(deltaTime, game);
    }
  }
  
  /**
   * Update production progress
   */
  updateProduction(deltaTime, game) {
    // Increase production progress
    this.productionProgress += (this.productionRate * deltaTime) / 1000;
    
    // Check if production is complete
    if (this.productionProgress >= 1) {
      this.completeProduction(game);
      this.productionProgress = 0;
    }
  }
  
  /**
   * Complete production of a unit
   */
  completeProduction(game) {
    if (this.productionQueue.length === 0) return;
    
    // Get the unit type from the queue
    const unitType = this.productionQueue.shift();
    
    // Calculate spawn position (near the building)
    const spawnX = this.x + this.width + 10;
    const spawnY = this.y + this.height / 2;
    
    // Create the unit
    const unit = new Unit(
      spawnX,
      spawnY,
      Config.UNIT_SIZE,
      Config.UNIT_SIZE,
      this.isPlayerControlled,
      unitType,
      this.playerColor
    );
    
    // Set the player ID
    unit.playerId = this.playerId;
    
    // Add the unit to the game
    game.entities.push(unit);
    
    console.log(`Building produced a ${unitType}`);
  }
  
  /**
   * Queue a unit for production
   */
  queueUnit(unitType) {
    this.productionQueue.push(unitType);
    console.log(`Added ${unitType} to production queue`);
  }
  
  /**
   * Take damage from an attacker
   */
  takeDamage(amount, attacker) {
    this.health -= amount;
    console.log(`Building took ${amount} damage, health: ${this.health}`);
    
    // If health drops to 0 or below, destroy the building
    if (this.health <= 0) {
      this.die();
    }
  }
  
  /**
   * Handle building destruction
   */
  die() {
    console.log('Building destroyed');
    // In a real implementation, we would remove the building from the game
    // and possibly play a destruction animation
  }
  
  /**
   * Convert building to a network-friendly format
   */
  toNetworkData() {
    const data = super.toNetworkData();
    return {
      ...data,
      buildingType: this.buildingType,
      playerColor: this.playerColor,
      productionRate: this.productionRate,
      productionType: this.productionType,
      productionProgress: this.productionProgress,
      productionQueue: this.productionQueue
    };
  }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Entity.js 
======================================== 
 
/**
 * Base class for all game entities (units, buildings, etc.)
 */
class Entity {
    /**
     * Initialize an entity
     */
    constructor(x, y, width, height, isPlayerControlled = false) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.isPlayerControlled = isPlayerControlled;
        this.isSelected = false;
        this.health = 100;
        this.maxHealth = 100;
        
        // Multiplayer properties
        this.id = null; // Server-assigned ID
        this.playerId = null; // ID of the player who owns this entity
        this.serverX = null; // Position from server for interpolation
        this.serverY = null; // Position from server for interpolation
    }
    
    /**
     * Update entity state
     */
    update(deltaTime, game) {
        // Base entity doesn't do anything in update
        // This method should be overridden by subclasses
    }
    
    /**
     * Check if this entity collides with another entity
     */
    collidesWith(otherEntity) {
        return (
            this.x < otherEntity.x + otherEntity.width &&
            this.x + this.width > otherEntity.x &&
            this.y < otherEntity.y + otherEntity.height &&
            this.y + this.height > otherEntity.y
        );
    }
    
    /**
     * Check if this entity contains a point
     */
    containsPoint(x, y) {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
    
    /**
     * Take damage
     */
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0;
            this.die();
        }
    }
    
    /**
     * Entity death
     */
    die() {
        // This method should be overridden by subclasses
        console.log('Entity died');
    }
    
    /**
     * Get the center position of the entity
     */
    getCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    
    /**
     * Calculate distance to another entity or point
     */
    distanceTo(target) {
        let targetX, targetY;
        
        if (target instanceof Entity) {
            const targetCenter = target.getCenter();
            targetX = targetCenter.x;
            targetY = targetCenter.y;
        } else {
            targetX = target.x;
            targetY = target.y;
        }
        
        const center = this.getCenter();
        const dx = targetX - center.x;
        const dy = targetY - center.y;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Convert entity to a network-friendly format
     */
    toNetworkData() {
        return {
            id: this.id,
            type: this.constructor.name.toLowerCase(),
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            health: this.health,
            playerId: this.playerId,
            isPlayerControlled: this.isPlayerControlled
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Unit.js 
======================================== 
 
/**
 * Unit class for player and AI controlled units
 */
class Unit extends Entity {
    /**
     * Initialize a unit
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width of the unit
     * @param {number} height - Height of the unit
     * @param {boolean} isPlayerControlled - Whether this unit is controlled by the player
     * @param {string} unitType - Type of unit (e.g., 'SOLDIER')
     * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
     */
    constructor(x, y, width, height, isPlayerControlled = false, unitType = 'SOLDIER', playerColor = 'red') {
        super(x, y, width, height, isPlayerControlled);
        
        // Unit type and appearance
        this.unitType = unitType;
        this.playerColor = playerColor;
        this.image = null;
        this.loadImage();
        
        // Apply attributes based on unit type
        const attributes = Config.UNIT_ATTRIBUTES[unitType] || Config.UNIT_ATTRIBUTES.SOLDIER;
        
        // Movement properties
        this.speed = attributes.speed || Config.UNIT_SPEED;
        this.targetX = null;
        this.targetY = null;
        this.isMoving = false;
        
        // Combat properties
        this.attackRange = attributes.attackRange || 50;
        this.attackDamage = attributes.attackDamage || 10;
        this.attackCooldown = attributes.attackCooldown || 1000; // ms
        this.lastAttackTime = 0;
        this.targetEntity = null;
        
        // Health and stats
        this.health = attributes.health || 100;
        this.maxHealth = attributes.health || 100;
        this.level = 1;
        this.experience = 0;
    }
    
    /**
     * Load the unit image based on player color and unit type
     */
    loadImage() {
        const imagePath = `/images/units/${this.playerColor}_${this.unitType.toLowerCase()}.png`;
        console.log(`Loading unit image: ${imagePath}`);
        this.image = new Image();
        this.image.src = imagePath;
        this.image.onerror = () => {
            console.error(`Failed to load unit image: ${imagePath}`);
            // Fallback to default image if available
            console.log(`Attempting to load fallback image: /images/units/${this.unitType.toLowerCase()}.png`);
            this.image.src = `/images/units/${this.unitType.toLowerCase()}.png`;
        };
    }
    
    /**
     * Set the player color for this unit
     */
    setPlayerColor(color) {
        this.playerColor = color;
        this.loadImage();
    }
    
    /**
     * Update unit state
     */
    update(deltaTime, game) {
        // Only use local movement if we're not receiving server updates
        // This prevents conflicts with the interpolation in Game.updateEntities
        if (this.serverX === undefined && this.isMoving && this.targetX !== null && this.targetY !== null) {
            this.moveTowardsTarget(deltaTime);
        }
        
        // Handle combat if we have a target entity
        if (this.targetEntity) {
            this.updateCombat(deltaTime, game);
        }
    }
    
    /**
     * Move towards the target position
     */
    moveTowardsTarget(deltaTime) {
        // Calculate direction to target
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If we're close enough to the target, stop moving
        if (distance < 1) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.isMoving = false;
            this.targetX = null;
            this.targetY = null;
            return;
        }
        
        // Normalize direction and apply speed
        const moveSpeed = Config.UNIT_SPEED * (deltaTime / 1000);
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;
        
        // Calculate new position
        const newX = this.x + normalizedDx * moveSpeed;
        const newY = this.y + normalizedDy * moveSpeed;
        
        // Ensure the unit stays within map boundaries
        const mapWidth = Config.MAP_WIDTH * Config.TILE_SIZE;
        const mapHeight = Config.MAP_HEIGHT * Config.TILE_SIZE;
        
        this.x = Math.max(0, Math.min(newX, mapWidth - this.width));
        this.y = Math.max(0, Math.min(newY, mapHeight - this.height));
    }
    
    /**
     * Set a movement target
     */
    setTarget(x, y) {
        this.targetX = x;
        this.targetY = y;
        this.isMoving = true;
    }
    
    /**
     * Update combat state
     */
    updateCombat(deltaTime, game) {
        // Check if target is still valid
        if (!this.targetEntity || this.targetEntity.health <= 0) {
            this.targetEntity = null;
            return;
        }
        
        // Calculate distance to target
        const center = this.getCenter();
        const targetCenter = this.targetEntity.getCenter();
        const dx = targetCenter.x - center.x;
        const dy = targetCenter.y - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If target is out of range, move towards it
        if (distance > this.attackRange) {
            this.setTarget(targetCenter.x, targetCenter.y);
            return;
        }
        
        // If we're in range and attack cooldown is over, attack
        const now = Date.now();
        if (now - this.lastAttackTime >= this.attackCooldown) {
            this.attack(this.targetEntity);
            this.lastAttackTime = now;
        }
    }
    
    /**
     * Attack a target entity
     */
    attack(target) {
        console.log(`Unit attacking target for ${this.attackDamage} damage`);
        target.takeDamage(this.attackDamage, this);
    }
    
    /**
     * Take damage from an attacker
     */
    takeDamage(amount, attacker) {
        this.health -= amount;
        console.log(`Unit took ${amount} damage, health: ${this.health}`);
        
        // If health drops to 0 or below, die
        if (this.health <= 0) {
            this.die();
            
            // Give experience to the attacker if it's a unit
            if (attacker instanceof Unit) {
                attacker.gainExperience(this.level * 10);
            }
        }
    }
    
    /**
     * Gain experience points
     */
    gainExperience(amount) {
        this.experience += amount;
        console.log(`Unit gained ${amount} experience, total: ${this.experience}`);
        
        // Check for level up (simple formula: 100 * current level)
        const experienceNeeded = this.level * 100;
        if (this.experience >= experienceNeeded) {
            this.levelUp();
        }
    }
    
    /**
     * Level up the unit
     */
    levelUp() {
        this.level++;
        this.experience = 0;
        
        // Increase stats
        this.maxHealth += 20;
        this.health = this.maxHealth;
        this.attackDamage += 5;
        
        console.log(`Unit leveled up to level ${this.level}`);
    }
    
    /**
     * Handle unit death
     */
    die() {
        console.log('Unit died');
        // In a real implementation, we would remove the unit from the game
        // and possibly play a death animation
    }
    
    /**
     * Convert unit to a network-friendly format
     */
    toNetworkData() {
        const data = super.toNetworkData();
        return {
            ...data,
            unitType: this.unitType,
            playerColor: this.playerColor,
            speed: this.speed,
            attackRange: this.attackRange,
            attackDamage: this.attackDamage,
            attackCooldown: this.attackCooldown,
            level: this.level,
            experience: this.experience,
            targetX: this.targetX,
            targetY: this.targetY,
            isMoving: this.isMoving
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\BuildingImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing building images
 */
class BuildingImageLoader {
    /**
     * Initialize the building image loader
     */
    constructor() {
        // Building types
        this.buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];
        
        // Player colors
        this.playerColors = ['red', 'blue', 'green', 'yellow'];
        
        // Store loaded images
        this.images = {};
        
        // Load all building images
        this.loadBuildingImages();
        
        console.log('BuildingImageLoader initialized');
    }
    
    /**
     * Load all building images
     */
    loadBuildingImages() {
        // Load default building images
        this.buildingTypes.forEach(buildingType => {
            const img = new Image();
            img.src = `/images/buildings/${buildingType.toLowerCase()}.png`;
            this.images[buildingType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded building image: ${buildingType}`);
            img.onerror = () => console.warn(`Failed to load building image: ${buildingType}`);
            
            // Load player-colored variants
            this.playerColors.forEach(color => {
                const coloredImg = new Image();
                coloredImg.src = `/images/buildings/${buildingType.toLowerCase()}_${color}.png`;
                this.images[`${buildingType}_${color}`] = coloredImg;
                
                // Log when image loads or fails
                coloredImg.onload = () => console.log(`Loaded building image: ${buildingType}_${color}`);
                coloredImg.onerror = () => console.warn(`Failed to load building image: ${buildingType}_${color}`);
            });
        });
    }
    
    /**
     * Get the image for a specific building type and player color
     */
    getBuildingImage(buildingType, playerColor = null) {
        if (playerColor) {
            const coloredImage = this.images[`${buildingType}_${playerColor}`];
            if (coloredImage) return coloredImage;
        }
        
        return this.images[buildingType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Camera.js 
======================================== 
 
/**
 * Camera class for handling viewport and map navigation
 */
class Camera {
    /**
     * Initialize the camera
     */
    constructor() {
        // Camera position (top-left corner of the viewport in world coordinates)
        this.x = 0;
        this.y = 0;
        
        // Camera dimensions (viewport size)
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Camera zoom level
        this.zoom = Config.ZOOM_DEFAULT;
        
        // Calculate initial boundaries based on current map dimensions
        this.updateBoundaries();
        
        // We'll center on player units later when they're created
        // Don't call centerOnMap() here
        
        console.log(`Camera initialized at position (${this.x}, ${this.y}) with zoom ${this.zoom}`);
    }

    /**
     * Center the camera on the map
     */
    centerOnMap() {
        // Calculate the map dimensions in isometric coordinates
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the isometric map width and height
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set camera position to center on the map
        this.x = isoCenterX - (viewportWorldWidth / 2);
        this.y = isoCenterY - (viewportWorldHeight / 2);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Camera centered on map at (${this.x.toFixed(2)}, ${this.y.toFixed(2)})`);
    }

    /**
     * Update camera boundaries based on current map dimensions
     */
    updateBoundaries() {
        // For isometric view, we need to calculate boundaries differently
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the width and height of the isometric map in world coordinates
        // In isometric view, the map width is (mapWidth + mapHeight) * tileSize / 2
        // and the map height is (mapWidth + mapHeight) * tileSize / 4
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Calculate maximum camera positions
        // We need to ensure the camera can't move so far that the map is off-screen
        // For isometric maps, we need more generous boundaries
        const extraPadding = Math.max(viewportWorldWidth, viewportWorldHeight) * 0.5;
        
        // Set more balanced boundaries
        // The key is to make the boundaries symmetrical around the map center
        this.maxX = isoCenterX + isoMapWidth/2 + extraPadding;
        this.maxY = isoCenterY + isoMapHeight/2 + extraPadding;
        this.minX = isoCenterX - isoMapWidth/2 - extraPadding;
        this.minY = isoCenterY - isoMapHeight/2 - extraPadding;
        
        console.log(`Camera boundaries updated: minX=${this.minX}, minY=${this.minY}, maxX=${this.maxX}, maxY=${this.maxY}`);
    }

    /**
     * Move the camera by the specified delta
     */
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.clampPosition();
    }

    /**
     * Set the camera position directly
     */
    setPosition(x, y) {
        this.x = x;
        this.y = y;
        this.clampPosition();
    }

    /**
     * Center the camera on a specific world position
     */
    centerOn(worldX, worldY) {
        // Calculate the position to center the camera on the given world coordinates
        this.x = worldX - (this.width / this.zoom / 2);
        this.y = worldY - (this.height / this.zoom / 2);
        
        // Ensure camera stays within map boundaries
        this.clampPosition();
    }

    /**
     * Ensure camera stays within map boundaries
     */
    clampPosition() {
        // For isometric view, we need to allow the camera to go slightly outside the map boundaries
        // to ensure the entire map is visible
        
        // Calculate the effective maximum positions based on viewport size
        // This ensures we can see the bottom of the map
        const viewportWidth = this.width / this.zoom;
        const viewportHeight = this.height / this.zoom;
        
        // Calculate effective boundaries
        // For the max boundaries, we need to subtract the viewport size to ensure
        // we can pan all the way to the bottom/right edges
        const effectiveMinX = this.minX;
        const effectiveMinY = this.minY;
        const effectiveMaxX = Math.max(0, this.maxX - viewportWidth);
        const effectiveMaxY = Math.max(0, this.maxY - viewportHeight);
        
        // Clamp camera position to stay within map boundaries
        this.x = Math.max(effectiveMinX, Math.min(this.x, effectiveMaxX));
        this.y = Math.max(effectiveMinY, Math.min(this.y, effectiveMaxY));
        
        console.log(`Camera position clamped to (${this.x}, ${this.y})`);
    }

    /**
     * Convert world coordinates to screen coordinates
     */
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }

    /**
     * Convert screen coordinates to world coordinates
     */
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX / this.zoom) + this.x,
            y: (screenY / this.zoom) + this.y
        };
    }

    /**
     * Check if a world position is visible on screen
     */
    isVisible(worldX, worldY, width, height) {
        // For units, convert Cartesian coordinates to isometric before checking visibility
        const isoX = (worldX - worldY) / 2;
        const isoY = (worldX + worldY) / 4;
        
        // Use a larger bounding box for visibility check to account for isometric conversion
        const boundingWidth = Math.max(width, height) * 2;
        const boundingHeight = Math.max(width, height) * 2;
        
        return (
            isoX + boundingWidth > this.x &&
            isoX - boundingWidth < this.x + (this.width / this.zoom) &&
            isoY + boundingHeight > this.y &&
            isoY - boundingHeight < this.y + (this.height / this.zoom)
        );
    }

    /**
     * Update camera dimensions when window is resized or map dimensions change
     */
    updateDimensions() {
        // Update viewport dimensions
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Update boundaries based on current map dimensions
        this.updateBoundaries();
        
        // Ensure camera position is still valid
        this.clampPosition();
        
        console.log(`Camera dimensions updated: width=${this.width}, height=${this.height}, map=${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
    }

    /**
     * Zoom at a specific point (mouse position)
     * @param {number} deltaZoom - Amount to change zoom by
     * @param {number} clientX - Mouse X position in screen coordinates
     * @param {number} clientY - Mouse Y position in screen coordinates
     */
    zoomAt(deltaZoom, clientX, clientY) {
        // Store the world point that we're zooming at
        const worldPoint = this.screenToWorld(clientX, clientY);
        const worldX = worldPoint.x;
        const worldY = worldPoint.y;
        
        // Store the old zoom value
        const oldZoom = this.zoom;
        
        // Update zoom level with constraints
        this.zoom += deltaZoom;
        this.zoom = Math.max(Config.ZOOM_MIN, Math.min(Config.ZOOM_MAX, this.zoom));
        
        // If zoom didn't actually change, exit early
        if (this.zoom === oldZoom) return;
        
        // Calculate new camera position to keep the mouse point fixed in world space
        const mouseXRatio = clientX / this.width;
        const mouseYRatio = clientY / this.height;
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set the new camera position
        this.x = worldX - (mouseXRatio * viewportWorldWidth);
        this.y = worldY - (mouseYRatio * viewportWorldHeight);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Zoomed to ${this.zoom.toFixed(2)} at world point (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
    }

    /**
     * Center the camera on player units
     * @param {Array} entities - All game entities
     * @param {string} playerId - The current player's ID
     */
    centerOnPlayerUnits(entities, playerId) {
        if (!entities || entities.length === 0) {
            console.log("No entities to center on, centering on map instead");
            this.centerOnMap();
            return;
        }
        
        // Find player-controlled units
        const playerUnits = entities.filter(entity => 
            entity.playerId === playerId && 
            entity.type === 'UNIT'
        );
        
        // If no player units found, try to find player base
        if (playerUnits.length === 0) {
            const playerBase = entities.find(entity => 
                entity.playerId === playerId && 
                entity.type === 'BUILDING' && 
                entity.buildingType === 'BASE'
            );
            
            if (playerBase) {
                console.log(`Centering camera on player base at (${playerBase.x}, ${playerBase.y})`);
                this.centerOn(playerBase.x + playerBase.width/2, playerBase.y + playerBase.height/2);
                
                // Zoom in a bit to focus on the base
                this.zoom = Config.ZOOM_DEFAULT * 1.2;
                this.clampPosition();
                return;
            }
        } else {
            // Calculate average position of all player units
            let avgX = 0;
            let avgY = 0;
            
            playerUnits.forEach(unit => {
                avgX += unit.x;
                avgY += unit.y;
            });
            
            avgX /= playerUnits.length;
            avgY /= playerUnits.length;
            
            console.log(`Centering camera on ${playerUnits.length} player units at (${avgX}, ${avgY})`);
            this.centerOn(avgX, avgY);
            
            // Zoom in a bit to focus on the units
            this.zoom = Config.ZOOM_DEFAULT * 1.2;
            this.clampPosition();
            return;
        }
        
        // Fallback to centering on map if no player entities found
        console.log("No player entities found, centering on map instead");
        this.centerOnMap();
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Config.js 
======================================== 
 
/**
 * Game configuration constants
 */
class Config {
    // Canvas and rendering
    static CANVAS_WIDTH = window.innerWidth;
    static CANVAS_HEIGHT = window.innerHeight;
    
    // Map settings
    static MAP_WIDTH = 100; // Number of tiles horizontally
    static MAP_HEIGHT = 100; // Number of tiles vertically
    static TILE_SIZE = 64; // Size of each tile in pixels - increased for better isometric rendering
    
    // Camera settings
    static CAMERA_SPEED = 10; // Camera movement speed
    static CAMERA_EDGE_THRESHOLD = 50; // Pixels from edge to trigger camera movement
    static ZOOM_MIN = 0.5; // Minimum zoom level (50%)
    static ZOOM_MAX = 2.0; // Maximum zoom level (200%)
    static ZOOM_SPEED = 0.1; // How much to zoom per mouse wheel tick
    static ZOOM_DEFAULT = 0.7; // Default zoom level (70%) - reduced to show more of the map
    
    // Unit settings
    static UNIT_SPEED = 2; // Movement speed of units
    static UNIT_SIZE = 32; // Size of units in pixels
    static UNIT_ATTRIBUTES = {
        SOLDIER: {
            health: 100,
            attackDamage: 10,
            attackRange: 50,
            attackCooldown: 1000,
            speed: 2
        }
    };
    
    // Building settings
    static BUILDING_ATTRIBUTES = {
        BASE: {
            health: 1000,
            productionRate: 0.1, // Units per second
            productionType: 'SOLDIER'
        },
        BARRACKS: {
            health: 500,
            productionRate: 0.2,
            productionType: 'SOLDIER'
        }
    };
    
    // Player settings
    static PLAYER_COLORS = [
        'red',
        'blue',
        'green',
        'yellow'
    ];
    
    // Colors
    static COLORS = {
        GRASS: '#3a8c3a',
        WATER: '#4286f4',
        SAND: '#e6d56e',
        MOUNTAIN: '#7a7a7a',
        FOREST: '#1f5e1f',
        PLAYER_UNIT: '#0000ff',
        ENEMY_UNIT: '#ff0000',
        SELECTION: '#ffffff',
        GRID: 'rgba(0, 0, 0, 0.2)'
    };
    
    // Debug settings
    static DEBUG_MODE = true; // Enable/disable debug information
    static SHOW_GRID = true; // Show grid lines
    
    // Update the canvas dimensions when the window is resized
    static updateDimensions() {
        this.CANVAS_WIDTH = window.innerWidth;
        this.CANVAS_HEIGHT = window.innerHeight;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Game.js 
======================================== 
 
/**
 * Main game class that coordinates all game components
 */
class Game {
    /**
     * Initialize the game
     */
    constructor() {
        // Get canvas and context
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Set canvas dimensions
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        
        // Initialize game components
        this.camera = new Camera();
        this.map = new Map();
        this.renderer = new Renderer(this);
        this.inputHandler = new InputHandler(this);
        this.multiplayer = new Multiplayer(this);
        
        // Game state
        this.entities = [];
        this.selectedEntities = [];
        this.running = false;
        this.lastFrameTime = 0;
        this.fps = 0;
        
        // Multiplayer state
        this.playerId = null;
    }
    
    /**
     * Start the game
     */
    start() {
        this.multiplayer.connect();

        const checkResourcesLoaded = () => {
            if (this.renderer.imagesLoaded && this.map.tiles.length > 0) {
                console.log("All resources loaded, starting game loop");
                this.running = true;
                requestAnimationFrame(this.gameLoop.bind(this));
            } else {
                console.log("Waiting for resources...");
                setTimeout(checkResourcesLoaded, 100);
            }
        };

        checkResourcesLoaded();
    }
    
    /**
     * Main game loop
     */
    gameLoop(timestamp) {
        // Calculate delta time and FPS
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;
        this.fps = 1000 / deltaTime;
        
        // Update game state
        this.update(deltaTime);
        
        // Render the game
        this.renderer.render();
        
        // Continue the game loop
        if (this.running) {
            requestAnimationFrame(this.gameLoop.bind(this));
        }
    }
    
    /**
     * Update game state
     */
    update(deltaTime) {
        // Update input handler
        this.inputHandler.update();
        
        // Update multiplayer
        this.multiplayer.update(deltaTime);
        
        // Update entity positions with interpolation
        this.updateEntities(deltaTime);
        
        // Update all entities
        for (const entity of this.entities) {
            entity.update(deltaTime, this);
        }
    }
    
    /**
     * Interpolate entity positions smoothly between server updates
     */
    updateEntities(deltaTime) {
        const interpolationFactor = 0.1; // adjust for smoothness
        
        for (const entity of this.entities) {
            // Only apply interpolation to units, not buildings
            if (entity instanceof Unit && entity.serverX !== undefined && entity.serverY !== undefined) {
                // Smoothly interpolate between current position and server position
                entity.x += (entity.serverX - entity.x) * interpolationFactor;
                entity.y += (entity.serverY - entity.y) * interpolationFactor;
            }
        }
    }
    
    /**
     * Process entities received from the server
     */
    processServerEntities(serverEntities) {
        if (!serverEntities) return;
        
        console.log('Processing server entities:', Object.keys(serverEntities).length);
        console.log('Entity types:', Object.values(serverEntities).map(e => e.type).join(', '));
        
        // Clear existing entities if this is a full update
        if (this.entities.length === 0) {
            this.entities = [];
        }
        
        // Process each entity from the server
        Object.values(serverEntities).forEach(serverEntity => {
            console.log(`Processing entity: ${serverEntity.id}, type: ${serverEntity.type}, position: (${serverEntity.x}, ${serverEntity.y})`);
            
            // Check if this entity already exists
            let entity = this.entities.find(e => e.id === serverEntity.id);
            
            if (!entity) {
                // Create a new entity based on its type
                if (serverEntity.type === 'unit') {
                    entity = new Unit(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.multiplayer.playerId,
                        serverEntity.unitType,
                        serverEntity.playerColor
                    );
                    
                    // Explicitly initialize interpolation properties
                    entity.prevX = serverEntity.x;
                    entity.prevY = serverEntity.y;
                    entity.serverX = serverEntity.x;
                    entity.serverY = serverEntity.y;
                    entity.interpolationStartTime = Date.now();
                    
                } else if (serverEntity.type === 'building') {
                    console.log(`Creating building: ${serverEntity.buildingType} at (${serverEntity.x}, ${serverEntity.y}) with color ${serverEntity.playerColor}`);
                    entity = new Building(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.multiplayer.playerId,
                        serverEntity.buildingType,
                        serverEntity.playerColor
                    );
                }
                
                if (entity) {
                    // Set additional properties
                    entity.id = serverEntity.id;
                    entity.playerId = serverEntity.playerId;
                    entity.health = serverEntity.health;
                    entity.maxHealth = serverEntity.maxHealth;
                    
                    // Add to entities array
                    this.entities.push(entity);
                    console.log(`Added new ${serverEntity.type} from server:`, entity);
                }
            } else {
                // Update existing entity
                if (serverEntity.type === 'unit') {
                    // For units, store server position for interpolation
                    entity.prevX = entity.x;
                    entity.prevY = entity.y;
                    entity.serverX = serverEntity.x;
                    entity.serverY = serverEntity.y;
                    entity.interpolationStartTime = Date.now();
                    entity.targetX = serverEntity.targetX;
                    entity.targetY = serverEntity.targetY;
                    entity.isMoving = serverEntity.isMoving;
                } else {
                    // For non-moving entities like buildings, update position directly
                    entity.x = serverEntity.x;
                    entity.y = serverEntity.y;
                }
                
                // Update health for all entities
                entity.health = serverEntity.health;
                entity.maxHealth = serverEntity.maxHealth;
                
                // Make sure isPlayerControlled is set correctly
                entity.isPlayerControlled = serverEntity.playerId === this.multiplayer.playerId;
            }
        });
        
        console.log(`Total entities after processing: ${this.entities.length}`);
    }
    
    /**
     * Handle entity selection
     */
    handleEntitySelection(worldX, worldY) {
        console.log(`Handling selection at world coordinates (${worldX}, ${worldY})`);

        const gridPos = this.map.isoToGrid(worldX, worldY);
        const gridX = gridPos.x;
        const gridY = gridPos.y;
        
        console.log(`Converted to grid coordinates (${gridX}, ${gridY})`);

        let entitySelected = false;

        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];

        // Check if any entity was clicked
        for (const entity of this.entities) {
            const entityGridX = Math.floor(entity.x / Config.TILE_SIZE);
            const entityGridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            console.log(`Checking entity ${entity.id} at grid (${entityGridX}, ${entityGridY}), isPlayerControlled: ${entity.isPlayerControlled}, playerId: ${entity.playerId}`);

            if (gridX === entityGridX && gridY === entityGridY) {
                console.log(`Entity ${entity.id} is at the clicked grid position`);
                
                // Only select entities that belong to the player and are player-controlled
                if (entity.playerId !== this.multiplayer.playerId || !entity.isPlayerControlled) {
                    console.log(`Entity ${entity.id} belongs to player ${entity.playerId} or is not player-controlled, not selecting`);
                    continue;
                }
                
                // Select this entity
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitySelected = true;
                
                // Log selection for debugging
                console.log(`Selected entity: ${entity.constructor.name}, ID: ${entity.id}, Player: ${entity.playerId}`);
                break; // Only select one entity for now
            }
        }
        
        // If no entity was selected, this might be a map click
        if (!entitySelected) {
            console.log(`No entity selected at grid (${gridX}, ${gridY})`);
        }
    }
    
    /**
     * Select entities within a box
     */
    selectEntitiesInBox(startX, startY, endX, endY) {
        console.log(`Selecting entities in box from world (${startX.toFixed(2)}, ${startY.toFixed(2)}) to (${endX.toFixed(2)}, ${endY.toFixed(2)})`);
        
        // Convert isometric world coordinates to grid coordinates
        const startGridPos = this.map.isoToGrid(startX, startY);
        const endGridPos = this.map.isoToGrid(endX, endY);
        
        console.log(`Selection box in grid coordinates: from (${startGridPos.x.toFixed(2)}, ${startGridPos.y.toFixed(2)}) to (${endGridPos.x.toFixed(2)}, ${endGridPos.y.toFixed(2)})`);
        
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle in grid coordinates
        const selectionRect = {
            x: Math.min(startGridPos.x, endGridPos.x),
            y: Math.min(startGridPos.y, endGridPos.y),
            width: Math.abs(endGridPos.x - startGridPos.x),
            height: Math.abs(endGridPos.y - startGridPos.y)
        };
        
        console.log(`Selection rectangle in grid: (${selectionRect.x.toFixed(2)}, ${selectionRect.y.toFixed(2)}) with size ${selectionRect.width.toFixed(2)}x${selectionRect.height.toFixed(2)}`);
        
        // Select entities found within the selection rectangle
        let entitiesSelected = 0;
        for (const entity of this.entities) {
            // Convert entity position to grid coordinates
            const entityGridX = Math.floor(entity.x / Config.TILE_SIZE);
            const entityGridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            console.log(`Checking entity ${entity.id} at grid (${entityGridX}, ${entityGridY}), isPlayerControlled: ${entity.isPlayerControlled}, playerId: ${entity.playerId}`);
            
            if (
                entityGridX >= selectionRect.x &&
                entityGridX <= selectionRect.x + selectionRect.width &&
                entityGridY >= selectionRect.y &&
                entityGridY <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    console.log(`Entity ${entity.id} belongs to player ${entity.playerId}, not selecting`);
                    continue;
                }
                
                // Select this entity
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitiesSelected++;
                
                // For debugging
                console.log(`Selected entity in box: ${entity.constructor.name}, ID: ${entity.id}`);
            } else {
                console.log(`Entity ${entity.id} not in selection box or not player-controlled`);
            }
        }
        
        console.log(`Selected ${entitiesSelected} entities in box selection`);
    }
    
    /**
     * Deselect all entities
     */
    deselectAll() {
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
    }
    
    /**
     * Handle area selection
     */
    handleAreaSelection(startPos, endPos) {
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle
        const selectionRect = {
            x: Math.min(startPos.x, endPos.x),
            y: Math.min(startPos.y, endPos.y),
            width: Math.abs(endPos.x - startPos.x),
            height: Math.abs(endPos.y - startPos.y)
        };
        
        // Select all entities within the selection rectangle
        let entitiesSelected = 0;
        for (const entity of this.entities) {
            if (
                entity.x + entity.width >= selectionRect.x &&
                entity.x <= selectionRect.x + selectionRect.width &&
                entity.y + entity.height >= selectionRect.y &&
                entity.y <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    continue;
                }
                
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitiesSelected++;
                
                // For debugging
                console.log(`Selected entity in area: ${entity.constructor.name}, ID: ${entity.id}`);
            }
        }
        
        console.log(`Selected ${entitiesSelected} entities in area selection`);
    }
    
    /**
     * Handle command (right-click)
     */
    handleCommand(worldX, worldY) {
        if (this.selectedEntities.length === 0) return;

        console.log(`Command at isometric world coordinates: (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
        
        // Correctly convert from isometric world coordinates to grid coordinates
        const gridPos = this.map.isoToGrid(worldX, worldY);
        const tileX = Math.floor(gridPos.x);
        const tileY = Math.floor(gridPos.y);
        
        console.log(`Converted to grid coordinates: (${tileX}, ${tileY})`);
        
        // Convert grid coordinates to cartesian coordinates for server
        const cartesianX = tileX * Config.TILE_SIZE;
        const cartesianY = tileY * Config.TILE_SIZE;
        
        console.log(`Units moving to cartesian coordinates: (${cartesianX}, ${cartesianY})`);

        // Get IDs of selected units for multiplayer
        const selectedUnitIds = this.selectedEntities
            .filter(entity => entity instanceof Unit)
            .map(entity => entity.id);
        
        if (selectedUnitIds.length > 0) {
            // Send movement command to server with cartesian coordinates
            this.multiplayer.moveUnits(selectedUnitIds, cartesianX, cartesianY);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        this.renderer.handleResize();
    }
    
    /**
     * Create a test player unit
     */
    createTestUnit() {
        // In multiplayer mode, units are created by the server
        if (this.multiplayer && this.multiplayer.connected) {
            // Find the player's base
            const playerBase = this.entities.find(entity => 
                entity.buildingType === 'BASE' && 
                entity.playerId === this.playerId
            );
            
            if (playerBase) {
                // Create unit near the player's base
                const spawnX = playerBase.x + playerBase.width + 10;
                const spawnY = playerBase.y + playerBase.height / 2;
                
                console.log(`Creating unit near player base at (${spawnX}, ${spawnY})`);
                this.multiplayer.createUnit(spawnX, spawnY, true, 'SOLDIER');
            } else {
                // Fallback to center of map if no base found
                const centerX = Config.MAP_WIDTH * Config.TILE_SIZE / 2;
                const centerY = Config.MAP_HEIGHT * Config.TILE_SIZE / 2;
                
                console.log(`No player base found, creating unit at center (${centerX}, ${centerY})`);
                this.multiplayer.createUnit(centerX, centerY, true, 'SOLDIER');
            }
            return;
        }
        
        // For single player testing only
        const unit = new Unit(
            Config.MAP_WIDTH * Config.TILE_SIZE / 2,
            Config.MAP_HEIGHT * Config.TILE_SIZE / 2,
            Config.UNIT_SIZE,
            Config.UNIT_SIZE,
            true,
            'SOLDIER',
            'red'
        );
        this.entities.push(unit);
    }
    
    /**
     * Create a unit at the specified position
     */
    createUnitAt(x, y) {
        if (this.multiplayer && this.multiplayer.connected) {
            this.multiplayer.createUnit(x, y, true, 'SOLDIER');
        } else {
            const unit = new Unit(
                x,
                y,
                Config.UNIT_SIZE,
                Config.UNIT_SIZE,
                true,
                'SOLDIER',
                'blue'
            );
            this.entities.push(unit);
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\InputHandler.js 
======================================== 
 
/**
 * Handles user input (keyboard, mouse) for game interaction
 */
class InputHandler {
    /**
     * Initialize input handler and set up event listeners
     */
    constructor(game) {
        this.game = game;
        this.camera = game.camera;
        this.canvas = game.canvas;
        
        this.keys = {}; // Track pressed keys
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseDown = false;
        this.rightMouseDown = false;
        this.middleMouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.selectionStartX = 0;
        this.selectionStartY = 0;
        this.selectionEndX = 0;
        this.selectionEndY = 0;
        this.isSelecting = false;
        
        // Minimap element
        this.minimapElement = document.getElementById('minimap');
        
        // Bind event handlers
        this.setupEventListeners();
    }
    
    /**
     * Set up all event listeners
     */
    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        window.addEventListener('keyup', this.handleKeyUp.bind(this));
        
        // Mouse events
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
        this.canvas.addEventListener('wheel', this.handleMouseWheel.bind(this));
        
        // Prevent context menu from appearing on right-click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Minimap events
        this.minimapElement.addEventListener('mousedown', this.handleMinimapClick.bind(this));
        this.minimapElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Window resize event
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Handle key down events
     */
    handleKeyDown(e) {
        this.keys[e.key] = true;
        
        // Handle specific key presses
        switch (e.key) {
            case 'Escape':
                // Deselect all units
                this.game.deselectAll();
                break;
            case 'c':
                // Center the camera on the map
                this.camera.centerOnMap();
                break;
        }
        
        // Handle camera movement with arrow keys
        this.updateCameraFromKeys();
    }
    
    /**
     * Handle key up events
     */
    handleKeyUp(e) {
        this.keys[e.code] = false;
    }
    
    /**
     * Handle mouse down events
     */
    handleMouseDown(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = true;
            this.selectionStartX = e.clientX;
            this.selectionStartY = e.clientY;
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
            this.isSelecting = true;
            
            // Check if clicked on an entity
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            console.log(`Mouse down at screen (${e.clientX}, ${e.clientY}), world (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`);
            this.game.handleEntitySelection(worldPos.x, worldPos.y);
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = true;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = true;
            e.preventDefault(); // Prevent default middle-click behavior
        }
    }
    
    /**
     * Handle mouse up events
     */
    handleMouseUp(e) {
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = false;
            
            if (this.isSelecting) {
                // Finalize selection box
                const startWorld = this.camera.screenToWorld(this.selectionStartX, this.selectionStartY);
                const endWorld = this.camera.screenToWorld(this.selectionEndX, this.selectionEndY);
                console.log(`Selection box from (${startWorld.x.toFixed(2)}, ${startWorld.y.toFixed(2)}) to (${endWorld.x.toFixed(2)}, ${endWorld.y.toFixed(2)})`);
                this.game.selectEntitiesInBox(startWorld.x, startWorld.y, endWorld.x, endWorld.y);
                this.isSelecting = false;
            }
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = false;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = false;
        }
    }
    
    /**
     * Handle mouse movement
     */
    handleMouseMove(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        
        // Update selection box if selecting
        if (this.isSelecting) {
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
        }
        
        // Handle middle mouse panning
        if (this.middleMouseDown) {
            const deltaX = this.lastMouseX - e.clientX;
            const deltaY = this.lastMouseY - e.clientY;
            
            // Move camera based on mouse movement
            this.camera.move(deltaX / this.camera.zoom, deltaY / this.camera.zoom);
        }
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Handle camera movement when mouse is near screen edges
        this.updateCameraFromMouse();
    }
    
    /**
     * Handle mouse wheel events for zooming
     */
    handleMouseWheel(e) {
        e.preventDefault();
        
        // Determine zoom direction
        const deltaZoom = e.deltaY < 0 ? Config.ZOOM_SPEED : -Config.ZOOM_SPEED;
        
        // Zoom at the mouse position
        this.camera.zoomAt(deltaZoom, e.clientX, e.clientY);
    }
    
    /**
     * Handle right click events
     */
    handleRightClick(e) {
        e.preventDefault(); // Prevent context menu
        
        // If we have selected entities, issue a command
        if (this.game.selectedEntities.length > 0) {
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            this.game.handleCommand(worldPos.x, worldPos.y);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        Config.updateDimensions();
        this.camera.updateDimensions();
        this.game.handleResize();
    }
    
    /**
     * Update camera position based on keyboard input
     */
    updateCameraFromKeys() {
        let dx = 0;
        let dy = 0;
        
        if (this.keys['ArrowUp'] || this.keys['w']) dy -= Config.CAMERA_SPEED;
        if (this.keys['ArrowDown'] || this.keys['s']) dy += Config.CAMERA_SPEED;
        if (this.keys['ArrowLeft'] || this.keys['a']) dx -= Config.CAMERA_SPEED;
        if (this.keys['ArrowRight'] || this.keys['d']) dx += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update camera position when mouse is near screen edges
     */
    updateCameraFromMouse() {
        let dx = 0;
        let dy = 0;
        const threshold = Config.CAMERA_EDGE_THRESHOLD;
        
        // Move camera if mouse is near the edges
        if (this.mouseX < threshold) dx -= Config.CAMERA_SPEED;
        if (this.mouseX > Config.CANVAS_WIDTH - threshold) dx += Config.CAMERA_SPEED;
        if (this.mouseY < threshold) dy -= Config.CAMERA_SPEED;
        if (this.mouseY > Config.CANVAS_HEIGHT - threshold) dy += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {
        this.updateCameraFromKeys();
        this.updateCameraFromMouse();
    }
    
    /**
     * Get the current selection box in screen coordinates
     */
    getSelectionBox() {
        if (!this.isSelecting) return null;
        
        return {
            x: Math.min(this.selectionStartX, this.selectionEndX),
            y: Math.min(this.selectionStartY, this.selectionEndY),
            width: Math.abs(this.selectionEndX - this.selectionStartX),
            height: Math.abs(this.selectionEndY - this.selectionStartY)
        };
    }
    
    /**
     * Handle minimap clicks
     */
    handleMinimapClick(e) {
        e.stopPropagation(); // Prevent event from bubbling to canvas
        
        // Get minimap dimensions
        const minimapRect = this.minimapElement.getBoundingClientRect();
        
        // Calculate relative position within minimap (0-1)
        const relativeX = (e.clientX - minimapRect.left) / minimapRect.width;
        const relativeY = (e.clientY - minimapRect.top) / minimapRect.height;
        
        // For isometric view, we need to convert differently
        // First, adjust for the minimap's isometric representation
        const adjustedX = (relativeX - 0.5) * 2; // Convert from 0-1 to -1 to 1 (centered)
        const adjustedY = (relativeY - 0.25) * 4; // Adjust for the 1/4 offset in the minimap
        
        // Convert to grid coordinates
        const gridX = Math.floor((adjustedX + adjustedY) / 2 * Config.MAP_WIDTH);
        const gridY = Math.floor((adjustedY - adjustedX) / 2 * Config.MAP_HEIGHT);
        
        // Clamp to valid grid coordinates
        const clampedGridX = Math.max(0, Math.min(gridX, Config.MAP_WIDTH - 1));
        const clampedGridY = Math.max(0, Math.min(gridY, Config.MAP_HEIGHT - 1));
        
        // Convert to isometric world coordinates
        const isoPos = this.game.map.gridToIso(clampedGridX, clampedGridY);
        
        console.log(`Minimap click: screen(${relativeX.toFixed(2)}, ${relativeY.toFixed(2)}) -> grid(${clampedGridX}, ${clampedGridY}) -> iso(${isoPos.x.toFixed(2)}, ${isoPos.y.toFixed(2)})`);
        
        // Left click - move camera to this position
        if (e.button === 0) {
            // Center camera on clicked position
            this.camera.centerOn(isoPos.x, isoPos.y);
        }
        // Right click - move selected units to this position
        else if (e.button === 2) {
            if (this.game.selectedEntities.length > 0) {
                this.game.handleCommand(isoPos.x, isoPos.y);
            }
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Multiplayer.js 
======================================== 
 
/**
 * Multiplayer class for handling client-side networking
 */
class Multiplayer {
    /**
     * Initialize the multiplayer system
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        this.socket = null;
        this.playerId = null;
        this.connected = false;
        this.serverEntities = {}; // Entities from the server
        this.pendingCommands = []; // Commands waiting to be sent
        this.lastServerUpdate = 0;
        this.serverStartTime = null; // Store server start time
        
        // Bind methods
        this.onConnect = this.onConnect.bind(this);
        this.onDisconnect = this.onDisconnect.bind(this);
        this.onGameState = this.onGameState.bind(this);
        this.onGameUpdate = this.onGameUpdate.bind(this);
        this.onPlayerJoined = this.onPlayerJoined.bind(this);
        this.onPlayerLeft = this.onPlayerLeft.bind(this);
        this.onUnitCreated = this.onUnitCreated.bind(this);
        this.onUnitsMoved = this.onUnitsMoved.bind(this);
        this.onEntityRemoved = this.onEntityRemoved.bind(this);
        this.onMapResized = this.onMapResized.bind(this);
        this.onJoinGameSuccess = this.onJoinGameSuccess.bind(this);
        this.onJoinGameError = this.onJoinGameError.bind(this);
    }
    
    /**
     * Connect to the game server
     */
    connect() {
        // Connect to the server on the same host and port
        // Since we're serving the client from the same server
        const serverUrl = window.location.origin;
        
        console.log(`Connecting to game server at ${serverUrl}`);
        
        // Create socket connection
        this.socket = io(serverUrl);
        
        // Set up event handlers
        this.socket.on('connect', this.onConnect);
        this.socket.on('disconnect', this.onDisconnect);
        this.socket.on('gameState', this.onGameState);
        this.socket.on('gameUpdate', this.onGameUpdate);
        this.socket.on('playerJoined', this.onPlayerJoined);
        this.socket.on('playerLeft', this.onPlayerLeft);
        this.socket.on('unitCreated', this.onUnitCreated);
        this.socket.on('unitsMoved', this.onUnitsMoved);
        this.socket.on('entityRemoved', this.onEntityRemoved);
        this.socket.on('mapResized', this.onMapResized);
        this.socket.on('joinGameSuccess', this.onJoinGameSuccess);
        this.socket.on('joinGameError', this.onJoinGameError);
    }
    
    /**
     * Disconnect from the game server
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.connected = false;
    }
    
    /**
     * Handle connection to the server
     */
    onConnect() {
        console.log('Connected to game server');
        this.connected = true;
        
        // Process any pending commands
        this.processPendingCommands();
    }
    
    /**
     * Handle disconnection from the server
     */
    onDisconnect() {
        console.log('Disconnected from game server');
        this.connected = false;
    }
    
    /**
     * Handle initial game state from server
     */
    onGameState(data) {
        console.log('Received initial game state from server');
        this.playerId = data.playerId;
        this.game.playerId = data.playerId;
        
        // Store server start time
        if (data.gameState && data.gameState.serverStartTime) {
            console.log('Setting server start time:', new Date(data.gameState.serverStartTime));
            this.serverStartTime = data.gameState.serverStartTime;
        }
        
        // Update map dimensions from server data
        if (data.gameState && data.gameState.mapDimensions) {
            console.log('Setting map dimensions from server data:', data.gameState.mapDimensions);
            this.updateMapDimensions(data.gameState.mapDimensions);
        }
        
        // Set the map from server data
        if (data.gameState && data.gameState.map) {
            console.log('Setting map from server data');
            this.game.map.setMapFromServer(data.gameState.map);
        } else {
            console.error('No map data received from server');
        }
        
        // Clear existing entities before processing new ones
        this.game.entities = [];
        
        // Process entities from server data (should only be buildings at this point)
        if (data.gameState && data.gameState.entities) {
            console.log('Processing initial entities from server data (buildings only)');
            this.game.processServerEntities(data.gameState.entities);
        }

        // Show the join button
        this.showJoinButton();
    }
    
    /**
     * Show the join button in the UI
     */
    showJoinButton() {
        // Create join button container if it doesn't exist
        let joinContainer = document.getElementById('joinContainer');
        if (!joinContainer) {
            joinContainer = document.createElement('div');
            joinContainer.id = 'joinContainer';
            joinContainer.style.position = 'absolute';
            joinContainer.style.top = '50%';
            joinContainer.style.left = '50%';
            joinContainer.style.transform = 'translate(-50%, -50%)';
            joinContainer.style.textAlign = 'center';
            joinContainer.style.zIndex = '1000';
            document.body.appendChild(joinContainer);
        }

        // Create join button if it doesn't exist
        let joinButton = document.getElementById('joinButton');
        if (!joinButton) {
            joinButton = document.createElement('button');
            joinButton.id = 'joinButton';
            joinButton.textContent = 'Join Game';
            joinButton.style.padding = '15px 30px';
            joinButton.style.fontSize = '18px';
            joinButton.style.cursor = 'pointer';
            joinButton.style.backgroundColor = '#4CAF50';
            joinButton.style.color = 'white';
            joinButton.style.border = 'none';
            joinButton.style.borderRadius = '5px';
            joinButton.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            
            // Add hover effect
            joinButton.onmouseover = () => {
                joinButton.style.backgroundColor = '#45a049';
            };
            joinButton.onmouseout = () => {
                joinButton.style.backgroundColor = '#4CAF50';
            };

            // Add click handler
            joinButton.onclick = () => {
                this.requestJoinGame();
                joinContainer.remove(); // Remove the button after clicking
            };

            joinContainer.appendChild(joinButton);
        }
    }
    
    /**
     * Request to join the game and create initial unit
     */
    requestJoinGame() {
        console.log('Requesting to join game with playerId:', this.playerId);
        this.socket.emit('joinGame', { playerId: this.playerId });
    }
    
    /**
     * Handle map resize event from server
     */
    onMapResized(data) {
        console.log('Received map resize event from server:', data.mapDimensions);
        
        // Update map dimensions
        this.updateMapDimensions(data.mapDimensions);
        
        // Update the map tiles
        if (data.map) {
            this.game.map.setMapFromServer(data.map);
        }
        
        // Update entities
        if (data.entities) {
            this.game.processServerEntities(data.entities);
        }
        
        // Reset camera position to ensure it's within bounds
        this.game.camera.updateDimensions();
        this.game.camera.clampPosition();
    }
    
    /**
     * Update map dimensions based on server data
     */
    updateMapDimensions(mapDimensions) {
        if (!mapDimensions) return;
        
        // Update Config with new map dimensions
        Config.MAP_WIDTH = mapDimensions.width;
        Config.MAP_HEIGHT = mapDimensions.height;
        
        // Apply zoom factor if provided
        if (mapDimensions.zoomFactor) {
            this.game.camera.zoom = mapDimensions.zoomFactor;
        }
        
        console.log(`Updated map dimensions to ${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
        
        // Update camera boundaries
        this.game.camera.updateDimensions();
    }
    
    /**
     * Handle game update from server
     */
    onGameUpdate(data) {
        const currentTime = Date.now();
        
        // Update server start time if provided
        if (data.serverStartTime && (!this.serverStartTime || this.serverStartTime !== data.serverStartTime)) {
            this.serverStartTime = data.serverStartTime;
        }

        Object.values(data.entities).forEach(serverEntity => {
            let localEntity = this.game.entities.find(e => e.id === serverEntity.id);

            if (localEntity) {
                if (localEntity instanceof Unit) {
                    // Explicitly store previous positions for interpolation
                    localEntity.prevX = localEntity.x;
                    localEntity.prevY = localEntity.y;
                    localEntity.serverX = serverEntity.x;
                    localEntity.serverY = serverEntity.y;
                    localEntity.interpolationStartTime = currentTime;
                }
            }
        });
        
        this.game.processServerEntities(data.entities);
    }
    
    /**
     * Handle new player joining
     */
    onPlayerJoined(data) {
        console.log('Player joined:', data.player);
        // Could show a notification or update player list
    }
    
    /**
     * Handle player leaving
     */
    onPlayerLeft(data) {
        console.log('Player left:', data.playerId);
        // Could show a notification or update player list
    }
    
    /**
     * Handle new unit creation
     */
    onUnitCreated(data) {
        const unit = data.unit;
        console.log("Received new unit from server:", unit);

        // Explicitly process and add the new unit
        this.game.processServerEntities({ [unit.id]: unit });

        // If the unit belongs to this player, center camera on it immediately
        if (unit.playerId === this.playerId) {
            const tileSize = Config.TILE_SIZE;
            const gridX = unit.x / tileSize;
            const gridY = unit.y / tileSize;
            const isoX = (gridX - gridY) * (tileSize / 2);
            const isoY = (gridX + gridY) * (tileSize / 4);

            console.log(`Centering camera on player unit at (${isoX}, ${isoY})`);

            // Explicitly center camera
            this.game.camera.centerOn(isoX, isoY);
            this.game.camera.zoom = Config.ZOOM_DEFAULT * 1.5;
            this.game.camera.clampPosition();
        }

        // Explicitly request rendering to immediately display the unit
        this.game.renderer.render();
    }
    
    /**
     * Handle units being moved
     */
    onUnitsMoved(data) {
        const { unitIds, targetX, targetY } = data;
        
        unitIds.forEach(unitId => {
            const unit = this.game.entities.find(e => e.id === unitId);
            if (unit) {
                // Set the target for the unit to move to
                unit.targetX = targetX;
                unit.targetY = targetY;
                unit.isMoving = true;
            }
        });
    }
    
    /**
     * Handle entity removal
     */
    onEntityRemoved(data) {
        const entityIndex = this.game.entities.findIndex(e => e.id === data.entityId);
        if (entityIndex !== -1) {
            this.game.entities.splice(entityIndex, 1);
        }
    }
    
    /**
     * Create an entity from server data
     */
    createEntityFromServer(entityData) {
        // This method is now deprecated in favor of processServerEntities
        console.warn('createEntityFromServer is deprecated, use processServerEntities instead');
        
        if (entityData.type === 'unit') {
            const unit = new Unit(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.unitType || 'SOLDIER',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            unit.id = entityData.id;
            unit.playerId = entityData.playerId;
            
            // Set unit attributes from server data
            if (entityData.health !== undefined) unit.health = entityData.health;
            if (entityData.maxHealth !== undefined) unit.maxHealth = entityData.maxHealth;
            if (entityData.attackDamage !== undefined) unit.attackDamage = entityData.attackDamage;
            if (entityData.attackRange !== undefined) unit.attackRange = entityData.attackRange;
            if (entityData.attackCooldown !== undefined) unit.attackCooldown = entityData.attackCooldown;
            if (entityData.speed !== undefined) unit.speed = entityData.speed;
            if (entityData.level !== undefined) unit.level = entityData.level;
            if (entityData.experience !== undefined) unit.experience = entityData.experience;
            
            // Set movement properties
            if (entityData.targetX !== undefined) unit.targetX = entityData.targetX;
            if (entityData.targetY !== undefined) unit.targetY = entityData.targetY;
            if (entityData.isMoving !== undefined) unit.isMoving = entityData.isMoving;
            
            // Add to game entities
            this.game.entities.push(unit);
            return unit;
        } else if (entityData.type === 'building') {
            const building = new Building(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.buildingType || 'BASE',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            building.id = entityData.id;
            building.playerId = entityData.playerId;
            
            // Set building attributes from server data
            if (entityData.health !== undefined) building.health = entityData.health;
            if (entityData.maxHealth !== undefined) building.maxHealth = entityData.maxHealth;
            
            // Add to game entities
            this.game.entities.push(building);
            return building;
        }
        
        return null;
    }
    
    /**
     * Create a new unit
     */
    createUnit(x, y, isPlayerControlled, unitType = 'SOLDIER') {
        if (!this.connected) {
            console.error('Cannot create unit: not connected to server');
            return;
        }
        
        this.socket.emit('createUnit', {
            x,
            y,
            isPlayerControlled,
            unitType
        });
    }
    
    /**
     * Move units and send to server
     */
    moveUnits(unitIds, targetX, targetY) {
        if (!this.connected) {
            this.pendingCommands.push(() => this.moveUnits(unitIds, targetX, targetY));
            return;
        }
        
        this.socket.emit('moveUnits', {
            unitIds,
            targetX,
            targetY
        });
    }
    
    /**
     * Process any pending commands
     */
    processPendingCommands() {
        if (!this.connected) return;
        
        while (this.pendingCommands.length > 0) {
            const command = this.pendingCommands.shift();
            command();
        }
    }
    
    /**
     * Update multiplayer state
     */
    update(deltaTime) {
        const interpolationDuration = 100; // Time between server updates in ms
        const currentTime = Date.now();

        this.game.entities.forEach(entity => {
            if (entity instanceof Unit && entity.serverX !== undefined && entity.serverY !== undefined) {
                const elapsed = currentTime - entity.interpolationStartTime;
                const t = Math.min(elapsed / interpolationDuration, 1); // interpolationDuration ~100ms

                entity.x = entity.prevX + (entity.serverX - entity.prevX) * t;
                entity.y = entity.prevY + (entity.serverY - entity.prevY) * t;

                if (t >= 1) {
                    entity.prevX = entity.serverX;
                    entity.prevY = entity.serverY;
                }
            }
        });
    }
    
    /**
     * Get the elapsed time since the server started
     * @returns {string} Formatted elapsed time (HH:MM:SS)
     */
    getElapsedTime() {
        if (!this.serverStartTime) {
            return "00:00:00";
        }
        
        // Calculate elapsed time in seconds
        const elapsedMs = Date.now() - this.serverStartTime;
        const elapsedSeconds = Math.floor(elapsedMs / 1000);
        
        // Calculate hours, minutes, and seconds
        const hours = Math.floor(elapsedSeconds / 3600);
        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
        const seconds = elapsedSeconds % 60;
        
        // Format as HH:MM:SS
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    /**
     * Handle successful game join
     */
    onJoinGameSuccess(data) {
        console.log('Successfully joined game, received unit:', data.unit);
        
        // Note: We don't need to process the unit here as it will come through
        // the unitCreated event that the server broadcasts to all clients
        
        // Remove the join button
        const joinContainer = document.getElementById('joinContainer');
        if (joinContainer) {
            joinContainer.remove();
        }
    }
    
    /**
     * Handle game join error
     */
    onJoinGameError(data) {
        console.error('Failed to join game:', data.message);
        alert(`Failed to join game: ${data.message}`);
        // Show join button again
        this.showJoinButton();
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Renderer.js 
======================================== 
 
/**
 * Handles all rendering operations for the game
 */
class Renderer {
    /**
     * Initialize the renderer
     */
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        this.ctx = game.ctx;
        this.camera = game.camera;
        this.map = game.map;
        
        // Isometric tile dimensions
        this.tileWidth = Config.TILE_SIZE;
        this.tileHeight = Config.TILE_SIZE / 2;
        
        // Preload images
        this.preloadImages();
        
        // Track loaded images
        this.imagesLoaded = false;
        this.checkImagesLoaded();
    }
    
    /**
     * Check if all images are loaded
     */
    checkImagesLoaded() {
        // Check if all tile images are loaded
        const allImagesLoaded = Object.values(this.map.tileImages).every(img => img.complete);
        
        if (allImagesLoaded) {
            this.imagesLoaded = true;
            console.log('All images loaded successfully');
        } else {
            // Check again in 100ms
            setTimeout(() => this.checkImagesLoaded(), 100);
        }
    }
    
    /**
     * Preload any additional images needed for rendering
     */
    preloadImages() {
        // Preload unit and building images here if needed
        // For now, we're just using the tile images preloaded by the Map class
    }
    
    /**
     * Clear the canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    /**
     * Main render function
     */
    render() {
        this.clear();
        
        // Render map
        this.renderMap();
        
        // Render entities
        this.renderEntities();
        
        // Render UI
        this.renderUI();
    }
    
    /**
     * Convert grid coordinates to screen coordinates
     */
    gridToScreen(col, row) {
        // Convert grid coordinates to isometric world coordinates
        const isoPos = this.map.gridToIso(col, row);
        
        // Convert world coordinates to screen coordinates
        return this.camera.worldToScreen(isoPos.x, isoPos.y);
    }
    
    /**
     * Render the map tiles
     */
    renderMap() {
        // Calculate visible tile range based on camera position and zoom
        // For isometric view, we need a different approach to determine visible tiles
        
        // Convert camera position to grid coordinates
        const cameraWorldPos = {
            x: this.camera.x,
            y: this.camera.y
        };
        
        // Get the viewport dimensions in world coordinates
        const viewportWidth = this.camera.width / this.camera.zoom;
        const viewportHeight = this.camera.height / this.camera.zoom;
        
        // Calculate the viewport corners in world coordinates
        const viewportCorners = [
            { x: cameraWorldPos.x, y: cameraWorldPos.y }, // Top-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y }, // Top-right
            { x: cameraWorldPos.x, y: cameraWorldPos.y + viewportHeight }, // Bottom-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y + viewportHeight } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Find the min and max grid coordinates that cover the viewport
        let minGridX = Math.floor(Math.min(...gridCorners.map(corner => corner.x)));
        let maxGridX = Math.ceil(Math.max(...gridCorners.map(corner => corner.x)));
        let minGridY = Math.floor(Math.min(...gridCorners.map(corner => corner.y)));
        let maxGridY = Math.ceil(Math.max(...gridCorners.map(corner => corner.y)));
        
        // Add a buffer to ensure we render tiles that are partially visible
        const buffer = 15;
        minGridX = Math.max(0, minGridX - buffer);
        minGridY = Math.max(0, minGridY - buffer);
        maxGridX = Math.min(this.map.width, maxGridX + buffer);
        maxGridY = Math.min(this.map.height, maxGridY + buffer);
        
        // Render tiles in the correct order for isometric view (back to front)
        // This ensures proper overlapping of tiles
        for (let sum = minGridX + minGridY; sum <= maxGridX + maxGridY; sum++) {
            for (let gridX = minGridX; gridX <= maxGridX; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < minGridY || gridY > maxGridY) continue;
                
                // Get the tile at this grid position
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert grid coordinates to isometric world coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Convert world coordinates to screen coordinates
                const screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
                
                // Calculate tile dimensions with zoom
                const tileWidthZoomed = this.tileWidth * this.camera.zoom;
                const tileHeightZoomed = this.tileHeight * this.camera.zoom;
                
                // Draw the tile
                if (this.imagesLoaded) {
                    // Use the appropriate tile image based on terrain type
                    const terrainType = tile.terrainType || tile.type;
                    const tileImage = this.map.getTileImage(terrainType);
                    
                    if (tileImage && tileImage.complete) {
                        // Draw the isometric tile image
                        this.ctx.drawImage(
                            tileImage,
                            screenPos.x - (tileWidthZoomed / 2), // Center the image horizontally
                            screenPos.y - (tileHeightZoomed / 2), // Center the image vertically
                            tileWidthZoomed,
                            tileHeightZoomed
                        );
                    } else {
                        // Fallback to colored diamond if image not loaded
                        this.drawIsometricTile(
                            screenPos.x,
                            screenPos.y,
                            tileWidthZoomed,
                            tileHeightZoomed,
                            this.getTileColor(tile.terrainType || tile.type)
                        );
                    }
                } else {
                    // Fallback to colored diamond if images not loaded yet
                    this.drawIsometricTile(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed,
                        this.getTileColor(tile.terrainType || tile.type)
                    );
                }
                
                // Draw grid lines if enabled
                if (Config.SHOW_GRID) {
                    this.drawIsometricGrid(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed
                    );
                }
            }
        }
    }
    
    /**
     * Draw an isometric tile (diamond shape)
     */
    drawIsometricTile(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.fill();
    }
    
    /**
     * Draw isometric grid lines
     */
    drawIsometricGrid(x, y, width, height) {
        this.ctx.strokeStyle = Config.COLORS.GRID;
        this.ctx.lineWidth = 1;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.stroke();
    }
    
    /**
     * Get the color for a tile type
     */
    getTileColor(tileType) {
        switch (tileType) {
            case 'grass': return Config.COLORS.GRASS;
            case 'water': return Config.COLORS.WATER;
            case 'sand': return Config.COLORS.SAND;
            case 'mountain': return Config.COLORS.MOUNTAIN;
            case 'forest': return Config.COLORS.FOREST;
            default: return Config.COLORS.GRASS;
        }
    }
    
    /**
     * Render all game entities
     */
    renderEntities() {
        // Sort entities by their y-coordinate for proper depth ordering in isometric view
        const sortedEntities = [...this.game.entities].sort((a, b) => a.y - b.y);
        
        for (const entity of sortedEntities) {
            if (!this.camera.isVisible(entity.x, entity.y, entity.width, entity.height)) {
                continue; // Skip this entity and move to the next one
            }
            
            let screenPos;
            
            if (entity instanceof Building) {
                // For buildings, use the grid-based conversion
                // Convert entity position to grid coordinates
                const gridX = Math.floor(entity.x / Config.TILE_SIZE);
                const gridY = Math.floor(entity.y / Config.TILE_SIZE);
                
                // Convert grid coordinates to isometric world coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Convert world coordinates to screen coordinates
                screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
            } else {
                // For units, use the direct Cartesian-to-isometric conversion
                const isoX = (entity.x - entity.y) / 2;
                const isoY = (entity.x + entity.y) / 4;
                
                // Convert to screen coordinates
                screenPos = this.camera.worldToScreen(isoX, isoY);
            }
            
            // Calculate entity dimensions with zoom
            const entityWidth = entity.width * this.camera.zoom;
            const entityHeight = entity.height * this.camera.zoom;
            
            // Render the entity based on its type
            if (entity instanceof Unit) {
                this.renderUnit(entity, screenPos, entityWidth, entityHeight);
            } else if (entity instanceof Building) {
                this.renderBuilding(entity, screenPos, entityWidth, entityHeight);
            }
        }
    }
    
    /**
     * Render a unit with its image and health bar
     */
    renderUnit(unit, screenPos, width, height) {
        // Debug logging for selection
        if (unit.isSelected) {
            console.log(`Rendering selected unit: ${unit.id}, isPlayerControlled: ${unit.isPlayerControlled}, playerId: ${unit.playerId}, position: (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw unit image if available
        if (unit.image && unit.image.complete) {
            console.log(`Rendering unit image: ${unit.unitType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                unit.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            // Fallback to colored rectangle if image not loaded
            console.log(`Fallback rendering for unit: ${unit.unitType} at (${screenPos.x}, ${screenPos.y})`);
            this.ctx.fillStyle = unit.isPlayerControlled ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
                
            this.ctx.fillRect(
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        }
        
        // Draw selection indicator if unit is selected
        if (unit.isSelected) {
            console.log(`Drawing selection indicator for unit ${unit.id} at (${screenPos.x}, ${screenPos.y}) with radius ${(width / 2) + 5 * this.camera.zoom}`);
            
            // Draw a glowing selection circle around the unit
            this.ctx.strokeStyle = Config.COLORS.SELECTION || '#00ff00';
            this.ctx.lineWidth = 2 * this.camera.zoom;
            
            // Draw circle around unit
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.stroke();
            
            // Add a semi-transparent fill for better visibility
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
            
            console.log(`Selection indicator drawn with color ${Config.COLORS.SELECTION}`);
        }
        
        // Draw health bar
        const healthBarWidth = width;
        const healthBarHeight = 4 * this.camera.zoom;
        const healthPercentage = unit.health / unit.maxHealth;
        
        // Health bar background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health bar fill
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Draw level indicator if level > 1
        if (unit.level > 1) {
            this.ctx.fillStyle = 'white';
            this.ctx.font = `${10 * this.camera.zoom}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                unit.level.toString(),
                screenPos.x,
                screenPos.y + height / 2 + 12 * this.camera.zoom
            );
        }
    }
    
    /**
     * Render a building with its image and health bar
     */
    renderBuilding(building, screenPos, width, height) {
        // Always draw a solid base rectangle first
        this.ctx.fillStyle = building.playerColor === 'red' ? 
            '#ff0000' : building.playerColor === 'blue' ? 
            '#0000ff' : '#888888';
            
        // Draw an isometric building base
        this.drawIsometricBuilding(
            screenPos.x,
            screenPos.y,
            width,
            height / 2, // Half height for isometric look
            this.ctx.fillStyle
        );
        
        // Draw building image if available
        if (building.image && building.image.complete) {
            // For isometric view, we need to adjust the image position
            console.log(`Rendering building image: ${building.buildingType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                building.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            console.log(`Fallback rendering for building: ${building.buildingType} at (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw health bar
        const healthPercentage = building.health / building.maxHealth;
        const healthBarWidth = width;
        const healthBarHeight = 5 * this.camera.zoom;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Determine the label based on player color
        let baseLabel = building.buildingType;
        if (building.buildingType === 'BASE') {
            baseLabel = building.playerColor === 'blue' ? 'Human Base' : 'AI Base';
        }
        
        // Draw building type text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = `${12 * this.camera.zoom}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(
            baseLabel,
            screenPos.x,
            screenPos.y
        );
    }
    
    /**
     * Draw an isometric building
     */
    drawIsometricBuilding(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a 3D isometric building
        // Top face (roof)
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height); // Top point
        this.ctx.lineTo(x + width / 2, y - height / 2); // Right point
        this.ctx.lineTo(x, y); // Bottom point
        this.ctx.lineTo(x - width / 2, y - height / 2); // Left point
        this.ctx.closePath();
        this.ctx.fill();
        
        // Right face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-left
        this.ctx.lineTo(x + width / 2, y - height / 2); // Top-right
        this.ctx.lineTo(x + width / 2, y + height / 2); // Bottom-right
        this.ctx.lineTo(x, y + height); // Bottom-left
        this.ctx.closePath();
        // Darken the right face
        this.ctx.fillStyle = this.darkenColor(color, 0.7);
        this.ctx.fill();
        
        // Left face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-right
        this.ctx.lineTo(x - width / 2, y - height / 2); // Top-left
        this.ctx.lineTo(x - width / 2, y + height / 2); // Bottom-left
        this.ctx.lineTo(x, y + height); // Bottom-right
        this.ctx.closePath();
        // Darken the left face more
        this.ctx.fillStyle = this.darkenColor(color, 0.5);
        this.ctx.fill();
    }
    
    /**
     * Darken a color by a factor
     */
    darkenColor(color, factor) {
        // Convert hex to RGB
        let r, g, b;
        if (color.startsWith('#')) {
            const hex = color.substring(1);
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        } else if (color.startsWith('rgb')) {
            const match = color.match(/\d+/g);
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
        } else {
            return color; // Can't darken
        }
        
        // Darken
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        
        // Convert back to hex
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    /**
     * Get color for health bar based on percentage
     */
    getHealthColor(percentage) {
        if (percentage > 0.6) {
            return 'rgb(0, 255, 0)'; // Green
        } else if (percentage > 0.3) {
            return 'rgb(255, 255, 0)'; // Yellow
        } else {
            return 'rgb(255, 0, 0)'; // Red
        }
    }
    
    /**
     * Render UI elements
     */
    renderUI() {
        // Render elapsed time at the top of the screen
        this.renderElapsedTime();
        
        // Render selection box if dragging
        const selectionBox = this.game.inputHandler.getSelectionBox();
        if (selectionBox) {
            this.ctx.strokeStyle = Config.COLORS.SELECTION;
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
            
            // Semi-transparent fill
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.fillRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
        }
        
        // Render minimap
        this.renderMinimap();
        
        // Render selected unit info
        this.renderSelectedUnitInfo();
        
        // Render debug info if enabled
        if (Config.DEBUG_MODE) {
            this.renderDebugInfo();
        }
    }
    
    /**
     * Render the elapsed time since the server started
     */
    renderElapsedTime() {
        const elapsedTime = this.game.multiplayer.getElapsedTime();
        
        // Set up text style
        this.ctx.font = '16px Arial';
        this.ctx.textAlign = 'center';
        
        // Draw background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(this.canvas.width / 2 - 80, 10, 160, 30);
        
        // Draw text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillText(`Time Elapsed: ${elapsedTime}`, this.canvas.width / 2, 30);
    }
    
    /**
     * Render the minimap
     */
    renderMinimap() {
        const minimapElement = document.getElementById('minimap');
        if (!minimapElement) return;
        
        // Create a canvas for the minimap if it doesn't exist
        if (!this.minimapCanvas) {
            this.minimapCanvas = document.createElement('canvas');
            this.minimapCanvas.width = 180; // Slightly smaller than the container
            this.minimapCanvas.height = 180;
            this.minimapCtx = this.minimapCanvas.getContext('2d');
            minimapElement.appendChild(this.minimapCanvas);
        }
        
        // Clear the minimap
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // Calculate the isometric map dimensions
        const isoMapWidth = (this.map.width + this.map.height) * (Config.TILE_SIZE / 2);
        const isoMapHeight = (this.map.width + this.map.height) * (Config.TILE_SIZE / 4);
        
        // Calculate scale factors for the minimap
        const scaleX = this.minimapCanvas.width / isoMapWidth;
        const scaleY = this.minimapCanvas.height / isoMapHeight;
        
        // Use the smaller scale to maintain aspect ratio
        const scale = Math.min(scaleX, scaleY) * 0.8; // 80% to leave some margin
        
        // Calculate offsets to center the map in the minimap
        const offsetX = this.minimapCanvas.width / 2;
        const offsetY = this.minimapCanvas.height / 4;
        
        // Draw map tiles on minimap
        // Render in the correct order for isometric view (back to front)
        for (let sum = 0; sum < this.map.width + this.map.height; sum++) {
            for (let gridX = 0; gridX < this.map.width; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < 0 || gridY >= this.map.height) continue;
                
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert to isometric coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Scale and position for minimap
                const x = offsetX + isoPos.x * scale;
                const y = offsetY + isoPos.y * scale;
                
                // Draw a small diamond for each tile
                this.minimapCtx.fillStyle = this.getTileColor(tile.terrainType || tile.type);
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(x, y - 2); // Top
                this.minimapCtx.lineTo(x + 2, y); // Right
                this.minimapCtx.lineTo(x, y + 2); // Bottom
                this.minimapCtx.lineTo(x - 2, y); // Left
                this.minimapCtx.closePath();
                this.minimapCtx.fill();
            }
        }
        
        // Draw entities on minimap
        for (const entity of this.game.entities) {
            // Convert entity position to grid coordinates
            const gridX = Math.floor(entity.x / Config.TILE_SIZE);
            const gridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            // Convert to isometric coordinates
            const isoPos = this.map.gridToIso(gridX, gridY);
            
            // Scale and position for minimap
            const x = offsetX + isoPos.x * scale;
            const y = offsetY + isoPos.y * scale;
            
            // Draw a dot for each entity
            this.minimapCtx.fillStyle = entity.playerColor === 'blue' ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            
            this.minimapCtx.beginPath();
            this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
            this.minimapCtx.fill();
        }
        
        // Draw camera viewport rectangle
        // Calculate the four corners of the viewport in world coordinates
        const viewportCorners = [
            { x: this.camera.x, y: this.camera.y }, // Top-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y }, // Top-right
            { x: this.camera.x, y: this.camera.y + this.camera.height / this.camera.zoom }, // Bottom-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y + this.camera.height / this.camera.zoom } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Convert back to isometric for minimap and scale
        const minimapCorners = gridCorners.map(gridPos => {
            const isoPos = this.map.gridToIso(gridPos.x, gridPos.y);
            return {
                x: offsetX + isoPos.x * scale,
                y: offsetY + isoPos.y * scale
            };
        });
        
        // Draw viewport outline
        this.minimapCtx.strokeStyle = 'white';
        this.minimapCtx.lineWidth = 1.5;
        this.minimapCtx.beginPath();
        this.minimapCtx.moveTo(minimapCorners[0].x, minimapCorners[0].y);
        this.minimapCtx.lineTo(minimapCorners[1].x, minimapCorners[1].y);
        this.minimapCtx.lineTo(minimapCorners[3].x, minimapCorners[3].y);
        this.minimapCtx.lineTo(minimapCorners[2].x, minimapCorners[2].y);
        this.minimapCtx.closePath();
        this.minimapCtx.stroke();
    }
    
    /**
     * Render information about selected units
     */
    renderSelectedUnitInfo() {
        const selectedUnits = this.game.entities.filter(e => e.isSelected && e instanceof Unit);
        
        if (selectedUnits.length === 0) {
            return;
        }
        
        // Only show info for the first selected unit
        const unit = selectedUnits[0];
        const padding = 10;
        const lineHeight = 20;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(
            this.canvas.width - 200 - padding,
            padding,
            200,
            150
        );
        
        this.ctx.fillStyle = 'white';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'left';
        
        let y = padding + lineHeight;
        
        this.ctx.fillText(`Unit Type: ${unit.unitType}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Level: ${unit.level}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Health: ${unit.health}/${unit.maxHealth}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Attack: ${unit.attackDamage}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Range: ${unit.attackRange}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Speed: ${unit.speed}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        if (unit.level < 10) { // Max level cap
            const expNeeded = unit.level * 100;
            this.ctx.fillText(`XP: ${unit.experience}/${expNeeded}`, this.canvas.width - 190, y);
        }
    }
    
    /**
     * Render debug information
     */
    renderDebugInfo() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'left';
        
        // Display FPS
        this.ctx.fillText(`FPS: ${this.game.fps.toFixed(1)}`, 10, 20);
        
        // Display camera position
        this.ctx.fillText(`Camera: (${this.camera.x.toFixed(0)}, ${this.camera.y.toFixed(0)})`, 10, 40);
        
        // Display zoom level
        this.ctx.fillText(`Zoom: ${(this.camera.zoom * 100).toFixed(0)}%`, 10, 60);
        
        // Display entity count
        this.ctx.fillText(`Entities: ${this.game.entities.length}`, 10, 80);
        
        // Display selected entities count
        const selectedCount = this.game.entities.filter(e => e.isSelected).length;
        this.ctx.fillText(`Selected: ${selectedCount}`, 10, 100);
        
        // Display isometric rendering info
        this.ctx.fillText(`Isometric Mode: Active`, 10, 120);
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\UnitImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing unit images
 */
class UnitImageLoader {
    /**
     * Initialize the unit image loader
     */
    constructor() {
        // Unit types
        this.unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];
        
        // Store loaded images
        this.images = {};
        
        // Load all unit images
        this.loadUnitImages();
        
        console.log('UnitImageLoader initialized');
    }
    
    /**
     * Load all unit images
     */
    loadUnitImages() {
        this.unitTypes.forEach(unitType => {
            const img = new Image();
            img.src = `/images/units/${unitType.toLowerCase()}.png`;
            this.images[unitType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded unit image: ${unitType}`);
            img.onerror = () => console.warn(`Failed to load unit image: ${unitType}`);
        });
    }
    
    /**
     * Get the image for a specific unit type
     */
    getUnitImage(unitType) {
        return this.images[unitType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Map.js 
======================================== 
 
/**
 * Manages the game map
 */
class Map {
    /**
     * Initialize the map
     */
    constructor() {
        this.width = Config.MAP_WIDTH;
        this.height = Config.MAP_HEIGHT;
        this.tiles = [];
        
        // Initialize with empty tiles
        this.initializeEmptyTiles();
        
        // Preload tile images
        this.tileImages = {};
        this.preloadTileImages();
    }
    
    /**
     * Preload tile images for different terrain types
     */
    preloadTileImages() {
        const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        terrainTypes.forEach(terrainType => {
            const img = new Image();
            img.src = `/images/terraintiles/${terrainType}.png`;
            this.tileImages[terrainType] = img;
        });
    }
    
    /**
     * Initialize empty tiles
     */
    initializeEmptyTiles() {
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                // Initialize with grass tiles as a fallback
                this.tiles[y][x] = new Tile('grass');
            }
        }
        console.log('Initialized empty map');
    }
    
    /**
     * Set the map data from the server
     */
    setMapFromServer(mapData) {
        console.log('Received map data from server', mapData ? 'valid' : 'invalid');
        
        if (!mapData || !Array.isArray(mapData) || mapData.length === 0) {
            console.error('Invalid map data from server');
            return;
        }
        
        this.height = mapData.length;
        this.width = mapData[0].length;
        
        console.log(`Setting map from server data: ${this.width}x${this.height}`);
        
        // Convert server map data to our tile format
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                if (!mapData[y] || !mapData[y][x]) {
                    console.error(`Missing tile data at ${x},${y}`);
                    this.tiles[y][x] = new Tile('grass');
                    continue;
                }
                
                const serverTile = mapData[y][x];
                // Use terrainType if available, fall back to type for backward compatibility
                const terrainType = serverTile.terrainType || serverTile.type || 'grass';
                this.tiles[y][x] = new Tile(terrainType);
                
                // Use passable if available, fall back to walkable for backward compatibility
                this.tiles[y][x].walkable = serverTile.passable !== undefined ? 
                    serverTile.passable : 
                    (serverTile.walkable !== undefined ? 
                        serverTile.walkable : 
                        (terrainType !== 'water' && terrainType !== 'mountain'));
                
                // Store elevation if available
                if (serverTile.elevation !== undefined) {
                    this.tiles[y][x].elevation = serverTile.elevation;
                }
            }
        }
        
        console.log('Map set from server data');
    }
    
    /**
     * Get the tile at the specified coordinates
     */
    getTile(x, y) {
        // Check bounds
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
            return null;
        }
        
        // Check if tiles array is properly initialized
        if (!this.tiles || !this.tiles[y] || !this.tiles[y][x]) {
            console.warn(`Tile at ${x},${y} is not initialized`);
            return new Tile('grass'); // Return a default tile
        }
        
        return this.tiles[y][x];
    }
    
    /**
     * Get the tile image for a specific terrain type
     */
    getTileImage(terrainType) {
        return this.tileImages[terrainType] || this.tileImages['grass'];
    }
    
    /**
     * Convert grid coordinates to isometric world coordinates
     */
    gridToIso(x, y) {
        return {
            x: (x - y) * (Config.TILE_SIZE / 2),
            y: (x + y) * (Config.TILE_SIZE / 4)
        };
    }
    
    /**
     * Convert isometric world coordinates to grid coordinates
     */
    isoToGrid(x, y) {
        const tileHalfWidth = Config.TILE_SIZE / 2;
        const tileQuarterHeight = Config.TILE_SIZE / 4;
        
        return {
            x: Math.floor((x / tileHalfWidth + y / tileQuarterHeight) / 2),
            y: Math.floor((y / tileQuarterHeight - x / tileHalfWidth) / 2)
        };
    }
    
    /**
     * Check if a tile is walkable
     */
    isWalkable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.walkable;
    }
    
    /**
     * Check if a tile is buildable
     */
    isBuildable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.buildable;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Tile.js 
======================================== 
 
/**
 * Represents a single tile on the game map
 */
class Tile {
    /**
     * Initialize a tile
     */
    constructor(terrainType = 'grass') {
        // Ensure valid tile type
        this.type = this.validateTerrainType(terrainType);
        this.terrainType = this.type; // For consistency with server data
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
        this.resourceType = this.getResourceType(this.type);
        this.resourceAmount = this.resourceType ? Math.floor(Math.random() * 500) + 500 : 0;
        this.elevation = 0; // Default elevation
    }
    
    /**
     * Validate and normalize terrain type
     */
    validateTerrainType(type) {
        const validTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        if (!type || typeof type !== 'string') {
            console.warn(`Invalid tile type: ${type}, defaulting to grass`);
            return 'grass';
        }
        
        const normalizedType = type.toLowerCase();
        
        if (!validTypes.includes(normalizedType)) {
            console.warn(`Unknown tile type: ${normalizedType}, defaulting to grass`);
            return 'grass';
        }
        
        return normalizedType;
    }
    
    /**
     * Determine if a tile type is walkable
     */
    isWalkable(type) {
        switch (type) {
            case 'water':
            case 'mountain':
                return false;
            case 'grass':
            case 'sand':
            case 'forest':
                return true;
            default:
                return true;
        }
    }
    
    /**
     * Determine if a tile type is buildable
     */
    isBuildable(type) {
        switch (type) {
            case 'grass':
            case 'sand':
                return true;
            case 'water':
            case 'mountain':
            case 'forest':
                return false;
            default:
                return false;
        }
    }
    
    /**
     * Get resource type for a tile if applicable
     */
    getResourceType(type) {
        switch (type) {
            case 'forest':
                return 'wood';
            case 'mountain':
                return 'stone';
            default:
                return null;
        }
    }
    
    /**
     * Extract resources from the tile
     */
    extractResource(amount) {
        if (!this.resourceType || this.resourceAmount <= 0) {
            return 0;
        }
        
        const extracted = Math.min(amount, this.resourceAmount);
        this.resourceAmount -= extracted;
        
        // If resources are depleted, change the tile type
        if (this.resourceAmount <= 0) {
            this.depleteResource();
        }
        
        return extracted;
    }
    
    /**
     * Handle resource depletion
     */
    depleteResource() {
        switch (this.resourceType) {
            case 'wood':
                this.type = 'grass';
                this.terrainType = 'grass';
                break;
            case 'stone':
                this.type = 'mountain';
                this.terrainType = 'mountain';
                break;
            default:
                break;
        }
        
        this.resourceType = null;
        this.resourceAmount = 0;
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateDetailedImages.js 
======================================== 
 
/**
 * Script to generate detailed images for units and buildings
 * This creates visually appealing assets for the game
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

/**
 * Generate a detailed unit image
 */
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Generate a detailed building image
 */
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Helper function to draw an isometric building
 */
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

/**
 * Helper function to darken a color
 */
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

/**
 * Function to save an image
 */
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

/**
 * Generate and save unit images
 */
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

/**
 * Generate and save building images
 */
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating detailed images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: public/images/units/');
console.log('   - Building images: public/images/buildings/');
console.log('2. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateImages.js 
======================================== 
 
const fs = require('fs');
const path = require('path');
const { createCanvas } = require('canvas');

// Create directories if they don't exist
const unitsDir = path.join(__dirname, '../../public/images/units');
const buildingsDir = path.join(__dirname, '../../public/images/buildings');

if (!fs.existsSync(unitsDir)) {
    fs.mkdirSync(unitsDir, { recursive: true });
}

if (!fs.existsSync(buildingsDir)) {
    fs.mkdirSync(buildingsDir, { recursive: true });
}

// Create a canvas
const canvas = createCanvas(64, 64);
const ctx = canvas.getContext('2d');

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Helper function to draw an isometric building
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(canvas, filename) {
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(filename, buffer);
    console.log(`Generated: ${filename}`);
}

// Generate and save unit images
function generateUnitImages() {
    console.log('Generating unit images...');
    
    unitTypes.forEach(unitType => {
        const canvas = generateUnitImage(unitType);
        const filename = path.join(unitsDir, `${unitType.toLowerCase()}.png`);
        saveImage(canvas, filename);
    });
    
    console.log('Unit image generation complete!');
}

// Generate and save building images
function generateBuildingImages() {
    console.log('Generating building images...');
    
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const canvas = generateBuildingImage(buildingType);
        const filename = path.join(buildingsDir, `${buildingType.toLowerCase()}.png`);
        saveImage(canvas, filename);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredCanvas = generateBuildingImage(buildingType, color);
            const coloredFilename = path.join(buildingsDir, `${buildingType.toLowerCase()}_${color}.png`);
            saveImage(coloredCanvas, coloredFilename);
        });
    });
    
    console.log('Building image generation complete!');
}

// Generate all images
function generateAllImages() {
    generateUnitImages();
    generateBuildingImages();
}

// Run the generator
generateAllImages();  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generatePlaceholderImages.js 
======================================== 
 
/**
 * Script to generate placeholder images for units and buildings
 * Run this script to create basic placeholder images until proper assets are available
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set background color based on unit type
    let color;
    switch(unitType) {
        case 'SOLDIER': color = '#3366cc'; break;
        case 'ARCHER': color = '#33cc33'; break;
        case 'CAVALRY': color = '#cc3333'; break;
        case 'TANK': color = '#666666'; break;
        case 'WORKER': color = '#cc9933'; break;
        default: color = '#3366cc';
    }
    
    // Draw isometric unit shape
    ctx.fillStyle = color;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Add details based on unit type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add unit type initial
    ctx.fillText(unitType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set base color based on building type
    let baseColor;
    switch(buildingType) {
        case 'BASE': baseColor = '#666699'; break;
        case 'BARRACKS': baseColor = '#996666'; break;
        case 'TOWER': baseColor = '#669966'; break;
        case 'FARM': baseColor = '#999966'; break;
        case 'MINE': baseColor = '#666666'; break;
        default: baseColor = '#666699';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red': baseColor = '#cc3333'; break;
            case 'blue': baseColor = '#3366cc'; break;
            case 'green': baseColor = '#33cc33'; break;
            case 'yellow': baseColor = '#cccc33'; break;
        }
    }
    
    // Draw isometric building
    // Base
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Right face (darker)
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(48, 32); // Right middle
    ctx.lineTo(48, 40); // Right bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Left face (darkest)
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(16, 32); // Left middle
    ctx.lineTo(16, 40); // Left bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Add details based on building type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add building type initial
    ctx.fillText(buildingType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Generate and save unit images
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

// Generate and save building images
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating placeholder images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: assets/units/');
console.log('   - Building images: assets/buildings/');
console.log('2. Make sure the folder structure exists');
console.log('3. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\utils\helpers.js 
======================================== 
 
/**
 * Utility functions for the game
 */

/**
 * Calculate distance between two points
 */
function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation between two values
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}

/**
 * Generate a random integer between min and max (inclusive)
 */
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Check if a point is inside a rectangle
 */
function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

/**
 * Check if two rectangles overlap
 */
function rectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h) {
    return (
        r1x < r2x + r2w &&
        r1x + r1w > r2x &&
        r1y < r2y + r2h &&
        r1y + r1h > r2y
    );
}

/**
 * Convert degrees to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Convert radians to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Calculate the angle between two points (in radians)
 */
function angleBetweenPoints(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
}

/**
 * Get a point on a circle given center, radius, and angle
 */
function pointOnCircle(centerX, centerY, radius, angleRadians) {
    return {
        x: centerX + radius * Math.cos(angleRadians),
        y: centerY + radius * Math.sin(angleRadians)
    };
}

/**
 * Shuffle an array (Fisher-Yates algorithm)
 */
function shuffleArray(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Format time in seconds to MM:SS format
 */
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Ease in-out function (smooth acceleration and deceleration)
 */
function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Get a random element from an array
 */
function randomArrayElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

/**
 * Check if a value is between min and max (inclusive)
 */
function isBetween(value, min, max) {
    return value >= min && value <= max;
}

/**
 * Calculate the Manhattan distance between two points
 */
function manhattanDistance(x1, y1, x2, y2) {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1);
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\server\index.js 
======================================== 
 
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const path = require('path');
const { v4: uuidv4 } = require('uuid');

// Create Express app and HTTP server
const app = express();
const server = http.createServer(app);

// Create Socket.IO server with CORS enabled
const io = new Server(server, {
  cors: {
    origin: '*',
    methods: ['GET', 'POST']
  }
});

// Serve static files from the public directory
app.use(express.static(path.join(__dirname, '../public')));
app.use('/src', express.static(path.join(__dirname, '../src')));

// Serve the main HTML file
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, '../public/index.html'));
});

// Redirect from /public to root for backward compatibility
app.get('/public', (req, res) => {
  res.redirect('/');
});

app.get('/public/index.html', (req, res) => {
  res.redirect('/');
});

// Function to determine map size based on player count
function getMapDimensions(playerCount) {
  if (playerCount <= 5) {
    return { 
      width: 40, 
      height: 40,
      zoomFactor: 1.5 // Higher zoom factor for smaller maps
    };
  } else if (playerCount <= 15) {
    return { 
      width: 60, 
      height: 60,
      zoomFactor: 1.0 // Medium zoom factor
    };
  } else {
    return { 
      width: 80, 
      height: 80,
      zoomFactor: 0.75 // Lower zoom factor for larger maps
    };
  }
}

// Generate a random map
function generateMap(width, height) {
  console.log(`Generating map with dimensions ${width}x${height}`);
  
  const tiles = [];
  const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
  const terrainWeights = [0.65, 0.15, 0.1, 0.08, 0.02]; // Adjusted probabilities for each terrain type
  
  // Generate a seed for consistent random generation
  let seed = Math.floor(Math.random() * 1000000);
  
  // Simple random number generator with seed
  const seededRandom = () => {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
  
  // Create noise functions for terrain generation
  const createNoiseGenerator = (scale, amplitude, octaves) => {
    const offsets = Array(octaves).fill().map(() => ({
      x: seededRandom() * 1000,
      y: seededRandom() * 1000
    }));
    
    return (x, y) => {
      let value = 0;
      let totalAmplitude = 0;
      
      for (let i = 0; i < octaves; i++) {
        const currentScale = scale * Math.pow(2, i);
        const currentAmplitude = amplitude * Math.pow(0.5, i);
        
        const nx = (x / currentScale) + offsets[i].x;
        const ny = (y / currentScale) + offsets[i].y;
        
        // Simple value noise
        const sampleX = Math.floor(nx);
        const sampleY = Math.floor(ny);
        const fracX = nx - sampleX;
        const fracY = ny - sampleY;
        
        // Generate 4 corner values
        const hash1 = (sampleX * 12345 + sampleY * 54321) % 123456;
        const hash2 = ((sampleX + 1) * 12345 + sampleY * 54321) % 123456;
        const hash3 = (sampleX * 12345 + (sampleY + 1) * 54321) % 123456;
        const hash4 = ((sampleX + 1) * 12345 + (sampleY + 1) * 54321) % 123456;
        
        const val1 = (hash1 / 123456) * 2 - 1;
        const val2 = (hash2 / 123456) * 2 - 1;
        const val3 = (hash3 / 123456) * 2 - 1;
        const val4 = (hash4 / 123456) * 2 - 1;
        
        // Bilinear interpolation
        const v1 = val1 + fracX * (val2 - val1);
        const v2 = val3 + fracX * (val4 - val3);
        const noise = v1 + fracY * (v2 - v1);
        
        value += noise * currentAmplitude;
        totalAmplitude += currentAmplitude;
      }
      
      // Normalize to [0, 1]
      return (value / totalAmplitude + 1) / 2;
    };
  };
  
  const elevationNoise = createNoiseGenerator(10, 1.0, 3);
  const moistureNoise = createNoiseGenerator(15, 1.0, 2);
  const resourceNoise = createNoiseGenerator(8, 1.0, 2);
  
  // Generate initial random tiles in an isometric layout
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      // Calculate isometric coordinates
      // In an isometric layout, the diamond shape comes from how we interpret the coordinates
      // The actual data structure remains a 2D grid
      
      // Get noise values for this position
      const elevation = Math.floor(elevationNoise(x, y) * 4); // 0-3 elevation
      const moisture = moistureNoise(x, y);
      const resourceValue = resourceNoise(x, y);
      
      // Determine terrain type based on elevation and moisture
      let terrainType;
      let passable = true;
      
      if (elevation === 0 && moisture > 0.7) {
        // Low elevation with high moisture = water
        terrainType = 'water';
        passable = false;
      } else if (elevation === 3 && moisture < 0.4) {
        // High elevation with low moisture = mountain
        terrainType = 'mountain';
        passable = false;
      } else if (elevation === 2 && moisture > 0.6) {
        // Medium-high elevation with high moisture = forest
        terrainType = 'forest';
        passable = true;
      } else if (elevation === 1 && moisture < 0.3) {
        // Low-medium elevation with low moisture = sand
        terrainType = 'sand';
        passable = true;
      } else {
        // Default is grass
        terrainType = 'grass';
        passable = true;
      }
      
      // Create the tile with the new data structure
      row.push({
        x: x,
        y: y,
        terrainType: terrainType,
        passable: passable,
        elevation: elevation,
        // Keep the old properties for backward compatibility
        type: terrainType,
        walkable: passable
      });
    }
    tiles.push(row);
  }
  
  // Apply some smoothing to make the map more natural
  const smoothedTiles = JSON.parse(JSON.stringify(tiles)); // Deep copy
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      // Count neighboring terrain types
      const neighbors = {};
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          
          const nx = x + dx;
          const ny = y + dy;
          
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const neighborType = tiles[ny][nx].terrainType;
            neighbors[neighborType] = (neighbors[neighborType] || 0) + 1;
          }
        }
      }
      
      // Find most common neighbor type
      let mostCommonType = tiles[y][x].terrainType;
      let maxCount = 0;
      
      for (const type in neighbors) {
        if (neighbors[type] > maxCount) {
          maxCount = neighbors[type];
          mostCommonType = type;
        }
      }
      
      // 50% chance to change to most common neighbor type
      if (maxCount > 4 && seededRandom() < 0.5) {
        smoothedTiles[y][x].terrainType = mostCommonType;
        smoothedTiles[y][x].type = mostCommonType; // For backward compatibility
        
        // Update passable status based on terrain type
        smoothedTiles[y][x].passable = mostCommonType !== 'water' && mostCommonType !== 'mountain';
        smoothedTiles[y][x].walkable = smoothedTiles[y][x].passable; // For backward compatibility
        
        // Adjust elevation based on new terrain type
        if (mostCommonType === 'mountain') {
          smoothedTiles[y][x].elevation = 3;
        } else if (mostCommonType === 'forest') {
          smoothedTiles[y][x].elevation = 2;
        } else if (mostCommonType === 'water') {
          smoothedTiles[y][x].elevation = 0;
        }
      }
    }
  }
  
  console.log('Map generation complete');
  return smoothedTiles;
}

// Game state
const gameState = {
  players: {},
  entities: {},
  map: null, // Will be initialized based on player count
  mapDimensions: { width: 40, height: 40, zoomFactor: 1.5 }, // Default starting dimensions with zoom
  lastUpdateTime: Date.now(),
  serverStartTime: Date.now() // Add server start time
};

// Initialize the map with default dimensions
gameState.map = generateMap(gameState.mapDimensions.width, gameState.mapDimensions.height);

// Initialize the game with bases and AI unit
initializeGame();

// Function to initialize the game with bases and AI unit
function initializeGame() {
  console.log('Initializing game with bases');
  
  // Create human base in the bottom-left quadrant
  const humanBaseId = uuidv4();
  const humanBaseX = Math.floor(gameState.mapDimensions.width * 0.25);
  const humanBaseY = Math.floor(gameState.mapDimensions.height * 0.75);
  
  // Create AI base in the top-right quadrant
  const aiBaseId = uuidv4();
  const aiBaseX = Math.floor(gameState.mapDimensions.width * 0.75);
  const aiBaseY = Math.floor(gameState.mapDimensions.height * 0.25);
  
  // Make sure the base locations are walkable
  makeAreaWalkable(humanBaseX, humanBaseY, 5, 5);
  makeAreaWalkable(aiBaseX, aiBaseY, 5, 5);
  
  // Add human base to entities with persistent team identifier
  gameState.entities[humanBaseId] = {
    id: humanBaseId,
    type: 'building',
    buildingType: 'BASE',
    playerColor: 'blue',
    x: humanBaseX * 32,
    y: humanBaseY * 32,
    width: 5 * 32,
    height: 5 * 32,
    playerId: 'human-team',
    isPlayerControlled: true,
    health: 1000,
    maxHealth: 1000
  };
  
  // Add AI base to entities
  gameState.entities[aiBaseId] = {
    id: aiBaseId,
    type: 'building',
    buildingType: 'BASE',
    playerColor: 'red',
    x: aiBaseX * 32,
    y: aiBaseY * 32,
    width: 5 * 32,
    height: 5 * 32,
    playerId: 'ai-team',
    isPlayerControlled: false,
    health: 1000,
    maxHealth: 1000
  };
  
  // Create an AI unit near the AI base
  const aiUnitId = uuidv4();
  gameState.entities[aiUnitId] = {
    id: aiUnitId,
    type: 'unit',
    unitType: 'SOLDIER',
    playerColor: 'red',
    x: aiBaseX * 32 - 64,
    y: aiBaseY * 32 + 80,
    width: 32,
    height: 32,
    playerId: 'ai-team',
    isPlayerControlled: false,
    health: 100,
    maxHealth: 100,
    attackDamage: 10,
    attackRange: 50,
    attackCooldown: 1000,
    speed: 2,
    level: 1,
    experience: 0,
    targetX: null,
    targetY: null,
    isMoving: false,
    lastUpdateTime: Date.now()
  };
  
  console.log('Game initialized with bases and AI unit');
}

// Function to make an area walkable (for base placement)
function makeAreaWalkable(centerX, centerY, width, height) {
  const halfWidth = Math.floor(width / 2);
  const halfHeight = Math.floor(height / 2);
  
  for (let y = centerY - halfHeight; y <= centerY + halfHeight; y++) {
    for (let x = centerX - halfWidth; x <= centerX + halfWidth; x++) {
      if (y >= 0 && y < gameState.map.length && x >= 0 && x < gameState.map[0].length) {
        gameState.map[y][x].terrainType = 'grass';
        gameState.map[y][x].type = 'grass'; // For backward compatibility
        gameState.map[y][x].passable = true;
        gameState.map[y][x].walkable = true; // For backward compatibility
        gameState.map[y][x].elevation = 1;
      }
    }
  }
}

// Function to check if map needs to be resized based on player count
function checkAndResizeMap() {
  const playerCount = Object.values(gameState.players).filter(player => player.connected).length;
  const newDimensions = getMapDimensions(playerCount);
  
  // Check if dimensions have changed
  if (newDimensions.width !== gameState.mapDimensions.width || 
      newDimensions.height !== gameState.mapDimensions.height) {
    
    console.log(`Resizing map from ${gameState.mapDimensions.width}x${gameState.mapDimensions.height} (zoom: ${gameState.mapDimensions.zoomFactor}) to ${newDimensions.width}x${newDimensions.height} (zoom: ${newDimensions.zoomFactor}) based on ${playerCount} players`);
    
    // Save old entities
    const oldEntities = { ...gameState.entities };
    
    // Update map dimensions
    gameState.mapDimensions = newDimensions;
    
    // Generate new map
    gameState.map = generateMap(newDimensions.width, newDimensions.height);
    
    // Clear entities
    gameState.entities = {};
    
    // Re-initialize game with bases
    initializeGame();
    
    // Restore player units with adjusted positions
    Object.values(oldEntities).forEach(entity => {
      if (entity.type === 'unit' && entity.playerId !== 'ai') {
        // Calculate relative position in the old map
        const oldMapWidth = gameState.map[0].length * 32;
        const oldMapHeight = gameState.map.length * 32;
        const relativeX = entity.x / oldMapWidth;
        const relativeY = entity.y / oldMapHeight;
        
        // Calculate new position in the new map
        const newMapWidth = newDimensions.width * 32;
        const newMapHeight = newDimensions.height * 32;
        const newX = Math.floor(relativeX * newMapWidth);
        const newY = Math.floor(relativeY * newMapHeight);
        
        // Create a new entity with adjusted position
        const newEntityId = uuidv4();
        gameState.entities[newEntityId] = {
          ...entity,
          id: newEntityId,
          x: newX,
          y: newY,
          targetX: null,
          targetY: null,
          isMoving: false
        };
      }
    });
    
    // Broadcast the new map and entities to all players
    io.emit('mapResized', {
      mapDimensions: gameState.mapDimensions,
      map: gameState.map,
      entities: gameState.entities
    });
    
    return true;
  }
  
  return false;
}

// Player colors for assignment
const playerColors = ['red', 'blue', 'green', 'yellow'];
let nextPlayerColorIndex = 0;

// Function to create a unit for a player
function createPlayerUnit(playerId) {
    // Find the player's base
    const playerBase = Object.values(gameState.entities).find(entity => 
        entity.type === 'building' && 
        entity.buildingType === 'BASE' && 
        entity.playerId === playerId
    );

    if (!playerBase) {
        console.error(`Could not find base for player ${playerId}`);
        return null;
    }

    // Create unit adjacent to the player's base
    const offsetX = 64; // 2 tiles to the right
    const unitX = playerBase.x + playerBase.width + offsetX;
    const unitY = playerBase.y + (playerBase.height / 2);

    // Create the unit with a unique ID
    const unitId = uuidv4();
    const unit = {
        id: unitId,
        type: 'unit',
        unitType: 'SOLDIER',
        x: unitX,
        y: unitY,
        width: 32,
        height: 32,
        health: 100,
        maxHealth: 100,
        attackDamage: 10,
        attackRange: 50,
        attackCooldown: 1000,
        speed: 2,
        level: 1,
        experience: 0,
        isPlayerControlled: true,
        playerId: playerId,
        playerColor: 'blue',
        targetX: null,
        targetY: null,
        isMoving: false,
        lastUpdateTime: Date.now()
    };

    console.log(`Created new unit for player ${playerId} at position (${unitX}, ${unitY})`);
    return unit;
}

// Handle socket connections
io.on('connection', (socket) => {
  console.log(`New player connected: ${socket.id}`);
  
  // Generate a unique player ID
  const playerId = uuidv4();
  
  // Add player to game state
  gameState.players[playerId] = {
    id: playerId,
    socketId: socket.id,
    name: `Player ${Object.keys(gameState.players).length + 1}`,
    color: 'blue', // Always blue for human player
    connected: true,
    lastActivity: Date.now()
  };
  
  // Check if map needs to be resized based on new player count
  const mapResized = checkAndResizeMap();
  
  // If map wasn't resized, we need to find the human base
  if (!mapResized) {
    // Find the human base by its persistent team identifier
    let humanBase = null;
    Object.values(gameState.entities).forEach(entity => {
      if (entity.type === 'building' && entity.buildingType === 'BASE' && 
          (entity.playerId === 'human-team' || entity.playerColor === 'blue')) {
        // Assign this player to the base
        entity.playerId = playerId;
        humanBase = entity;
        console.log(`Assigned human base to player ${playerId}`);
      }
    });
  }

  // Filter entities to only include buildings for initial state
  const buildingEntities = {};
  Object.entries(gameState.entities).forEach(([id, entity]) => {
    if (entity.type === 'building') {
      buildingEntities[id] = entity;
    }
  });
  
  // Send initial game state to the new player (only map and buildings)
  socket.emit('gameState', {
    playerId: playerId,
    gameState: {
      players: gameState.players,
      entities: buildingEntities,
      map: gameState.map,
      mapDimensions: gameState.mapDimensions,
      lastUpdateTime: gameState.lastUpdateTime,
      serverStartTime: gameState.serverStartTime
    }
  });
  
  // Broadcast new player to all other players
  socket.broadcast.emit('playerJoined', {
    player: gameState.players[playerId]
  });

  // Handle join game request
  socket.on('joinGame', (data) => {
    const playerId = data.playerId;
    console.log(`Player ${playerId} joining game`);

    if (gameState.players[playerId]) {
      // Create the unit explicitly
      const newUnit = createPlayerUnit(playerId);
      if (!newUnit) {
        socket.emit('joinGameError', { message: "Could not create unit." });
        return;
      }

      // IMPORTANT: Add unit to game state explicitly
      gameState.entities[newUnit.id] = newUnit;
      console.log(`Added unit ${newUnit.id} to game state for player ${playerId}`);

      // Broadcast to ALL clients (including the one who joined)
      io.emit('unitCreated', { unit: newUnit });
      console.log(`Broadcasted unitCreated event for unit ${newUnit.id}`);

      // Confirm join to requesting client explicitly
      socket.emit('joinGameSuccess', { unit: newUnit });
      console.log(`Sent joinGameSuccess to player ${playerId}`);
    } else {
      console.error(`Player ${playerId} not found in gameState.players`);
      socket.emit('joinGameError', { message: "Player not found." });
    }
  });
  
  // Handle player disconnection
  socket.on('disconnect', () => {
    console.log(`Player disconnected: ${socket.id}`);
    
    // Find the player by socket ID
    const playerId = Object.keys(gameState.players).find(
      id => gameState.players[id].socketId === socket.id
    );
    
    if (playerId) {
      // Mark player as disconnected
      gameState.players[playerId].connected = false;
      gameState.players[playerId].lastActivity = Date.now();
      
      // Broadcast player disconnection to all other players
      socket.broadcast.emit('playerLeft', {
        playerId: playerId
      });
      
      // Remove player units, but NOT their base
      Object.keys(gameState.entities).forEach(entityId => {
        const entity = gameState.entities[entityId];
        if (entity.playerId === playerId && entity.buildingType !== 'BASE') {
          delete gameState.entities[entityId];
          
          // Broadcast entity removal
          io.emit('entityRemoved', {
            entityId: entityId
          });
        }
      });
      
      // Check if map needs to be resized after player disconnection
      checkAndResizeMap();
    }
  });
});

// Game update loop (10 updates per second)
const UPDATE_INTERVAL = 100; // ms

setInterval(() => {
  const currentTime = Date.now();
  const deltaTime = currentTime - gameState.lastUpdateTime;
  gameState.lastUpdateTime = currentTime;
  
  // Update all moving entities
  Object.keys(gameState.entities).forEach(entityId => {
    const entity = gameState.entities[entityId];
    
    if (entity.isMoving && entity.targetX !== null && entity.targetY !== null) {
      // Calculate direction to target
      const centerX = entity.x + entity.width / 2;
      const centerY = entity.y + entity.height / 2;
      const dx = entity.targetX - centerX;
      const dy = entity.targetY - centerY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If we're close enough to the target, stop moving
      if (distance < 5) {
        entity.isMoving = false;
        entity.targetX = null;
        entity.targetY = null;
        return;
      }
      
      // Normalize direction and apply speed
      const moveSpeed = entity.speed * (deltaTime / 1000);
      const normalizedDx = dx / distance;
      const normalizedDy = dy / distance;
      
      // Update position with boundary checking
      const newX = entity.x + normalizedDx * moveSpeed;
      const newY = entity.y + normalizedDy * moveSpeed;
      
      // Ensure the entity stays within map boundaries
      const mapWidth = gameState.mapDimensions.width * 32; // Map width in pixels
      const mapHeight = gameState.mapDimensions.height * 32; // Map height in pixels
      
      entity.x = Math.max(0, Math.min(newX, mapWidth - entity.width));
      entity.y = Math.max(0, Math.min(newY, mapHeight - entity.height));
    }
  });
  
  // Broadcast updated game state to all players
  io.emit('gameUpdate', {
    entities: gameState.entities,
    timestamp: currentTime,
    serverStartTime: gameState.serverStartTime // Include server start time
  });
}, UPDATE_INTERVAL);

// Start the server
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Game client available at http://localhost:${PORT}`);
  console.log(`Initial map size: ${gameState.mapDimensions.width}x${gameState.mapDimensions.height} (zoom: ${gameState.mapDimensions.zoomFactor})`);
});  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\index.html 
======================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massive RTS Game</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="resourcesPanel" class="panel">
                <!-- Resources will be displayed here -->
            </div>
            <div id="minimap" class="panel">
                <!-- Minimap will be displayed here -->
            </div>
            <div id="controlPanel" class="panel">
                <!-- Control buttons will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Game scripts -->
    <script src="/src/utils/helpers.js"></script>
    <script src="/src/map/Tile.js"></script>
    <script src="/src/map/Map.js"></script>
    <script src="/src/entities/Entity.js"></script>
    <script src="/src/entities/Unit.js"></script>
    <script src="/src/entities/Building.js"></script>
    <script src="/src/game/Config.js"></script>
    <script src="/src/game/Camera.js"></script>
    <script src="/src/game/InputHandler.js"></script>
    <script src="/src/game/Renderer.js"></script>
    <script src="/src/game/Multiplayer.js"></script>
    <script src="/src/game/Game.js"></script>
    <script>
        // Initialize the game when the window loads
        window.onload = function() {
            const game = new Game();
            game.start();
        };
    </script>
</body>
</html>  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\styles.css 
======================================== 
 
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #222;
    color: #fff;
    overflow: hidden;
}

.game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    background-color: #000;
}

.ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allow clicks to pass through to canvas */
}

.panel {
    pointer-events: auto; /* Make panels clickable */
    background-color: rgba(0, 0, 0, 0.7);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
}

#resourcesPanel {
    position: absolute;
    top: 10px;
    left: 220px;
    width: 200px;
}

#minimap {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    height: 200px;
}

#controlPanel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 200px;
}

.control-btn {
    display: block;
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 8px;
    background-color: #2a6496;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    text-align: center;
    transition: background-color 0.2s;
}

.control-btn:hover {
    background-color: #3a7db5;
}

.control-btn:active {
    background-color: #1a5486;
}  
 
 
======================================== 
FILE: package.json 
======================================== 
 
{
  "name": "massive-rts",
  "version": "0.1.0",
  "description": "A browser-based RTS game with massively multiplayer capabilities",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "client": "http-server -c-1 -p 8080",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "rts",
    "game",
    "multiplayer",
    "browser",
    "html5",
    "canvas"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "canvas": "^3.1.0",
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "http-server": "^14.1.1",
    "nodemon": "^3.0.1"
  }
}
 
 
 
======================================== 
FILE: generate_terrain_tiles.js 
======================================== 
 
/**
 * Isometric Terrain Tile Generator
 * 
 * This script generates basic isometric terrain tiles (grass, mountain, water)
 * as PNG files for use in an isometric game.
 * 
 * Dependencies:
 * - Node.js
 * - canvas npm package (install with: npm install canvas)
 * 
 * Usage:
 * 1. Install dependencies: npm install canvas
 * 2. Run script: node generate_terrain_tiles.js
 * 3. Check current directory for generated PNG files
 */

const fs = require('fs');
const { createCanvas } = require('canvas');

// Configuration
const TILE_WIDTH = 128;
const TILE_HEIGHT = 64;
const OUTPUT_DIR = './';

// Define terrain types with their properties
const terrainTypes = [
    {
        name: 'grass',
        baseColor: '#7CBA3D',
        patternColor: '#8BC34A',
        patternType: 'noise'
    },
    {
        name: 'mountain',
        baseColor: '#8D6E63',
        patternColor: '#6D4C41',
        patternType: 'rocky'
    },
    {
        name: 'water',
        baseColor: '#4B93D1',
        patternColor: '#64B5F6',
        patternType: 'waves'
    },
    {
        name: 'forest',
        baseColor: '#2E7D32',
        patternColor: '#1B5E20',
        patternType: 'trees'
    },
    {
        name: 'sand',
        baseColor: '#FDD835',
        patternColor: '#F9A825',
        patternType: 'noise'
    }
];

/**
 * Main function to generate all terrain tiles
 */
function generateTerrainTiles() {
    console.log('Generating isometric terrain tiles...');
    
    // Create output directory if it doesn't exist
    if (!fs.existsSync(OUTPUT_DIR)) {
        fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    }
    
    // Generate each terrain type
    terrainTypes.forEach(terrain => {
        generateTile(terrain);
    });
    
    console.log('Tile generation complete! Files saved to:', OUTPUT_DIR);
}

/**
 * Generate a single terrain tile
 * @param {Object} terrain - Terrain configuration object
 */
function generateTile(terrain) {
    console.log(`Generating ${terrain.name} tile...`);
    
    // Create canvas with specified dimensions
    const canvas = createCanvas(TILE_WIDTH, TILE_HEIGHT);
    const ctx = canvas.getContext('2d');
    
    // Clear canvas with transparency
    ctx.clearRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw the isometric diamond shape
    drawIsometricTile(ctx, terrain);
    
    // Save the canvas as a PNG file
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(`${OUTPUT_DIR}${terrain.name}.png`, buffer);
    
    console.log(` ${terrain.name}.png created`);
}

/**
 * Draw an isometric tile with the specified terrain properties
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawIsometricTile(ctx, terrain) {
    // Draw the diamond shape
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, 0);              // Top point
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);    // Right point
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);    // Bottom point
    ctx.lineTo(0, TILE_HEIGHT / 2);             // Left point
    ctx.closePath();
    
    // Fill with base color
    ctx.fillStyle = terrain.baseColor;
    ctx.fill();
    
    // Add pattern based on terrain type
    switch (terrain.patternType) {
        case 'noise':
            drawNoisePattern(ctx, terrain);
            break;
        case 'rocky':
            drawRockyPattern(ctx, terrain);
            break;
        case 'waves':
            drawWavePattern(ctx, terrain);
            break;
        case 'trees':
            drawTreePattern(ctx, terrain);
            break;
    }
    
    // Add shading for 3D effect
    addShading(ctx);
    
    // Add border
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
}

/**
 * Draw a noise pattern (for grass and sand)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawNoisePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    ctx.fillStyle = terrain.patternColor;
    
    // Create a noise pattern with small dots
    for (let i = 0; i < 500; i++) {
        const x = Math.random() * TILE_WIDTH;
        const y = Math.random() * TILE_HEIGHT;
        const size = Math.random() * 1.5 + 0.5;
        
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

/**
 * Draw a rocky pattern (for mountains)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawRockyPattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Draw mountain peak
    const gradient = ctx.createLinearGradient(
        TILE_WIDTH / 2, 0,
        TILE_WIDTH / 2, TILE_HEIGHT
    );
    gradient.addColorStop(0, terrain.patternColor);
    gradient.addColorStop(1, terrain.baseColor);
    
    ctx.fillStyle = gradient;
    
    // Draw a triangular mountain shape
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 4);
    ctx.lineTo(TILE_WIDTH * 0.7, TILE_HEIGHT * 0.7);
    ctx.lineTo(TILE_WIDTH * 0.3, TILE_HEIGHT * 0.7);
    ctx.closePath();
    ctx.fill();
    
    // Add some rocky details
    ctx.fillStyle = terrain.patternColor;
    for (let i = 0; i < 15; i++) {
        const x = TILE_WIDTH * 0.3 + Math.random() * (TILE_WIDTH * 0.4);
        const y = TILE_HEIGHT * 0.4 + Math.random() * (TILE_HEIGHT * 0.3);
        const size = 2 + Math.random() * 5;
        
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y - size / 2);
        ctx.lineTo(x + size * 1.5, y);
        ctx.lineTo(x + size, y + size / 2);
        ctx.closePath();
        ctx.fill();
    }
    
    // Add snow cap
    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 4);
    ctx.lineTo(TILE_WIDTH / 2 + 10, TILE_HEIGHT / 4 + 10);
    ctx.lineTo(TILE_WIDTH / 2 - 10, TILE_HEIGHT / 4 + 10);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

/**
 * Draw a wave pattern (for water)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawWavePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Create a gradient for water depth
    const gradient = ctx.createLinearGradient(
        0, TILE_HEIGHT / 2,
        TILE_WIDTH, TILE_HEIGHT / 2
    );
    gradient.addColorStop(0, terrain.baseColor);
    gradient.addColorStop(0.5, terrain.patternColor);
    gradient.addColorStop(1, terrain.baseColor);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw wave lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 1;
    
    for (let i = 0; i < 8; i++) {
        const yPos = TILE_HEIGHT * 0.3 + i * (TILE_HEIGHT * 0.5 / 8);
        
        ctx.beginPath();
        ctx.moveTo(TILE_WIDTH * 0.3, yPos);
        
        // Create a wavy line
        for (let x = 0; x < TILE_WIDTH * 0.4; x += 5) {
            ctx.lineTo(
                TILE_WIDTH * 0.3 + x,
                yPos + Math.sin(x * 0.1) * 2
            );
        }
        
        ctx.stroke();
    }
    
    ctx.restore();
}

/**
 * Draw a tree pattern (for forests)
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} terrain - Terrain configuration object
 */
function drawTreePattern(ctx, terrain) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Draw base gradient
    const gradient = ctx.createLinearGradient(
        0, 0,
        TILE_WIDTH, TILE_HEIGHT
    );
    gradient.addColorStop(0, terrain.baseColor);
    gradient.addColorStop(1, terrain.patternColor);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, TILE_WIDTH, TILE_HEIGHT);
    
    // Draw tree trunks
    ctx.fillStyle = '#795548';
    
    for (let i = 0; i < 10; i++) {
        const x = 15 + Math.random() * (TILE_WIDTH - 30);
        const y = 10 + Math.random() * (TILE_HEIGHT - 20);
        
        ctx.fillRect(x, y, 3, 6);
    }
    
    // Draw tree tops
    ctx.fillStyle = terrain.patternColor;
    
    for (let i = 0; i < 10; i++) {
        const x = 15 + Math.random() * (TILE_WIDTH - 30);
        const y = 8 + Math.random() * (TILE_HEIGHT - 20);
        
        ctx.beginPath();
        ctx.arc(x + 1, y, 6, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.restore();
}

/**
 * Add shading to create a 3D effect
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 */
function addShading(ctx) {
    ctx.save();
    
    // Clip to the diamond shape
    clipToDiamond(ctx);
    
    // Add highlight on top-left edge
    const highlightGradient = ctx.createLinearGradient(
        0, TILE_HEIGHT / 2,
        TILE_WIDTH / 2, 0
    );
    highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
    highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    
    ctx.fillStyle = highlightGradient;
    ctx.beginPath();
    ctx.moveTo(0, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH / 2, 0);
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT / 2);
    ctx.closePath();
    ctx.fill();
    
    // Add shadow on bottom-right edge
    const shadowGradient = ctx.createLinearGradient(
        TILE_WIDTH / 2, TILE_HEIGHT / 2,
        TILE_WIDTH, TILE_HEIGHT / 2
    );
    shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
    
    ctx.fillStyle = shadowGradient;
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
}

/**
 * Helper function to clip the canvas to the diamond shape
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 */
function clipToDiamond(ctx) {
    ctx.beginPath();
    ctx.moveTo(TILE_WIDTH / 2, 0);              // Top point
    ctx.lineTo(TILE_WIDTH, TILE_HEIGHT / 2);    // Right point
    ctx.lineTo(TILE_WIDTH / 2, TILE_HEIGHT);    // Bottom point
    ctx.lineTo(0, TILE_HEIGHT / 2);             // Left point
    ctx.closePath();
    ctx.clip();
}

// Run the generator
generateTerrainTiles();  
 
 
======================================== 
FILE: Renderer.js 
======================================== 
 
renderEntities() {
    this.game.entities.forEach(entity => {
        if (!this.camera.isVisible(entity.x, entity.y, entity.width, entity.height)) {
            return;
        }
        const isoX = (entity.x - entity.y) / 2;
        const isoY = (entity.x + entity.y) / 4;
        const screenPos = this.camera.worldToScreen(isoX, isoY);
        // Proceed with existing rendering logic using screenPos.x, screenPos.y
        if (entity.image) {
            this.ctx.drawImage(entity.image, screenPos.x, screenPos.y);
        } else {
            this.ctx.fillStyle = entity.isPlayerControlled ? Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            this.ctx.fillRect(screenPos.x, screenPos.y, entity.width * this.camera.zoom, entity.height * this.camera.zoom);
        }
        // Add any additional rendering (e.g., selection highlights, health bars)
    });
}  
 
