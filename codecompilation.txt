Massive RTS Game - Code Compilation 
Created: Tue 03/04/2025 19:23:35.27 
======================================== 
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Building.js 
======================================== 
 
/**
 * Building class for player bases and other structures
 */
class Building extends Entity {
  /**
   * Initialize a building
   * @param {number} x - X position
   * @param {number} y - Y position
   * @param {number} width - Width of the building
   * @param {number} height - Height of the building
   * @param {boolean} isPlayerControlled - Whether this building is controlled by the player
   * @param {string} buildingType - Type of building (e.g., 'BASE', 'BARRACKS')
   * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
   */
  constructor(x, y, width, height, isPlayerControlled = false, buildingType = 'BASE', playerColor = 'red') {
    super(x, y, width, height, isPlayerControlled);
    
    console.log(`Creating building: ${buildingType} at (${x}, ${y}) with color ${playerColor}`);
    
    // Building type and appearance
    this.buildingType = buildingType;
    this.playerColor = playerColor;
    this.image = null;
    this.loadImage();
    
    // Apply attributes based on building type
    const attributes = Config.BUILDING_ATTRIBUTES[buildingType] || Config.BUILDING_ATTRIBUTES.BASE;
    
    // Building properties
    this.productionRate = attributes.productionRate || 0;
    this.productionType = attributes.productionType || null;
    this.productionProgress = 0;
    this.productionQueue = [];
    
    // Health and stats
    this.health = attributes.health || 500;
    this.maxHealth = attributes.health || 500;
  }
  
  /**
   * Load the building image based on player color and building type
   */
  loadImage() {
    const imagePath = `/images/buildings/${this.playerColor}_${this.buildingType.toLowerCase()}.png`;
    console.log(`Loading building image: ${imagePath}`);
    this.image = new Image();
    this.image.src = imagePath;
    this.image.onerror = (e) => {
      console.error(`Failed to load building image: ${imagePath}`, e);
      // Fallback to a colored rectangle
      console.log(`Attempting to load fallback image: /images/buildings/${this.buildingType.toLowerCase()}.png`);
      this.image.src = `/images/buildings/${this.buildingType.toLowerCase()}.png`;
    };
    this.image.onload = () => {
      console.log(`Successfully loaded building image: ${imagePath}`);
    };
  }
  
  /**
   * Set the player color for this building
   */
  setPlayerColor(color) {
    this.playerColor = color;
    this.loadImage();
  }
  
  /**
   * Update building state
   */
  update(deltaTime, game) {
    // Handle production if this building produces units
    if (this.productionRate > 0 && this.productionQueue.length > 0) {
      this.updateProduction(deltaTime, game);
    }
  }
  
  /**
   * Update production progress
   */
  updateProduction(deltaTime, game) {
    // Increase production progress
    this.productionProgress += (this.productionRate * deltaTime) / 1000;
    
    // Check if production is complete
    if (this.productionProgress >= 1) {
      this.completeProduction(game);
      this.productionProgress = 0;
    }
  }
  
  /**
   * Complete production of a unit
   */
  completeProduction(game) {
    if (this.productionQueue.length === 0) return;
    
    // Get the unit type from the queue
    const unitType = this.productionQueue.shift();
    
    // Calculate spawn position (near the building)
    const spawnX = this.x + this.width + 10;
    const spawnY = this.y + this.height / 2;
    
    // Create the unit
    const unit = new Unit(
      spawnX,
      spawnY,
      Config.UNIT_SIZE,
      Config.UNIT_SIZE,
      this.isPlayerControlled,
      unitType,
      this.playerColor
    );
    
    // Set the player ID
    unit.playerId = this.playerId;
    
    // Add the unit to the game
    game.entities.push(unit);
    
    console.log(`Building produced a ${unitType}`);
  }
  
  /**
   * Queue a unit for production
   */
  queueUnit(unitType) {
    this.productionQueue.push(unitType);
    console.log(`Added ${unitType} to production queue`);
  }
  
  /**
   * Take damage from an attacker
   */
  takeDamage(amount, attacker) {
    this.health -= amount;
    console.log(`Building took ${amount} damage, health: ${this.health}`);
    
    // If health drops to 0 or below, destroy the building
    if (this.health <= 0) {
      this.die();
    }
  }
  
  /**
   * Handle building destruction
   */
  die() {
    console.log('Building destroyed');
    // In a real implementation, we would remove the building from the game
    // and possibly play a destruction animation
  }
  
  /**
   * Convert building to a network-friendly format
   */
  toNetworkData() {
    const data = super.toNetworkData();
    return {
      ...data,
      buildingType: this.buildingType,
      playerColor: this.playerColor,
      productionRate: this.productionRate,
      productionType: this.productionType,
      productionProgress: this.productionProgress,
      productionQueue: this.productionQueue
    };
  }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Entity.js 
======================================== 
 
/**
 * Base class for all game entities (units, buildings, etc.)
 */
class Entity {
    /**
     * Initialize an entity
     */
    constructor(x, y, width, height, isPlayerControlled = false) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.isPlayerControlled = isPlayerControlled;
        this.isSelected = false;
        this.health = 100;
        this.maxHealth = 100;
        
        // Multiplayer properties
        this.id = null; // Server-assigned ID
        this.playerId = null; // ID of the player who owns this entity
        this.serverX = null; // Position from server for interpolation
        this.serverY = null; // Position from server for interpolation
    }
    
    /**
     * Update entity state
     */
    update(deltaTime, game) {
        // Base entity doesn't do anything in update
        // This method should be overridden by subclasses
    }
    
    /**
     * Check if this entity collides with another entity
     */
    collidesWith(otherEntity) {
        return (
            this.x < otherEntity.x + otherEntity.width &&
            this.x + this.width > otherEntity.x &&
            this.y < otherEntity.y + otherEntity.height &&
            this.y + this.height > otherEntity.y
        );
    }
    
    /**
     * Check if this entity contains a point
     */
    containsPoint(x, y) {
        return (
            x >= this.x &&
            x <= this.x + this.width &&
            y >= this.y &&
            y <= this.y + this.height
        );
    }
    
    /**
     * Take damage
     */
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) {
            this.health = 0;
            this.die();
        }
    }
    
    /**
     * Entity death
     */
    die() {
        // This method should be overridden by subclasses
        console.log('Entity died');
    }
    
    /**
     * Get the center position of the entity
     */
    getCenter() {
        return {
            x: this.x + this.width / 2,
            y: this.y + this.height / 2
        };
    }
    
    /**
     * Calculate distance to another entity or point
     */
    distanceTo(target) {
        let targetX, targetY;
        
        if (target instanceof Entity) {
            const targetCenter = target.getCenter();
            targetX = targetCenter.x;
            targetY = targetCenter.y;
        } else {
            targetX = target.x;
            targetY = target.y;
        }
        
        const center = this.getCenter();
        const dx = targetX - center.x;
        const dy = targetY - center.y;
        
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    /**
     * Convert entity to a network-friendly format
     */
    toNetworkData() {
        return {
            id: this.id,
            type: this.constructor.name.toLowerCase(),
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            health: this.health,
            playerId: this.playerId,
            isPlayerControlled: this.isPlayerControlled
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\entities\Unit.js 
======================================== 
 
/**
 * Unit class for player and AI controlled units
 */
class Unit extends Entity {
    /**
     * Initialize a unit
     * @param {number} x - X position
     * @param {number} y - Y position
     * @param {number} width - Width of the unit
     * @param {number} height - Height of the unit
     * @param {boolean} isPlayerControlled - Whether this unit is controlled by the player
     * @param {string} unitType - Type of unit (e.g., 'SOLDIER')
     * @param {string} playerColor - Color of the player (e.g., 'red', 'blue')
     */
    constructor(x, y, width, height, isPlayerControlled = false, unitType = 'SOLDIER', playerColor = 'red') {
        super(x, y, width, height, isPlayerControlled);
        
        // Unit type and appearance
        this.unitType = unitType;
        this.playerColor = playerColor;
        this.image = null;
        this.loadImage();
        
        // Apply attributes based on unit type
        const attributes = Config.UNIT_ATTRIBUTES[unitType] || Config.UNIT_ATTRIBUTES.SOLDIER;
        
        // Movement properties
        this.speed = attributes.speed || Config.UNIT_SPEED;
        this.targetX = null;
        this.targetY = null;
        this.isMoving = false;
        
        // Combat properties
        this.attackRange = attributes.attackRange || 50;
        this.attackDamage = attributes.attackDamage || 10;
        this.attackCooldown = attributes.attackCooldown || 1000; // ms
        this.lastAttackTime = 0;
        this.targetEntity = null;
        
        // Health and stats
        this.health = attributes.health || 100;
        this.maxHealth = attributes.health || 100;
        this.level = 1;
        this.experience = 0;
    }
    
    /**
     * Load the unit image based on player color and unit type
     */
    loadImage() {
        const imagePath = `/images/units/${this.playerColor}_${this.unitType.toLowerCase()}.png`;
        console.log(`Loading unit image: ${imagePath}`);
        this.image = new Image();
        this.image.src = imagePath;
        this.image.onerror = () => {
            console.error(`Failed to load unit image: ${imagePath}`);
            // Fallback to default image if available
            console.log(`Attempting to load fallback image: /images/units/${this.unitType.toLowerCase()}.png`);
            this.image.src = `/images/units/${this.unitType.toLowerCase()}.png`;
        };
    }
    
    /**
     * Set the player color for this unit
     */
    setPlayerColor(color) {
        this.playerColor = color;
        this.loadImage();
    }
    
    /**
     * Update unit state
     */
    update(deltaTime, game) {
        // Handle movement if we have a target
        if (this.isMoving && this.targetX !== null && this.targetY !== null) {
            this.moveTowardsTarget(deltaTime);
        }
        
        // Handle combat if we have a target entity
        if (this.targetEntity) {
            this.updateCombat(deltaTime, game);
        }
    }
    
    /**
     * Move towards the target position
     */
    moveTowardsTarget(deltaTime) {
        // Calculate direction to target
        const dx = this.targetX - this.x;
        const dy = this.targetY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If we're close enough to the target, stop moving
        if (distance < 1) {
            this.x = this.targetX;
            this.y = this.targetY;
            this.isMoving = false;
            this.targetX = null;
            this.targetY = null;
            return;
        }
        
        // Normalize direction and apply speed
        const moveSpeed = Config.UNIT_SPEED * (deltaTime / 1000);
        const normalizedDx = dx / distance;
        const normalizedDy = dy / distance;
        
        // Calculate new position
        const newX = this.x + normalizedDx * moveSpeed;
        const newY = this.y + normalizedDy * moveSpeed;
        
        // Ensure the unit stays within map boundaries
        const mapWidth = Config.MAP_WIDTH * Config.TILE_SIZE;
        const mapHeight = Config.MAP_HEIGHT * Config.TILE_SIZE;
        
        this.x = Math.max(0, Math.min(newX, mapWidth - this.width));
        this.y = Math.max(0, Math.min(newY, mapHeight - this.height));
    }
    
    /**
     * Set a movement target
     */
    setTarget(x, y) {
        this.targetX = x;
        this.targetY = y;
        this.isMoving = true;
    }
    
    /**
     * Update combat state
     */
    updateCombat(deltaTime, game) {
        // Check if target is still valid
        if (!this.targetEntity || this.targetEntity.health <= 0) {
            this.targetEntity = null;
            return;
        }
        
        // Calculate distance to target
        const center = this.getCenter();
        const targetCenter = this.targetEntity.getCenter();
        const dx = targetCenter.x - center.x;
        const dy = targetCenter.y - center.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // If target is out of range, move towards it
        if (distance > this.attackRange) {
            this.setTarget(targetCenter.x, targetCenter.y);
            return;
        }
        
        // If we're in range and attack cooldown is over, attack
        const now = Date.now();
        if (now - this.lastAttackTime >= this.attackCooldown) {
            this.attack(this.targetEntity);
            this.lastAttackTime = now;
        }
    }
    
    /**
     * Attack a target entity
     */
    attack(target) {
        console.log(`Unit attacking target for ${this.attackDamage} damage`);
        target.takeDamage(this.attackDamage, this);
    }
    
    /**
     * Take damage from an attacker
     */
    takeDamage(amount, attacker) {
        this.health -= amount;
        console.log(`Unit took ${amount} damage, health: ${this.health}`);
        
        // If health drops to 0 or below, die
        if (this.health <= 0) {
            this.die();
            
            // Give experience to the attacker if it's a unit
            if (attacker instanceof Unit) {
                attacker.gainExperience(this.level * 10);
            }
        }
    }
    
    /**
     * Gain experience points
     */
    gainExperience(amount) {
        this.experience += amount;
        console.log(`Unit gained ${amount} experience, total: ${this.experience}`);
        
        // Check for level up (simple formula: 100 * current level)
        const experienceNeeded = this.level * 100;
        if (this.experience >= experienceNeeded) {
            this.levelUp();
        }
    }
    
    /**
     * Level up the unit
     */
    levelUp() {
        this.level++;
        this.experience = 0;
        
        // Increase stats
        this.maxHealth += 20;
        this.health = this.maxHealth;
        this.attackDamage += 5;
        
        console.log(`Unit leveled up to level ${this.level}`);
    }
    
    /**
     * Handle unit death
     */
    die() {
        console.log('Unit died');
        // In a real implementation, we would remove the unit from the game
        // and possibly play a death animation
    }
    
    /**
     * Convert unit to a network-friendly format
     */
    toNetworkData() {
        const data = super.toNetworkData();
        return {
            ...data,
            unitType: this.unitType,
            playerColor: this.playerColor,
            speed: this.speed,
            attackRange: this.attackRange,
            attackDamage: this.attackDamage,
            attackCooldown: this.attackCooldown,
            level: this.level,
            experience: this.experience,
            targetX: this.targetX,
            targetY: this.targetY,
            isMoving: this.isMoving
        };
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\BuildingImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing building images
 */
class BuildingImageLoader {
    /**
     * Initialize the building image loader
     */
    constructor() {
        // Building types
        this.buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];
        
        // Player colors
        this.playerColors = ['red', 'blue', 'green', 'yellow'];
        
        // Store loaded images
        this.images = {};
        
        // Load all building images
        this.loadBuildingImages();
        
        console.log('BuildingImageLoader initialized');
    }
    
    /**
     * Load all building images
     */
    loadBuildingImages() {
        // Load default building images
        this.buildingTypes.forEach(buildingType => {
            const img = new Image();
            img.src = `/images/buildings/${buildingType.toLowerCase()}.png`;
            this.images[buildingType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded building image: ${buildingType}`);
            img.onerror = () => console.warn(`Failed to load building image: ${buildingType}`);
            
            // Load player-colored variants
            this.playerColors.forEach(color => {
                const coloredImg = new Image();
                coloredImg.src = `/images/buildings/${buildingType.toLowerCase()}_${color}.png`;
                this.images[`${buildingType}_${color}`] = coloredImg;
                
                // Log when image loads or fails
                coloredImg.onload = () => console.log(`Loaded building image: ${buildingType}_${color}`);
                coloredImg.onerror = () => console.warn(`Failed to load building image: ${buildingType}_${color}`);
            });
        });
    }
    
    /**
     * Get the image for a specific building type and player color
     */
    getBuildingImage(buildingType, playerColor = null) {
        if (playerColor) {
            const coloredImage = this.images[`${buildingType}_${playerColor}`];
            if (coloredImage) return coloredImage;
        }
        
        return this.images[buildingType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Camera.js 
======================================== 
 
/**
 * Camera class for handling viewport and map navigation
 */
class Camera {
    /**
     * Initialize the camera
     */
    constructor() {
        // Camera position (top-left corner of the viewport in world coordinates)
        this.x = 0;
        this.y = 0;
        
        // Camera dimensions (viewport size)
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Camera zoom level
        this.zoom = Config.ZOOM_DEFAULT;
        
        // Calculate initial boundaries based on current map dimensions
        this.updateBoundaries();
        
        // We'll center on player units later when they're created
        // Don't call centerOnMap() here
        
        console.log(`Camera initialized at position (${this.x}, ${this.y}) with zoom ${this.zoom}`);
    }

    /**
     * Center the camera on the map
     */
    centerOnMap() {
        // Calculate the map dimensions in isometric coordinates
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the isometric map width and height
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set camera position to center on the map
        this.x = isoCenterX - (viewportWorldWidth / 2);
        this.y = isoCenterY - (viewportWorldHeight / 2);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Camera centered on map at (${this.x.toFixed(2)}, ${this.y.toFixed(2)})`);
    }

    /**
     * Update camera boundaries based on current map dimensions
     */
    updateBoundaries() {
        // For isometric view, we need to calculate boundaries differently
        const mapWidth = Config.MAP_WIDTH;
        const mapHeight = Config.MAP_HEIGHT;
        const tileSize = Config.TILE_SIZE;
        
        // Calculate the width and height of the isometric map in world coordinates
        // In isometric view, the map width is (mapWidth + mapHeight) * tileSize / 2
        // and the map height is (mapWidth + mapHeight) * tileSize / 4
        const isoMapWidth = (mapWidth + mapHeight) * (tileSize / 2);
        const isoMapHeight = (mapWidth + mapHeight) * (tileSize / 4);
        
        // Calculate the center in grid coordinates
        const centerGridX = mapWidth / 2;
        const centerGridY = mapHeight / 2;
        
        // Convert to isometric coordinates
        const isoCenterX = (centerGridX - centerGridY) * (tileSize / 2);
        const isoCenterY = (centerGridX + centerGridY) * (tileSize / 4);
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Calculate maximum camera positions
        // We need to ensure the camera can't move so far that the map is off-screen
        // For isometric maps, we need more generous boundaries
        const extraPadding = Math.max(viewportWorldWidth, viewportWorldHeight) * 0.5;
        
        // Set more balanced boundaries
        // The key is to make the boundaries symmetrical around the map center
        this.maxX = isoCenterX + isoMapWidth/2 + extraPadding;
        this.maxY = isoCenterY + isoMapHeight/2 + extraPadding;
        this.minX = isoCenterX - isoMapWidth/2 - extraPadding;
        this.minY = isoCenterY - isoMapHeight/2 - extraPadding;
        
        console.log(`Camera boundaries updated: minX=${this.minX}, minY=${this.minY}, maxX=${this.maxX}, maxY=${this.maxY}`);
    }

    /**
     * Move the camera by the specified delta
     */
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        this.clampPosition();
    }

    /**
     * Set the camera position directly
     */
    setPosition(x, y) {
        this.x = x;
        this.y = y;
        this.clampPosition();
    }

    /**
     * Center the camera on a specific world position
     */
    centerOn(worldX, worldY) {
        // Calculate the position to center the camera on the given world coordinates
        this.x = worldX - (this.width / this.zoom / 2);
        this.y = worldY - (this.height / this.zoom / 2);
        
        // Ensure camera stays within map boundaries
        this.clampPosition();
    }

    /**
     * Ensure camera stays within map boundaries
     */
    clampPosition() {
        // For isometric view, we need to allow the camera to go slightly outside the map boundaries
        // to ensure the entire map is visible
        
        // Calculate the effective maximum positions based on viewport size
        // This ensures we can see the bottom of the map
        const viewportWidth = this.width / this.zoom;
        const viewportHeight = this.height / this.zoom;
        
        // Calculate effective boundaries
        // For the max boundaries, we need to subtract the viewport size to ensure
        // we can pan all the way to the bottom/right edges
        const effectiveMinX = this.minX;
        const effectiveMinY = this.minY;
        const effectiveMaxX = Math.max(0, this.maxX - viewportWidth);
        const effectiveMaxY = Math.max(0, this.maxY - viewportHeight);
        
        // Clamp camera position to stay within map boundaries
        this.x = Math.max(effectiveMinX, Math.min(this.x, effectiveMaxX));
        this.y = Math.max(effectiveMinY, Math.min(this.y, effectiveMaxY));
        
        console.log(`Camera position clamped to (${this.x}, ${this.y})`);
    }

    /**
     * Convert world coordinates to screen coordinates
     */
    worldToScreen(worldX, worldY) {
        return {
            x: (worldX - this.x) * this.zoom,
            y: (worldY - this.y) * this.zoom
        };
    }

    /**
     * Convert screen coordinates to world coordinates
     */
    screenToWorld(screenX, screenY) {
        return {
            x: (screenX / this.zoom) + this.x,
            y: (screenY / this.zoom) + this.y
        };
    }

    /**
     * Check if a world position is visible on screen
     */
    isVisible(worldX, worldY, width, height) {
        return (
            worldX + width > this.x &&
            worldX < this.x + (this.width / this.zoom) &&
            worldY + height > this.y &&
            worldY < this.y + (this.height / this.zoom)
        );
    }

    /**
     * Update camera dimensions when window is resized or map dimensions change
     */
    updateDimensions() {
        // Update viewport dimensions
        this.width = Config.CANVAS_WIDTH;
        this.height = Config.CANVAS_HEIGHT;
        
        // Update boundaries based on current map dimensions
        this.updateBoundaries();
        
        // Ensure camera position is still valid
        this.clampPosition();
        
        console.log(`Camera dimensions updated: width=${this.width}, height=${this.height}, map=${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
    }

    /**
     * Zoom at a specific point (mouse position)
     * @param {number} deltaZoom - Amount to change zoom by
     * @param {number} clientX - Mouse X position in screen coordinates
     * @param {number} clientY - Mouse Y position in screen coordinates
     */
    zoomAt(deltaZoom, clientX, clientY) {
        // Store the world point that we're zooming at
        const worldPoint = this.screenToWorld(clientX, clientY);
        const worldX = worldPoint.x;
        const worldY = worldPoint.y;
        
        // Store the old zoom value
        const oldZoom = this.zoom;
        
        // Update zoom level with constraints
        this.zoom += deltaZoom;
        this.zoom = Math.max(Config.ZOOM_MIN, Math.min(Config.ZOOM_MAX, this.zoom));
        
        // If zoom didn't actually change, exit early
        if (this.zoom === oldZoom) return;
        
        // Calculate new camera position to keep the mouse point fixed in world space
        const mouseXRatio = clientX / this.width;
        const mouseYRatio = clientY / this.height;
        
        // Calculate the viewport dimensions in world space
        const viewportWorldWidth = this.width / this.zoom;
        const viewportWorldHeight = this.height / this.zoom;
        
        // Set the new camera position
        this.x = worldX - (mouseXRatio * viewportWorldWidth);
        this.y = worldY - (mouseYRatio * viewportWorldHeight);
        
        // Ensure camera stays within boundaries
        this.clampPosition();
        
        console.log(`Zoomed to ${this.zoom.toFixed(2)} at world point (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
    }

    /**
     * Center the camera on player units
     * @param {Array} entities - All game entities
     * @param {string} playerId - The current player's ID
     */
    centerOnPlayerUnits(entities, playerId) {
        if (!entities || entities.length === 0) {
            console.log("No entities to center on, centering on map instead");
            this.centerOnMap();
            return;
        }
        
        // Find player-controlled units
        const playerUnits = entities.filter(entity => 
            entity.playerId === playerId && 
            entity.type === 'UNIT'
        );
        
        // If no player units found, try to find player base
        if (playerUnits.length === 0) {
            const playerBase = entities.find(entity => 
                entity.playerId === playerId && 
                entity.type === 'BUILDING' && 
                entity.buildingType === 'BASE'
            );
            
            if (playerBase) {
                console.log(`Centering camera on player base at (${playerBase.x}, ${playerBase.y})`);
                this.centerOn(playerBase.x + playerBase.width/2, playerBase.y + playerBase.height/2);
                
                // Zoom in a bit to focus on the base
                this.zoom = Config.ZOOM_DEFAULT * 1.2;
                this.clampPosition();
                return;
            }
        } else {
            // Calculate average position of all player units
            let avgX = 0;
            let avgY = 0;
            
            playerUnits.forEach(unit => {
                avgX += unit.x;
                avgY += unit.y;
            });
            
            avgX /= playerUnits.length;
            avgY /= playerUnits.length;
            
            console.log(`Centering camera on ${playerUnits.length} player units at (${avgX}, ${avgY})`);
            this.centerOn(avgX, avgY);
            
            // Zoom in a bit to focus on the units
            this.zoom = Config.ZOOM_DEFAULT * 1.2;
            this.clampPosition();
            return;
        }
        
        // Fallback to centering on map if no player entities found
        console.log("No player entities found, centering on map instead");
        this.centerOnMap();
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Config.js 
======================================== 
 
/**
 * Game configuration constants
 */
class Config {
    // Canvas and rendering
    static CANVAS_WIDTH = window.innerWidth;
    static CANVAS_HEIGHT = window.innerHeight;
    
    // Map settings
    static MAP_WIDTH = 100; // Number of tiles horizontally
    static MAP_HEIGHT = 100; // Number of tiles vertically
    static TILE_SIZE = 64; // Size of each tile in pixels - increased for better isometric rendering
    
    // Camera settings
    static CAMERA_SPEED = 10; // Camera movement speed
    static CAMERA_EDGE_THRESHOLD = 50; // Pixels from edge to trigger camera movement
    static ZOOM_MIN = 0.5; // Minimum zoom level (50%)
    static ZOOM_MAX = 2.0; // Maximum zoom level (200%)
    static ZOOM_SPEED = 0.1; // How much to zoom per mouse wheel tick
    static ZOOM_DEFAULT = 0.7; // Default zoom level (70%) - reduced to show more of the map
    
    // Unit settings
    static UNIT_SPEED = 2; // Movement speed of units
    static UNIT_SIZE = 32; // Size of units in pixels
    static UNIT_ATTRIBUTES = {
        SOLDIER: {
            health: 100,
            attackDamage: 10,
            attackRange: 50,
            attackCooldown: 1000,
            speed: 2
        }
    };
    
    // Building settings
    static BUILDING_ATTRIBUTES = {
        BASE: {
            health: 1000,
            productionRate: 0.1, // Units per second
            productionType: 'SOLDIER'
        },
        BARRACKS: {
            health: 500,
            productionRate: 0.2,
            productionType: 'SOLDIER'
        }
    };
    
    // Player settings
    static PLAYER_COLORS = [
        'red',
        'blue',
        'green',
        'yellow'
    ];
    
    // Colors
    static COLORS = {
        GRASS: '#3a8c3a',
        WATER: '#4286f4',
        SAND: '#e6d56e',
        MOUNTAIN: '#7a7a7a',
        FOREST: '#1f5e1f',
        PLAYER_UNIT: '#0000ff',
        ENEMY_UNIT: '#ff0000',
        SELECTION: '#ffffff',
        GRID: 'rgba(0, 0, 0, 0.2)'
    };
    
    // Debug settings
    static DEBUG_MODE = true; // Enable/disable debug information
    static SHOW_GRID = true; // Show grid lines
    
    // Update the canvas dimensions when the window is resized
    static updateDimensions() {
        this.CANVAS_WIDTH = window.innerWidth;
        this.CANVAS_HEIGHT = window.innerHeight;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Game.js 
======================================== 
 
/**
 * Main game class that coordinates all game components
 */
class Game {
    /**
     * Initialize the game
     */
    constructor() {
        // Get canvas and context
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Set canvas dimensions
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        
        // Initialize game components
        this.camera = new Camera();
        this.map = new Map();
        this.renderer = new Renderer(this);
        this.inputHandler = new InputHandler(this);
        this.multiplayer = new Multiplayer(this);
        
        // Game state
        this.entities = [];
        this.selectedEntities = [];
        this.running = false;
        this.lastFrameTime = 0;
        this.fps = 0;
        
        // Multiplayer state
        this.playerId = null;
    }
    
    /**
     * Start the game
     */
    start() {
        // Initialize multiplayer
        this.multiplayer = new Multiplayer(this);
        this.multiplayer.connect();
        
        // Start the game loop
        this.running = true;
        requestAnimationFrame(this.gameLoop.bind(this));
    }
    
    /**
     * Main game loop
     */
    gameLoop(timestamp) {
        // Calculate delta time and FPS
        const deltaTime = timestamp - this.lastFrameTime;
        this.lastFrameTime = timestamp;
        this.fps = 1000 / deltaTime;
        
        // Update game state
        this.update(deltaTime);
        
        // Render the game
        this.renderer.render();
        
        // Continue the game loop
        if (this.running) {
            requestAnimationFrame(this.gameLoop.bind(this));
        }
    }
    
    /**
     * Update game state
     */
    update(deltaTime) {
        // Update input handler
        this.inputHandler.update();
        
        // Update multiplayer
        this.multiplayer.update(deltaTime);
        
        // Update all entities
        for (const entity of this.entities) {
            entity.update(deltaTime, this);
        }
    }
    
    /**
     * Process entities received from the server
     */
    processServerEntities(serverEntities) {
        if (!serverEntities) return;
        
        console.log('Processing server entities:', Object.keys(serverEntities).length);
        console.log('Entity types:', Object.values(serverEntities).map(e => e.type).join(', '));
        
        // Clear existing entities if this is a full update
        if (this.entities.length === 0) {
            this.entities = [];
        }
        
        // Process each entity from the server
        Object.values(serverEntities).forEach(serverEntity => {
            console.log(`Processing entity: ${serverEntity.id}, type: ${serverEntity.type}, position: (${serverEntity.x}, ${serverEntity.y})`);
            
            // Check if this entity already exists
            let entity = this.entities.find(e => e.id === serverEntity.id);
            
            if (!entity) {
                // Create a new entity based on its type
                if (serverEntity.type === 'unit') {
                    entity = new Unit(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.multiplayer.playerId,
                        serverEntity.unitType,
                        serverEntity.playerColor
                    );
                } else if (serverEntity.type === 'building') {
                    console.log(`Creating building: ${serverEntity.buildingType} at (${serverEntity.x}, ${serverEntity.y}) with color ${serverEntity.playerColor}`);
                    entity = new Building(
                        serverEntity.x,
                        serverEntity.y,
                        serverEntity.width,
                        serverEntity.height,
                        serverEntity.playerId === this.multiplayer.playerId,
                        serverEntity.buildingType,
                        serverEntity.playerColor
                    );
                }
                
                if (entity) {
                    // Set additional properties
                    entity.id = serverEntity.id;
                    entity.playerId = serverEntity.playerId;
                    entity.health = serverEntity.health;
                    entity.maxHealth = serverEntity.maxHealth;
                    
                    // Add to entities array
                    this.entities.push(entity);
                    console.log(`Added new ${serverEntity.type} from server:`, entity);
                }
            } else {
                // Update existing entity
                if (serverEntity.type === 'unit') {
                    // Only update position for units, not buildings
                    entity.x = serverEntity.x;
                    entity.y = serverEntity.y;
                    entity.targetX = serverEntity.targetX;
                    entity.targetY = serverEntity.targetY;
                    entity.isMoving = serverEntity.isMoving;
                }
                
                // Update health for all entities
                entity.health = serverEntity.health;
                entity.maxHealth = serverEntity.maxHealth;
                
                // Make sure isPlayerControlled is set correctly
                entity.isPlayerControlled = serverEntity.playerId === this.multiplayer.playerId;
            }
        });
        
        console.log(`Total entities after processing: ${this.entities.length}`);
    }
    
    /**
     * Handle entity selection
     */
    handleEntitySelection(worldX, worldY) {
        console.log(`Handling selection at world coordinates (${worldX}, ${worldY})`);

        const gridPos = this.map.isoToGrid(worldX, worldY);
        const gridX = gridPos.x;
        const gridY = gridPos.y;
        
        console.log(`Converted to grid coordinates (${gridX}, ${gridY})`);

        let entitySelected = false;

        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];

        // Check if any entity was clicked
        for (const entity of this.entities) {
            const entityGridX = Math.floor(entity.x / Config.TILE_SIZE);
            const entityGridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            console.log(`Checking entity ${entity.id} at grid (${entityGridX}, ${entityGridY}), isPlayerControlled: ${entity.isPlayerControlled}, playerId: ${entity.playerId}`);

            if (gridX === entityGridX && gridY === entityGridY) {
                console.log(`Entity ${entity.id} is at the clicked grid position`);
                
                // Only select entities that belong to the player and are player-controlled
                if (entity.playerId !== this.multiplayer.playerId || !entity.isPlayerControlled) {
                    console.log(`Entity ${entity.id} belongs to player ${entity.playerId} or is not player-controlled, not selecting`);
                    continue;
                }
                
                // Select this entity
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitySelected = true;
                
                // Log selection for debugging
                console.log(`Selected entity: ${entity.constructor.name}, ID: ${entity.id}, Player: ${entity.playerId}`);
                break; // Only select one entity for now
            }
        }
        
        // If no entity was selected, this might be a map click
        if (!entitySelected) {
            console.log(`No entity selected at grid (${gridX}, ${gridY})`);
        }
    }
    
    /**
     * Select entities within a box
     */
    selectEntitiesInBox(startX, startY, endX, endY) {
        console.log(`Selecting entities in box from world (${startX.toFixed(2)}, ${startY.toFixed(2)}) to (${endX.toFixed(2)}, ${endY.toFixed(2)})`);
        
        // Convert isometric world coordinates to grid coordinates
        const startGridPos = this.map.isoToGrid(startX, startY);
        const endGridPos = this.map.isoToGrid(endX, endY);
        
        console.log(`Selection box in grid coordinates: from (${startGridPos.x.toFixed(2)}, ${startGridPos.y.toFixed(2)}) to (${endGridPos.x.toFixed(2)}, ${endGridPos.y.toFixed(2)})`);
        
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle in grid coordinates
        const selectionRect = {
            x: Math.min(startGridPos.x, endGridPos.x),
            y: Math.min(startGridPos.y, endGridPos.y),
            width: Math.abs(endGridPos.x - startGridPos.x),
            height: Math.abs(endGridPos.y - startGridPos.y)
        };
        
        console.log(`Selection rectangle in grid: (${selectionRect.x.toFixed(2)}, ${selectionRect.y.toFixed(2)}) with size ${selectionRect.width.toFixed(2)}x${selectionRect.height.toFixed(2)}`);
        
        // Select entities found within the selection rectangle
        let entitiesSelected = 0;
        for (const entity of this.entities) {
            // Convert entity position to grid coordinates
            const entityGridX = Math.floor(entity.x / Config.TILE_SIZE);
            const entityGridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            console.log(`Checking entity ${entity.id} at grid (${entityGridX}, ${entityGridY}), isPlayerControlled: ${entity.isPlayerControlled}, playerId: ${entity.playerId}`);
            
            if (
                entityGridX >= selectionRect.x &&
                entityGridX <= selectionRect.x + selectionRect.width &&
                entityGridY >= selectionRect.y &&
                entityGridY <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    console.log(`Entity ${entity.id} belongs to player ${entity.playerId}, not selecting`);
                    continue;
                }
                
                // Select this entity
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitiesSelected++;
                
                // For debugging
                console.log(`Selected entity in box: ${entity.constructor.name}, ID: ${entity.id}`);
            } else {
                console.log(`Entity ${entity.id} not in selection box or not player-controlled`);
            }
        }
        
        console.log(`Selected ${entitiesSelected} entities in box selection`);
    }
    
    /**
     * Deselect all entities
     */
    deselectAll() {
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
    }
    
    /**
     * Handle area selection
     */
    handleAreaSelection(startPos, endPos) {
        // Deselect all entities first
        for (const entity of this.entities) {
            entity.isSelected = false;
        }
        this.selectedEntities = [];
        
        // Calculate selection rectangle
        const selectionRect = {
            x: Math.min(startPos.x, endPos.x),
            y: Math.min(startPos.y, endPos.y),
            width: Math.abs(endPos.x - startPos.x),
            height: Math.abs(endPos.y - startPos.y)
        };
        
        // Select all entities within the selection rectangle
        let entitiesSelected = 0;
        for (const entity of this.entities) {
            if (
                entity.x + entity.width >= selectionRect.x &&
                entity.x <= selectionRect.x + selectionRect.width &&
                entity.y + entity.height >= selectionRect.y &&
                entity.y <= selectionRect.y + selectionRect.height &&
                entity.isPlayerControlled // Only select player-controlled units
            ) {
                // Only select entities that belong to the player
                if (entity.playerId !== this.multiplayer.playerId) {
                    continue;
                }
                
                entity.isSelected = true;
                this.selectedEntities.push(entity);
                entitiesSelected++;
                
                // For debugging
                console.log(`Selected entity in area: ${entity.constructor.name}, ID: ${entity.id}`);
            }
        }
        
        console.log(`Selected ${entitiesSelected} entities in area selection`);
    }
    
    /**
     * Handle command (right-click)
     */
    handleCommand(worldX, worldY) {
        if (this.selectedEntities.length === 0) return;

        console.log(`Command at isometric world coordinates: (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
        
        // Correctly convert from isometric world coordinates to grid coordinates
        const gridPos = this.map.isoToGrid(worldX, worldY);
        const tileX = Math.floor(gridPos.x);
        const tileY = Math.floor(gridPos.y);
        
        console.log(`Converted to grid coordinates: (${tileX}, ${tileY})`);
        
        // Convert grid coordinates to cartesian coordinates for server
        const cartesianX = tileX * Config.TILE_SIZE;
        const cartesianY = tileY * Config.TILE_SIZE;
        
        console.log(`Units moving to cartesian coordinates: (${cartesianX}, ${cartesianY})`);

        // Get IDs of selected units for multiplayer
        const selectedUnitIds = this.selectedEntities
            .filter(entity => entity instanceof Unit)
            .map(entity => entity.id);
        
        if (selectedUnitIds.length > 0) {
            // Send movement command to server with cartesian coordinates
            this.multiplayer.moveUnits(selectedUnitIds, cartesianX, cartesianY);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
        this.renderer.handleResize();
    }
    
    /**
     * Create a test player unit
     */
    createTestUnit() {
        // In multiplayer mode, units are created by the server
        if (this.multiplayer && this.multiplayer.connected) {
            // Find the player's base
            const playerBase = this.entities.find(entity => 
                entity.buildingType === 'BASE' && 
                entity.playerId === this.playerId
            );
            
            if (playerBase) {
                // Create unit near the player's base
                const spawnX = playerBase.x + playerBase.width + 10;
                const spawnY = playerBase.y + playerBase.height / 2;
                
                console.log(`Creating unit near player base at (${spawnX}, ${spawnY})`);
                this.multiplayer.createUnit(spawnX, spawnY, true, 'SOLDIER');
            } else {
                // Fallback to center of map if no base found
                const centerX = Config.MAP_WIDTH * Config.TILE_SIZE / 2;
                const centerY = Config.MAP_HEIGHT * Config.TILE_SIZE / 2;
                
                console.log(`No player base found, creating unit at center (${centerX}, ${centerY})`);
                this.multiplayer.createUnit(centerX, centerY, true, 'SOLDIER');
            }
            return;
        }
        
        // For single player testing only
        const unit = new Unit(
            Config.MAP_WIDTH * Config.TILE_SIZE / 2,
            Config.MAP_HEIGHT * Config.TILE_SIZE / 2,
            Config.UNIT_SIZE,
            Config.UNIT_SIZE,
            true,
            'SOLDIER',
            'red'
        );
        this.entities.push(unit);
    }
    
    /**
     * Create a unit at the specified position
     */
    createUnitAt(x, y) {
        if (this.multiplayer && this.multiplayer.connected) {
            this.multiplayer.createUnit(x, y, true, 'SOLDIER');
        } else {
            const unit = new Unit(
                x,
                y,
                Config.UNIT_SIZE,
                Config.UNIT_SIZE,
                true,
                'SOLDIER',
                'blue'
            );
            this.entities.push(unit);
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\InputHandler.js 
======================================== 
 
/**
 * Handles user input (keyboard, mouse) for game interaction
 */
class InputHandler {
    /**
     * Initialize input handler and set up event listeners
     */
    constructor(game) {
        this.game = game;
        this.camera = game.camera;
        this.canvas = game.canvas;
        
        this.keys = {}; // Track pressed keys
        this.mouseX = 0;
        this.mouseY = 0;
        this.mouseDown = false;
        this.rightMouseDown = false;
        this.middleMouseDown = false;
        this.lastMouseX = 0;
        this.lastMouseY = 0;
        this.selectionStartX = 0;
        this.selectionStartY = 0;
        this.selectionEndX = 0;
        this.selectionEndY = 0;
        this.isSelecting = false;
        
        // Minimap element
        this.minimapElement = document.getElementById('minimap');
        
        // Bind event handlers
        this.setupEventListeners();
    }
    
    /**
     * Set up all event listeners
     */
    setupEventListeners() {
        // Keyboard events
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        window.addEventListener('keyup', this.handleKeyUp.bind(this));
        
        // Mouse events
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
        this.canvas.addEventListener('wheel', this.handleMouseWheel.bind(this));
        
        // Prevent context menu from appearing on right-click
        this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Minimap events
        this.minimapElement.addEventListener('mousedown', this.handleMinimapClick.bind(this));
        this.minimapElement.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // Window resize event
        window.addEventListener('resize', this.handleResize.bind(this));
    }
    
    /**
     * Handle key down events
     */
    handleKeyDown(e) {
        this.keys[e.key] = true;
        
        // Handle specific key presses
        switch (e.key) {
            case 'Escape':
                // Deselect all units
                this.game.deselectAll();
                break;
            case 'c':
                // Center the camera on the map
                this.camera.centerOnMap();
                break;
        }
        
        // Handle camera movement with arrow keys
        this.updateCameraFromKeys();
    }
    
    /**
     * Handle key up events
     */
    handleKeyUp(e) {
        this.keys[e.code] = false;
    }
    
    /**
     * Handle mouse down events
     */
    handleMouseDown(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = true;
            this.selectionStartX = e.clientX;
            this.selectionStartY = e.clientY;
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
            this.isSelecting = true;
            
            // Check if clicked on an entity
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            console.log(`Mouse down at screen (${e.clientX}, ${e.clientY}), world (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`);
            this.game.handleEntitySelection(worldPos.x, worldPos.y);
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = true;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = true;
            e.preventDefault(); // Prevent default middle-click behavior
        }
    }
    
    /**
     * Handle mouse up events
     */
    handleMouseUp(e) {
        // Left mouse button
        if (e.button === 0) {
            this.mouseDown = false;
            
            if (this.isSelecting) {
                // Finalize selection box
                const startWorld = this.camera.screenToWorld(this.selectionStartX, this.selectionStartY);
                const endWorld = this.camera.screenToWorld(this.selectionEndX, this.selectionEndY);
                console.log(`Selection box from (${startWorld.x.toFixed(2)}, ${startWorld.y.toFixed(2)}) to (${endWorld.x.toFixed(2)}, ${endWorld.y.toFixed(2)})`);
                this.game.selectEntitiesInBox(startWorld.x, startWorld.y, endWorld.x, endWorld.y);
                this.isSelecting = false;
            }
        }
        // Right mouse button
        else if (e.button === 2) {
            this.rightMouseDown = false;
        }
        // Middle mouse button (rollerball)
        else if (e.button === 1) {
            this.middleMouseDown = false;
        }
    }
    
    /**
     * Handle mouse movement
     */
    handleMouseMove(e) {
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        
        // Update selection box if selecting
        if (this.isSelecting) {
            this.selectionEndX = e.clientX;
            this.selectionEndY = e.clientY;
        }
        
        // Handle middle mouse panning
        if (this.middleMouseDown) {
            const deltaX = this.lastMouseX - e.clientX;
            const deltaY = this.lastMouseY - e.clientY;
            
            // Move camera based on mouse movement
            this.camera.move(deltaX / this.camera.zoom, deltaY / this.camera.zoom);
        }
        
        this.lastMouseX = e.clientX;
        this.lastMouseY = e.clientY;
        
        // Handle camera movement when mouse is near screen edges
        this.updateCameraFromMouse();
    }
    
    /**
     * Handle mouse wheel events for zooming
     */
    handleMouseWheel(e) {
        e.preventDefault();
        
        // Determine zoom direction
        const deltaZoom = e.deltaY < 0 ? Config.ZOOM_SPEED : -Config.ZOOM_SPEED;
        
        // Zoom at the mouse position
        this.camera.zoomAt(deltaZoom, e.clientX, e.clientY);
    }
    
    /**
     * Handle right click events
     */
    handleRightClick(e) {
        e.preventDefault(); // Prevent context menu
        
        // If we have selected entities, issue a command
        if (this.game.selectedEntities.length > 0) {
            const worldPos = this.camera.screenToWorld(e.clientX, e.clientY);
            this.game.handleCommand(worldPos.x, worldPos.y);
        }
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        Config.updateDimensions();
        this.camera.updateDimensions();
        this.game.handleResize();
    }
    
    /**
     * Update camera position based on keyboard input
     */
    updateCameraFromKeys() {
        let dx = 0;
        let dy = 0;
        
        if (this.keys['ArrowUp'] || this.keys['w']) dy -= Config.CAMERA_SPEED;
        if (this.keys['ArrowDown'] || this.keys['s']) dy += Config.CAMERA_SPEED;
        if (this.keys['ArrowLeft'] || this.keys['a']) dx -= Config.CAMERA_SPEED;
        if (this.keys['ArrowRight'] || this.keys['d']) dx += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update camera position when mouse is near screen edges
     */
    updateCameraFromMouse() {
        let dx = 0;
        let dy = 0;
        const threshold = Config.CAMERA_EDGE_THRESHOLD;
        
        // Move camera if mouse is near the edges
        if (this.mouseX < threshold) dx -= Config.CAMERA_SPEED;
        if (this.mouseX > Config.CANVAS_WIDTH - threshold) dx += Config.CAMERA_SPEED;
        if (this.mouseY < threshold) dy -= Config.CAMERA_SPEED;
        if (this.mouseY > Config.CANVAS_HEIGHT - threshold) dy += Config.CAMERA_SPEED;
        
        if (dx !== 0 || dy !== 0) {
            this.camera.move(dx, dy);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {
        this.updateCameraFromKeys();
        this.updateCameraFromMouse();
    }
    
    /**
     * Get the current selection box in screen coordinates
     */
    getSelectionBox() {
        if (!this.isSelecting) return null;
        
        return {
            x: Math.min(this.selectionStartX, this.selectionEndX),
            y: Math.min(this.selectionStartY, this.selectionEndY),
            width: Math.abs(this.selectionEndX - this.selectionStartX),
            height: Math.abs(this.selectionEndY - this.selectionStartY)
        };
    }
    
    /**
     * Handle minimap clicks
     */
    handleMinimapClick(e) {
        e.stopPropagation(); // Prevent event from bubbling to canvas
        
        // Get minimap dimensions
        const minimapRect = this.minimapElement.getBoundingClientRect();
        
        // Calculate relative position within minimap (0-1)
        const relativeX = (e.clientX - minimapRect.left) / minimapRect.width;
        const relativeY = (e.clientY - minimapRect.top) / minimapRect.height;
        
        // For isometric view, we need to convert differently
        // First, adjust for the minimap's isometric representation
        const adjustedX = (relativeX - 0.5) * 2; // Convert from 0-1 to -1 to 1 (centered)
        const adjustedY = (relativeY - 0.25) * 4; // Adjust for the 1/4 offset in the minimap
        
        // Convert to grid coordinates
        const gridX = Math.floor((adjustedX + adjustedY) / 2 * Config.MAP_WIDTH);
        const gridY = Math.floor((adjustedY - adjustedX) / 2 * Config.MAP_HEIGHT);
        
        // Clamp to valid grid coordinates
        const clampedGridX = Math.max(0, Math.min(gridX, Config.MAP_WIDTH - 1));
        const clampedGridY = Math.max(0, Math.min(gridY, Config.MAP_HEIGHT - 1));
        
        // Convert to isometric world coordinates
        const isoPos = this.game.map.gridToIso(clampedGridX, clampedGridY);
        
        console.log(`Minimap click: screen(${relativeX.toFixed(2)}, ${relativeY.toFixed(2)}) -> grid(${clampedGridX}, ${clampedGridY}) -> iso(${isoPos.x.toFixed(2)}, ${isoPos.y.toFixed(2)})`);
        
        // Left click - move camera to this position
        if (e.button === 0) {
            // Center camera on clicked position
            this.camera.centerOn(isoPos.x, isoPos.y);
        }
        // Right click - move selected units to this position
        else if (e.button === 2) {
            if (this.game.selectedEntities.length > 0) {
                this.game.handleCommand(isoPos.x, isoPos.y);
            }
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Multiplayer.js 
======================================== 
 
/**
 * Multiplayer class for handling client-side networking
 */
class Multiplayer {
    /**
     * Initialize the multiplayer system
     * @param {Game} game - Reference to the main game instance
     */
    constructor(game) {
        this.game = game;
        this.socket = null;
        this.playerId = null;
        this.connected = false;
        this.serverEntities = {}; // Entities from the server
        this.pendingCommands = []; // Commands waiting to be sent
        this.lastServerUpdate = 0;
        
        // Bind methods
        this.onConnect = this.onConnect.bind(this);
        this.onDisconnect = this.onDisconnect.bind(this);
        this.onGameState = this.onGameState.bind(this);
        this.onGameUpdate = this.onGameUpdate.bind(this);
        this.onPlayerJoined = this.onPlayerJoined.bind(this);
        this.onPlayerLeft = this.onPlayerLeft.bind(this);
        this.onUnitCreated = this.onUnitCreated.bind(this);
        this.onUnitsMoved = this.onUnitsMoved.bind(this);
        this.onEntityRemoved = this.onEntityRemoved.bind(this);
        this.onMapResized = this.onMapResized.bind(this);
    }
    
    /**
     * Connect to the game server
     */
    connect() {
        // Connect to the server on the same host and port
        // Since we're serving the client from the same server
        const serverUrl = window.location.origin;
        
        console.log(`Connecting to game server at ${serverUrl}`);
        
        // Create socket connection
        this.socket = io(serverUrl);
        
        // Set up event handlers
        this.socket.on('connect', this.onConnect);
        this.socket.on('disconnect', this.onDisconnect);
        this.socket.on('gameState', this.onGameState);
        this.socket.on('gameUpdate', this.onGameUpdate);
        this.socket.on('playerJoined', this.onPlayerJoined);
        this.socket.on('playerLeft', this.onPlayerLeft);
        this.socket.on('unitCreated', this.onUnitCreated);
        this.socket.on('unitsMoved', this.onUnitsMoved);
        this.socket.on('entityRemoved', this.onEntityRemoved);
        this.socket.on('mapResized', this.onMapResized);
    }
    
    /**
     * Disconnect from the game server
     */
    disconnect() {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.connected = false;
    }
    
    /**
     * Handle connection to the server
     */
    onConnect() {
        console.log('Connected to game server');
        this.connected = true;
        
        // Process any pending commands
        this.processPendingCommands();
    }
    
    /**
     * Handle disconnection from the server
     */
    onDisconnect() {
        console.log('Disconnected from game server');
        this.connected = false;
    }
    
    /**
     * Handle initial game state from server
     */
    onGameState(data) {
        console.log('Received initial game state from server');
        this.playerId = data.playerId;
        this.game.playerId = data.playerId;
        
        // Update map dimensions from server data
        if (data.gameState && data.gameState.mapDimensions) {
            console.log('Setting map dimensions from server data:', data.gameState.mapDimensions);
            this.updateMapDimensions(data.gameState.mapDimensions);
        }
        
        // Set the map from server data
        if (data.gameState && data.gameState.map) {
            console.log('Setting map from server data');
            this.game.map.setMapFromServer(data.gameState.map);
        } else {
            console.error('No map data received from server');
        }
        
        // Process entities from server data
        if (data.gameState && data.gameState.entities) {
            console.log('Processing entities from server data');
            this.game.processServerEntities(data.gameState.entities);
            
            // Create initial unit after entities are processed
            console.log('Creating initial unit for player');
            this.createInitialUnit();
        }
    }
    
    /**
     * Handle map resize event from server
     */
    onMapResized(data) {
        console.log('Received map resize event from server:', data.mapDimensions);
        
        // Update map dimensions
        this.updateMapDimensions(data.mapDimensions);
        
        // Update the map tiles
        if (data.map) {
            this.game.map.setMapFromServer(data.map);
        }
        
        // Update entities
        if (data.entities) {
            this.game.processServerEntities(data.entities);
        }
        
        // Reset camera position to ensure it's within bounds
        this.game.camera.updateDimensions();
        this.game.camera.clampPosition();
    }
    
    /**
     * Update map dimensions based on server data
     */
    updateMapDimensions(mapDimensions) {
        if (!mapDimensions) return;
        
        // Update Config with new map dimensions
        Config.MAP_WIDTH = mapDimensions.width;
        Config.MAP_HEIGHT = mapDimensions.height;
        
        // Apply zoom factor if provided
        if (mapDimensions.zoomFactor) {
            this.game.camera.zoom = mapDimensions.zoomFactor;
        }
        
        console.log(`Updated map dimensions to ${Config.MAP_WIDTH}x${Config.MAP_HEIGHT}`);
        
        // Update camera boundaries
        this.game.camera.updateDimensions();
    }
    
    /**
     * Create an initial unit for the player near their base
     */
    createInitialUnit() {
        // Find the player's base
        const playerBase = this.game.entities.find(entity => 
            entity.buildingType === 'BASE' && 
            entity.playerId === this.playerId
        );
        
        let unitX, unitY;
        
        if (playerBase) {
            // Create unit directly adjacent to the player's base
            // Use a fixed offset that ensures the unit is in a valid position
            const offsetX = 64; // 2 tiles to the right
            
            // Calculate spawn position relative to the base
            unitX = playerBase.x + playerBase.width + offsetX;
            unitY = playerBase.y + (playerBase.height / 2);
            
            console.log(`Creating initial unit adjacent to player base at (${unitX}, ${unitY})`);
            
            // Create the unit directly without setTimeout
            this.createUnit(unitX, unitY, true, 'SOLDIER');
        } else {
            console.error('Could not find player base to spawn initial unit');
            
            // Fallback to center of map if no base found
            unitX = Config.MAP_WIDTH * Config.TILE_SIZE / 2;
            unitY = Config.MAP_HEIGHT * Config.TILE_SIZE / 2;
            
            console.log(`No player base found, creating unit at center (${unitX}, ${unitY})`);
            this.createUnit(unitX, unitY, true, 'SOLDIER');
        }
        
        // Center the camera on the unit's position and zoom in
        setTimeout(() => {
            // Convert grid coordinates to isometric coordinates for proper centering
            const tileSize = Config.TILE_SIZE;
            const gridX = unitX / tileSize;
            const gridY = unitY / tileSize;
            const isoX = (gridX - gridY) * (tileSize / 2);
            const isoY = (gridX + gridY) * (tileSize / 4);
            
            console.log(`Centering camera on player unit at isometric position (${isoX}, ${isoY})`);
            
            // Center the camera on the unit
            this.game.camera.centerOn(isoX, isoY);
            
            // Set an appropriate zoom level for the initial view
            this.game.camera.zoom = Config.ZOOM_DEFAULT * 1.5;
            
            // Ensure camera stays within boundaries
            this.game.camera.clampPosition();
        }, 100); // Short delay to ensure the unit is fully created
    }
    
    /**
     * Handle game state updates from server
     */
    onGameUpdate(data) {
        this.lastServerUpdate = Date.now();
        
        // Store previous positions before updating
        this.game.entities.forEach(entity => {
            if (entity.type === 'unit') {
                // Store current position as previous position
                entity.prevX = entity.x;
                entity.prevY = entity.y;
                
                // Initialize interpolation time
                entity.interpolationStartTime = Date.now();
            }
        });
        
        // Update entities from server data
        this.game.processServerEntities(data.entities);
        
        // Store server positions for interpolation
        this.game.entities.forEach(entity => {
            if (entity.type === 'unit') {
                // Store server position for interpolation
                entity.serverX = entity.x;
                entity.serverY = entity.y;
                
                // Restore current position to previous position for smooth interpolation
                if (entity.prevX !== undefined && entity.prevY !== undefined) {
                    entity.x = entity.prevX;
                    entity.y = entity.prevY;
                }
            }
        });
    }
    
    /**
     * Handle new player joining
     */
    onPlayerJoined(data) {
        console.log('Player joined:', data.player);
        // Could show a notification or update player list
    }
    
    /**
     * Handle player leaving
     */
    onPlayerLeft(data) {
        console.log('Player left:', data.playerId);
        // Could show a notification or update player list
    }
    
    /**
     * Handle new unit creation
     */
    onUnitCreated(data) {
        console.log('Unit created:', data.unit);
        
        // Process the new unit using the same method
        this.game.processServerEntities({ [data.unit.id]: data.unit });
        
        // If this is a player-controlled unit, center the camera on it
        if (data.unit.playerId === this.playerId) {
            // Convert grid coordinates to isometric coordinates for proper centering
            const tileSize = Config.TILE_SIZE;
            const gridX = data.unit.x / tileSize;
            const gridY = data.unit.y / tileSize;
            const isoX = (gridX - gridY) * (tileSize / 2);
            const isoY = (gridX + gridY) * (tileSize / 4);
            
            console.log(`Centering camera on new player unit at isometric position (${isoX}, ${isoY})`);
            
            // Center the camera on the unit
            this.game.camera.centerOn(isoX, isoY);
            
            // Set an appropriate zoom level
            this.game.camera.zoom = Config.ZOOM_DEFAULT * 1.5;
            
            // Ensure camera stays within boundaries
            this.game.camera.clampPosition();
        }
    }
    
    /**
     * Handle units being moved
     */
    onUnitsMoved(data) {
        const { unitIds, targetX, targetY } = data;
        
        unitIds.forEach(unitId => {
            const unit = this.game.entities.find(e => e.id === unitId);
            if (unit) {
                unit.moveTo(targetX, targetY);
            }
        });
    }
    
    /**
     * Handle entity removal
     */
    onEntityRemoved(data) {
        const entityIndex = this.game.entities.findIndex(e => e.id === data.entityId);
        if (entityIndex !== -1) {
            this.game.entities.splice(entityIndex, 1);
        }
    }
    
    /**
     * Create an entity from server data
     */
    createEntityFromServer(entityData) {
        // This method is now deprecated in favor of processServerEntities
        console.warn('createEntityFromServer is deprecated, use processServerEntities instead');
        
        if (entityData.type === 'unit') {
            const unit = new Unit(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.unitType || 'SOLDIER',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            unit.id = entityData.id;
            unit.playerId = entityData.playerId;
            
            // Set unit attributes from server data
            if (entityData.health !== undefined) unit.health = entityData.health;
            if (entityData.maxHealth !== undefined) unit.maxHealth = entityData.maxHealth;
            if (entityData.attackDamage !== undefined) unit.attackDamage = entityData.attackDamage;
            if (entityData.attackRange !== undefined) unit.attackRange = entityData.attackRange;
            if (entityData.attackCooldown !== undefined) unit.attackCooldown = entityData.attackCooldown;
            if (entityData.speed !== undefined) unit.speed = entityData.speed;
            if (entityData.level !== undefined) unit.level = entityData.level;
            if (entityData.experience !== undefined) unit.experience = entityData.experience;
            
            // Set movement properties
            if (entityData.targetX !== undefined) unit.targetX = entityData.targetX;
            if (entityData.targetY !== undefined) unit.targetY = entityData.targetY;
            if (entityData.isMoving !== undefined) unit.isMoving = entityData.isMoving;
            
            // Add to game entities
            this.game.entities.push(unit);
            return unit;
        } else if (entityData.type === 'building') {
            const building = new Building(
                entityData.x,
                entityData.y,
                entityData.width,
                entityData.height,
                entityData.playerId === this.playerId,
                entityData.buildingType || 'BASE',
                entityData.playerColor || 'red'
            );
            
            // Set server-specific properties
            building.id = entityData.id;
            building.playerId = entityData.playerId;
            
            // Set building attributes from server data
            if (entityData.health !== undefined) building.health = entityData.health;
            if (entityData.maxHealth !== undefined) building.maxHealth = entityData.maxHealth;
            
            // Add to game entities
            this.game.entities.push(building);
            return building;
        }
        
        return null;
    }
    
    /**
     * Create a new unit
     */
    createUnit(x, y, isPlayerControlled, unitType = 'SOLDIER') {
        if (!this.connected) {
            console.error('Cannot create unit: not connected to server');
            return;
        }
        
        this.socket.emit('createUnit', {
            x,
            y,
            isPlayerControlled,
            unitType
        });
    }
    
    /**
     * Move units and send to server
     */
    moveUnits(unitIds, targetX, targetY) {
        if (!this.connected) {
            this.pendingCommands.push(() => this.moveUnits(unitIds, targetX, targetY));
            return;
        }
        
        this.socket.emit('moveUnits', {
            unitIds,
            targetX,
            targetY
        });
    }
    
    /**
     * Process any pending commands
     */
    processPendingCommands() {
        if (!this.connected) return;
        
        while (this.pendingCommands.length > 0) {
            const command = this.pendingCommands.shift();
            command();
        }
    }
    
    /**
     * Update method called each frame
     */
    update(deltaTime) {
        // Interpolate entity positions between server updates
        if (this.connected) {
            const currentTime = Date.now();
            
            this.game.entities.forEach(entity => {
                // Only interpolate units, not buildings
                if (entity.type === 'unit' && entity.serverX !== undefined && entity.serverY !== undefined) {
                    // Calculate interpolation progress
                    const interpolationDuration = 100; // ms, adjust based on server update frequency
                    const timeSinceUpdate = entity.interpolationStartTime ? 
                        currentTime - entity.interpolationStartTime : 0;
                    
                    // Calculate interpolation factor (0 to 1)
                    let t = Math.min(timeSinceUpdate / interpolationDuration, 1.0);
                    
                    // Apply easing function for smoother movement (ease-out)
                    t = 1 - Math.pow(1 - t, 2);
                    
                    // Apply interpolation
                    if (t < 1.0) {
                        // Interpolate between current position and server position
                        entity.x = entity.prevX + (entity.serverX - entity.prevX) * t;
                        entity.y = entity.prevY + (entity.serverY - entity.prevY) * t;
                    } else {
                        // Reached target position
                        entity.x = entity.serverX;
                        entity.y = entity.serverY;
                    }
                    
                    // If unit is not moving, ensure it's exactly at the server position
                    if (!entity.isMoving && t >= 1.0) {
                        entity.x = entity.serverX;
                        entity.y = entity.serverY;
                    }
                }
            });
        }
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\Renderer.js 
======================================== 
 
/**
 * Handles all rendering operations for the game
 */
class Renderer {
    /**
     * Initialize the renderer
     */
    constructor(game) {
        this.game = game;
        this.canvas = game.canvas;
        this.ctx = game.ctx;
        this.camera = game.camera;
        this.map = game.map;
        
        // Isometric tile dimensions
        this.tileWidth = Config.TILE_SIZE;
        this.tileHeight = Config.TILE_SIZE / 2;
        
        // Preload images
        this.preloadImages();
        
        // Track loaded images
        this.imagesLoaded = false;
        this.checkImagesLoaded();
    }
    
    /**
     * Check if all images are loaded
     */
    checkImagesLoaded() {
        // Check if all tile images are loaded
        const allImagesLoaded = Object.values(this.map.tileImages).every(img => img.complete);
        
        if (allImagesLoaded) {
            this.imagesLoaded = true;
            console.log('All images loaded successfully');
        } else {
            // Check again in 100ms
            setTimeout(() => this.checkImagesLoaded(), 100);
        }
    }
    
    /**
     * Preload any additional images needed for rendering
     */
    preloadImages() {
        // Preload unit and building images here if needed
        // For now, we're just using the tile images preloaded by the Map class
    }
    
    /**
     * Clear the canvas
     */
    clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    /**
     * Main render function
     */
    render() {
        this.clear();
        
        // Render map
        this.renderMap();
        
        // Render entities
        this.renderEntities();
        
        // Render UI
        this.renderUI();
    }
    
    /**
     * Convert grid coordinates to screen coordinates
     */
    gridToScreen(col, row) {
        // Convert grid coordinates to isometric world coordinates
        const isoPos = this.map.gridToIso(col, row);
        
        // Convert world coordinates to screen coordinates
        return this.camera.worldToScreen(isoPos.x, isoPos.y);
    }
    
    /**
     * Render the map tiles
     */
    renderMap() {
        // Calculate visible tile range based on camera position and zoom
        // For isometric view, we need a different approach to determine visible tiles
        
        // Convert camera position to grid coordinates
        const cameraWorldPos = {
            x: this.camera.x,
            y: this.camera.y
        };
        
        // Get the viewport dimensions in world coordinates
        const viewportWidth = this.camera.width / this.camera.zoom;
        const viewportHeight = this.camera.height / this.camera.zoom;
        
        // Calculate the viewport corners in world coordinates
        const viewportCorners = [
            { x: cameraWorldPos.x, y: cameraWorldPos.y }, // Top-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y }, // Top-right
            { x: cameraWorldPos.x, y: cameraWorldPos.y + viewportHeight }, // Bottom-left
            { x: cameraWorldPos.x + viewportWidth, y: cameraWorldPos.y + viewportHeight } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Find the min and max grid coordinates that cover the viewport
        let minGridX = Math.floor(Math.min(...gridCorners.map(corner => corner.x)));
        let maxGridX = Math.ceil(Math.max(...gridCorners.map(corner => corner.x)));
        let minGridY = Math.floor(Math.min(...gridCorners.map(corner => corner.y)));
        let maxGridY = Math.ceil(Math.max(...gridCorners.map(corner => corner.y)));
        
        // Add a buffer to ensure we render tiles that are partially visible
        const buffer = 15;
        minGridX = Math.max(0, minGridX - buffer);
        minGridY = Math.max(0, minGridY - buffer);
        maxGridX = Math.min(this.map.width, maxGridX + buffer);
        maxGridY = Math.min(this.map.height, maxGridY + buffer);
        
        // Render tiles in the correct order for isometric view (back to front)
        // This ensures proper overlapping of tiles
        for (let sum = minGridX + minGridY; sum <= maxGridX + maxGridY; sum++) {
            for (let gridX = minGridX; gridX <= maxGridX; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < minGridY || gridY > maxGridY) continue;
                
                // Get the tile at this grid position
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert grid coordinates to isometric world coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Convert world coordinates to screen coordinates
                const screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
                
                // Calculate tile dimensions with zoom
                const tileWidthZoomed = this.tileWidth * this.camera.zoom;
                const tileHeightZoomed = this.tileHeight * this.camera.zoom;
                
                // Draw the tile
                if (this.imagesLoaded) {
                    // Use the appropriate tile image based on terrain type
                    const terrainType = tile.terrainType || tile.type;
                    const tileImage = this.map.getTileImage(terrainType);
                    
                    if (tileImage && tileImage.complete) {
                        // Draw the isometric tile image
                        this.ctx.drawImage(
                            tileImage,
                            screenPos.x - (tileWidthZoomed / 2), // Center the image horizontally
                            screenPos.y - (tileHeightZoomed / 2), // Center the image vertically
                            tileWidthZoomed,
                            tileHeightZoomed
                        );
                    } else {
                        // Fallback to colored diamond if image not loaded
                        this.drawIsometricTile(
                            screenPos.x,
                            screenPos.y,
                            tileWidthZoomed,
                            tileHeightZoomed,
                            this.getTileColor(tile.terrainType || tile.type)
                        );
                    }
                } else {
                    // Fallback to colored diamond if images not loaded yet
                    this.drawIsometricTile(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed,
                        this.getTileColor(tile.terrainType || tile.type)
                    );
                }
                
                // Draw grid lines if enabled
                if (Config.SHOW_GRID) {
                    this.drawIsometricGrid(
                        screenPos.x,
                        screenPos.y,
                        tileWidthZoomed,
                        tileHeightZoomed
                    );
                }
            }
        }
    }
    
    /**
     * Draw an isometric tile (diamond shape)
     */
    drawIsometricTile(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.fill();
    }
    
    /**
     * Draw isometric grid lines
     */
    drawIsometricGrid(x, y, width, height) {
        this.ctx.strokeStyle = Config.COLORS.GRID;
        this.ctx.lineWidth = 1;
        
        // Draw a diamond shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height / 2); // Top point
        this.ctx.lineTo(x + width / 2, y); // Right point
        this.ctx.lineTo(x, y + height / 2); // Bottom point
        this.ctx.lineTo(x - width / 2, y); // Left point
        this.ctx.closePath();
        
        this.ctx.stroke();
    }
    
    /**
     * Get the color for a tile type
     */
    getTileColor(tileType) {
        switch (tileType) {
            case 'grass': return Config.COLORS.GRASS;
            case 'water': return Config.COLORS.WATER;
            case 'sand': return Config.COLORS.SAND;
            case 'mountain': return Config.COLORS.MOUNTAIN;
            case 'forest': return Config.COLORS.FOREST;
            default: return Config.COLORS.GRASS;
        }
    }
    
    /**
     * Render all game entities
     */
    renderEntities() {
        // Sort entities by their y-coordinate for proper depth ordering in isometric view
        const sortedEntities = [...this.game.entities].sort((a, b) => a.y - b.y);
        
        for (const entity of sortedEntities) {
            // Convert entity position to grid coordinates
            const gridX = Math.floor(entity.x / Config.TILE_SIZE);
            const gridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            // Convert grid coordinates to isometric world coordinates
            const isoPos = this.map.gridToIso(gridX, gridY);
            
            // Add debug logging
            console.log(`Entity: ${entity.constructor.name}, Position: (${entity.x}, ${entity.y}), Grid: (${gridX}, ${gridY}), Iso: (${isoPos.x}, ${isoPos.y})`);
            
            // Convert world coordinates to screen coordinates
            const screenPos = this.camera.worldToScreen(isoPos.x, isoPos.y);
            
            // Calculate entity dimensions with zoom
            const entityWidth = entity.width * this.camera.zoom;
            const entityHeight = entity.height * this.camera.zoom;
            
            // Render the entity based on its type
            if (entity instanceof Unit) {
                this.renderUnit(entity, screenPos, entityWidth, entityHeight);
            } else if (entity instanceof Building) {
                this.renderBuilding(entity, screenPos, entityWidth, entityHeight);
            }
        }
    }
    
    /**
     * Render a unit with its image and health bar
     */
    renderUnit(unit, screenPos, width, height) {
        // Debug logging for selection
        if (unit.isSelected) {
            console.log(`Rendering selected unit: ${unit.id}, isPlayerControlled: ${unit.isPlayerControlled}, playerId: ${unit.playerId}, position: (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw unit image if available
        if (unit.image && unit.image.complete) {
            console.log(`Rendering unit image: ${unit.unitType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                unit.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            // Fallback to colored rectangle if image not loaded
            console.log(`Fallback rendering for unit: ${unit.unitType} at (${screenPos.x}, ${screenPos.y})`);
            this.ctx.fillStyle = unit.isPlayerControlled ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
                
            this.ctx.fillRect(
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        }
        
        // Draw selection indicator if unit is selected
        if (unit.isSelected) {
            console.log(`Drawing selection indicator for unit ${unit.id} at (${screenPos.x}, ${screenPos.y}) with radius ${(width / 2) + 5 * this.camera.zoom}`);
            
            // Draw a glowing selection circle around the unit
            this.ctx.strokeStyle = Config.COLORS.SELECTION || '#00ff00';
            this.ctx.lineWidth = 2 * this.camera.zoom;
            
            // Draw circle around unit
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.stroke();
            
            // Add a semi-transparent fill for better visibility
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            this.ctx.beginPath();
            this.ctx.arc(
                screenPos.x,
                screenPos.y,
                (width / 2) + 5 * this.camera.zoom,
                0,
                Math.PI * 2
            );
            this.ctx.fill();
            
            console.log(`Selection indicator drawn with color ${Config.COLORS.SELECTION}`);
        }
        
        // Draw health bar
        const healthBarWidth = width;
        const healthBarHeight = 4 * this.camera.zoom;
        const healthPercentage = unit.health / unit.maxHealth;
        
        // Health bar background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health bar fill
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Draw level indicator if level > 1
        if (unit.level > 1) {
            this.ctx.fillStyle = 'white';
            this.ctx.font = `${10 * this.camera.zoom}px Arial`;
            this.ctx.textAlign = 'center';
            this.ctx.fillText(
                unit.level.toString(),
                screenPos.x,
                screenPos.y + height / 2 + 12 * this.camera.zoom
            );
        }
    }
    
    /**
     * Render a building with its image and health bar
     */
    renderBuilding(building, screenPos, width, height) {
        // Always draw a solid base rectangle first
        this.ctx.fillStyle = building.playerColor === 'red' ? 
            '#ff0000' : building.playerColor === 'blue' ? 
            '#0000ff' : '#888888';
            
        // Draw an isometric building base
        this.drawIsometricBuilding(
            screenPos.x,
            screenPos.y,
            width,
            height / 2, // Half height for isometric look
            this.ctx.fillStyle
        );
        
        // Draw building image if available
        if (building.image && building.image.complete) {
            // For isometric view, we need to adjust the image position
            console.log(`Rendering building image: ${building.buildingType} at (${screenPos.x}, ${screenPos.y}), size: ${width}x${height}`);
            this.ctx.drawImage(
                building.image,
                screenPos.x - width / 2,
                screenPos.y - height / 2,
                width,
                height
            );
        } else {
            console.log(`Fallback rendering for building: ${building.buildingType} at (${screenPos.x}, ${screenPos.y})`);
        }
        
        // Draw health bar
        const healthPercentage = building.health / building.maxHealth;
        const healthBarWidth = width;
        const healthBarHeight = 5 * this.camera.zoom;
        
        // Background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth,
            healthBarHeight
        );
        
        // Health
        this.ctx.fillStyle = this.getHealthColor(healthPercentage);
        this.ctx.fillRect(
            screenPos.x - width / 2,
            screenPos.y - height / 2 - healthBarHeight - 2,
            healthBarWidth * healthPercentage,
            healthBarHeight
        );
        
        // Determine the label based on player color
        let baseLabel = building.buildingType;
        if (building.buildingType === 'BASE') {
            baseLabel = building.playerColor === 'blue' ? 'Human Base' : 'AI Base';
        }
        
        // Draw building type text
        this.ctx.fillStyle = '#ffffff';
        this.ctx.font = `${12 * this.camera.zoom}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(
            baseLabel,
            screenPos.x,
            screenPos.y
        );
    }
    
    /**
     * Draw an isometric building
     */
    drawIsometricBuilding(x, y, width, height, color) {
        this.ctx.fillStyle = color;
        
        // Draw a 3D isometric building
        // Top face (roof)
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - height); // Top point
        this.ctx.lineTo(x + width / 2, y - height / 2); // Right point
        this.ctx.lineTo(x, y); // Bottom point
        this.ctx.lineTo(x - width / 2, y - height / 2); // Left point
        this.ctx.closePath();
        this.ctx.fill();
        
        // Right face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-left
        this.ctx.lineTo(x + width / 2, y - height / 2); // Top-right
        this.ctx.lineTo(x + width / 2, y + height / 2); // Bottom-right
        this.ctx.lineTo(x, y + height); // Bottom-left
        this.ctx.closePath();
        // Darken the right face
        this.ctx.fillStyle = this.darkenColor(color, 0.7);
        this.ctx.fill();
        
        // Left face
        this.ctx.beginPath();
        this.ctx.moveTo(x, y); // Top-right
        this.ctx.lineTo(x - width / 2, y - height / 2); // Top-left
        this.ctx.lineTo(x - width / 2, y + height / 2); // Bottom-left
        this.ctx.lineTo(x, y + height); // Bottom-right
        this.ctx.closePath();
        // Darken the left face more
        this.ctx.fillStyle = this.darkenColor(color, 0.5);
        this.ctx.fill();
    }
    
    /**
     * Darken a color by a factor
     */
    darkenColor(color, factor) {
        // Convert hex to RGB
        let r, g, b;
        if (color.startsWith('#')) {
            const hex = color.substring(1);
            r = parseInt(hex.substring(0, 2), 16);
            g = parseInt(hex.substring(2, 4), 16);
            b = parseInt(hex.substring(4, 6), 16);
        } else if (color.startsWith('rgb')) {
            const match = color.match(/\d+/g);
            r = parseInt(match[0]);
            g = parseInt(match[1]);
            b = parseInt(match[2]);
        } else {
            return color; // Can't darken
        }
        
        // Darken
        r = Math.floor(r * factor);
        g = Math.floor(g * factor);
        b = Math.floor(b * factor);
        
        // Convert back to hex
        return `rgb(${r}, ${g}, ${b})`;
    }
    
    /**
     * Get color for health bar based on percentage
     */
    getHealthColor(percentage) {
        if (percentage > 0.6) {
            return 'rgb(0, 255, 0)'; // Green
        } else if (percentage > 0.3) {
            return 'rgb(255, 255, 0)'; // Yellow
        } else {
            return 'rgb(255, 0, 0)'; // Red
        }
    }
    
    /**
     * Render UI elements
     */
    renderUI() {
        // Render selection box if dragging
        const selectionBox = this.game.inputHandler.getSelectionBox();
        if (selectionBox) {
            this.ctx.strokeStyle = Config.COLORS.SELECTION;
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
            
            // Semi-transparent fill
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            this.ctx.fillRect(
                selectionBox.x,
                selectionBox.y,
                selectionBox.width,
                selectionBox.height
            );
        }
        
        // Render minimap
        this.renderMinimap();
        
        // Render selected unit info
        this.renderSelectedUnitInfo();
    }
    
    /**
     * Render the minimap
     */
    renderMinimap() {
        const minimapElement = document.getElementById('minimap');
        if (!minimapElement) return;
        
        // Create a canvas for the minimap if it doesn't exist
        if (!this.minimapCanvas) {
            this.minimapCanvas = document.createElement('canvas');
            this.minimapCanvas.width = 180; // Slightly smaller than the container
            this.minimapCanvas.height = 180;
            this.minimapCtx = this.minimapCanvas.getContext('2d');
            minimapElement.appendChild(this.minimapCanvas);
        }
        
        // Clear the minimap
        this.minimapCtx.clearRect(0, 0, this.minimapCanvas.width, this.minimapCanvas.height);
        
        // Calculate the isometric map dimensions
        const isoMapWidth = (this.map.width + this.map.height) * (Config.TILE_SIZE / 2);
        const isoMapHeight = (this.map.width + this.map.height) * (Config.TILE_SIZE / 4);
        
        // Calculate scale factors for the minimap
        const scaleX = this.minimapCanvas.width / isoMapWidth;
        const scaleY = this.minimapCanvas.height / isoMapHeight;
        
        // Use the smaller scale to maintain aspect ratio
        const scale = Math.min(scaleX, scaleY) * 0.8; // 80% to leave some margin
        
        // Calculate offsets to center the map in the minimap
        const offsetX = this.minimapCanvas.width / 2;
        const offsetY = this.minimapCanvas.height / 4;
        
        // Draw map tiles on minimap
        // Render in the correct order for isometric view (back to front)
        for (let sum = 0; sum < this.map.width + this.map.height; sum++) {
            for (let gridX = 0; gridX < this.map.width; gridX++) {
                const gridY = sum - gridX;
                
                if (gridY < 0 || gridY >= this.map.height) continue;
                
                const tile = this.map.getTile(gridX, gridY);
                if (!tile) continue;
                
                // Convert to isometric coordinates
                const isoPos = this.map.gridToIso(gridX, gridY);
                
                // Scale and position for minimap
                const x = offsetX + isoPos.x * scale;
                const y = offsetY + isoPos.y * scale;
                
                // Draw a small diamond for each tile
                this.minimapCtx.fillStyle = this.getTileColor(tile.terrainType || tile.type);
                this.minimapCtx.beginPath();
                this.minimapCtx.moveTo(x, y - 2); // Top
                this.minimapCtx.lineTo(x + 2, y); // Right
                this.minimapCtx.lineTo(x, y + 2); // Bottom
                this.minimapCtx.lineTo(x - 2, y); // Left
                this.minimapCtx.closePath();
                this.minimapCtx.fill();
            }
        }
        
        // Draw entities on minimap
        for (const entity of this.game.entities) {
            // Convert entity position to grid coordinates
            const gridX = Math.floor(entity.x / Config.TILE_SIZE);
            const gridY = Math.floor(entity.y / Config.TILE_SIZE);
            
            // Convert to isometric coordinates
            const isoPos = this.map.gridToIso(gridX, gridY);
            
            // Scale and position for minimap
            const x = offsetX + isoPos.x * scale;
            const y = offsetY + isoPos.y * scale;
            
            // Draw a dot for each entity
            this.minimapCtx.fillStyle = entity.playerColor === 'blue' ? 
                Config.COLORS.PLAYER_UNIT : Config.COLORS.ENEMY_UNIT;
            
            this.minimapCtx.beginPath();
            this.minimapCtx.arc(x, y, 2, 0, Math.PI * 2);
            this.minimapCtx.fill();
        }
        
        // Draw camera viewport rectangle
        // Calculate the four corners of the viewport in world coordinates
        const viewportCorners = [
            { x: this.camera.x, y: this.camera.y }, // Top-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y }, // Top-right
            { x: this.camera.x, y: this.camera.y + this.camera.height / this.camera.zoom }, // Bottom-left
            { x: this.camera.x + this.camera.width / this.camera.zoom, y: this.camera.y + this.camera.height / this.camera.zoom } // Bottom-right
        ];
        
        // Convert viewport corners to grid coordinates
        const gridCorners = viewportCorners.map(corner => this.map.isoToGrid(corner.x, corner.y));
        
        // Convert back to isometric for minimap and scale
        const minimapCorners = gridCorners.map(gridPos => {
            const isoPos = this.map.gridToIso(gridPos.x, gridPos.y);
            return {
                x: offsetX + isoPos.x * scale,
                y: offsetY + isoPos.y * scale
            };
        });
        
        // Draw viewport outline
        this.minimapCtx.strokeStyle = 'white';
        this.minimapCtx.lineWidth = 1.5;
        this.minimapCtx.beginPath();
        this.minimapCtx.moveTo(minimapCorners[0].x, minimapCorners[0].y);
        this.minimapCtx.lineTo(minimapCorners[1].x, minimapCorners[1].y);
        this.minimapCtx.lineTo(minimapCorners[3].x, minimapCorners[3].y);
        this.minimapCtx.lineTo(minimapCorners[2].x, minimapCorners[2].y);
        this.minimapCtx.closePath();
        this.minimapCtx.stroke();
    }
    
    /**
     * Render information about selected units
     */
    renderSelectedUnitInfo() {
        const selectedUnits = this.game.entities.filter(e => e.isSelected && e instanceof Unit);
        
        if (selectedUnits.length === 0) {
            return;
        }
        
        // Only show info for the first selected unit
        const unit = selectedUnits[0];
        const padding = 10;
        const lineHeight = 20;
        
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(
            this.canvas.width - 200 - padding,
            padding,
            200,
            150
        );
        
        this.ctx.fillStyle = 'white';
        this.ctx.font = '14px Arial';
        this.ctx.textAlign = 'left';
        
        let y = padding + lineHeight;
        
        this.ctx.fillText(`Unit Type: ${unit.unitType}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Level: ${unit.level}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Health: ${unit.health}/${unit.maxHealth}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Attack: ${unit.attackDamage}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Range: ${unit.attackRange}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        this.ctx.fillText(`Speed: ${unit.speed}`, this.canvas.width - 190, y);
        y += lineHeight;
        
        if (unit.level < 10) { // Max level cap
            const expNeeded = unit.level * 100;
            this.ctx.fillText(`XP: ${unit.experience}/${expNeeded}`, this.canvas.width - 190, y);
        }
    }
    
    /**
     * Render debug information
     */
    renderDebugInfo() {
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px Arial';
        this.ctx.textAlign = 'left';
        
        // Display FPS
        this.ctx.fillText(`FPS: ${this.game.fps.toFixed(1)}`, 10, 20);
        
        // Display camera position
        this.ctx.fillText(`Camera: (${this.camera.x.toFixed(0)}, ${this.camera.y.toFixed(0)})`, 10, 40);
        
        // Display zoom level
        this.ctx.fillText(`Zoom: ${(this.camera.zoom * 100).toFixed(0)}%`, 10, 60);
        
        // Display entity count
        this.ctx.fillText(`Entities: ${this.game.entities.length}`, 10, 80);
        
        // Display selected entities count
        const selectedCount = this.game.entities.filter(e => e.isSelected).length;
        this.ctx.fillText(`Selected: ${selectedCount}`, 10, 100);
        
        // Display isometric rendering info
        this.ctx.fillText(`Isometric Mode: Active`, 10, 120);
    }
    
    /**
     * Handle window resize
     */
    handleResize() {
        this.canvas.width = Config.CANVAS_WIDTH;
        this.canvas.height = Config.CANVAS_HEIGHT;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\game\UnitImageLoader.js 
======================================== 
 
/**
 * Handles loading and managing unit images
 */
class UnitImageLoader {
    /**
     * Initialize the unit image loader
     */
    constructor() {
        // Unit types
        this.unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];
        
        // Store loaded images
        this.images = {};
        
        // Load all unit images
        this.loadUnitImages();
        
        console.log('UnitImageLoader initialized');
    }
    
    /**
     * Load all unit images
     */
    loadUnitImages() {
        this.unitTypes.forEach(unitType => {
            const img = new Image();
            img.src = `/images/units/${unitType.toLowerCase()}.png`;
            this.images[unitType] = img;
            
            // Log when image loads or fails
            img.onload = () => console.log(`Loaded unit image: ${unitType}`);
            img.onerror = () => console.warn(`Failed to load unit image: ${unitType}`);
        });
    }
    
    /**
     * Get the image for a specific unit type
     */
    getUnitImage(unitType) {
        return this.images[unitType] || null;
    }
    
    /**
     * Check if all images are loaded
     */
    areAllImagesLoaded() {
        return Object.values(this.images).every(img => img.complete);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Map.js 
======================================== 
 
/**
 * Manages the game map
 */
class Map {
    /**
     * Initialize the map
     */
    constructor() {
        this.width = Config.MAP_WIDTH;
        this.height = Config.MAP_HEIGHT;
        this.tiles = [];
        
        // Initialize with empty tiles
        this.initializeEmptyTiles();
        
        // Preload tile images
        this.tileImages = {};
        this.preloadTileImages();
    }
    
    /**
     * Preload tile images for different terrain types
     */
    preloadTileImages() {
        const terrainTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        terrainTypes.forEach(terrainType => {
            const img = new Image();
            img.src = `/images/terraintiles/${terrainType}.png`;
            this.tileImages[terrainType] = img;
        });
    }
    
    /**
     * Initialize empty tiles
     */
    initializeEmptyTiles() {
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                // Initialize with grass tiles as a fallback
                this.tiles[y][x] = new Tile('grass');
            }
        }
        console.log('Initialized empty map');
    }
    
    /**
     * Set the map data from the server
     */
    setMapFromServer(mapData) {
        console.log('Received map data from server', mapData ? 'valid' : 'invalid');
        
        if (!mapData || !Array.isArray(mapData) || mapData.length === 0) {
            console.error('Invalid map data from server');
            return;
        }
        
        this.height = mapData.length;
        this.width = mapData[0].length;
        
        console.log(`Setting map from server data: ${this.width}x${this.height}`);
        
        // Convert server map data to our tile format
        this.tiles = new Array(this.height);
        for (let y = 0; y < this.height; y++) {
            this.tiles[y] = new Array(this.width);
            for (let x = 0; x < this.width; x++) {
                if (!mapData[y] || !mapData[y][x]) {
                    console.error(`Missing tile data at ${x},${y}`);
                    this.tiles[y][x] = new Tile('grass');
                    continue;
                }
                
                const serverTile = mapData[y][x];
                // Use terrainType if available, fall back to type for backward compatibility
                const terrainType = serverTile.terrainType || serverTile.type || 'grass';
                this.tiles[y][x] = new Tile(terrainType);
                
                // Use passable if available, fall back to walkable for backward compatibility
                this.tiles[y][x].walkable = serverTile.passable !== undefined ? 
                    serverTile.passable : 
                    (serverTile.walkable !== undefined ? 
                        serverTile.walkable : 
                        (terrainType !== 'water' && terrainType !== 'mountain'));
                
                // Store elevation if available
                if (serverTile.elevation !== undefined) {
                    this.tiles[y][x].elevation = serverTile.elevation;
                }
            }
        }
        
        console.log('Map set from server data');
    }
    
    /**
     * Get the tile at the specified coordinates
     */
    getTile(x, y) {
        // Check bounds
        if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
            return null;
        }
        
        // Check if tiles array is properly initialized
        if (!this.tiles || !this.tiles[y] || !this.tiles[y][x]) {
            console.warn(`Tile at ${x},${y} is not initialized`);
            return new Tile('grass'); // Return a default tile
        }
        
        return this.tiles[y][x];
    }
    
    /**
     * Get the tile image for a specific terrain type
     */
    getTileImage(terrainType) {
        return this.tileImages[terrainType] || this.tileImages['grass'];
    }
    
    /**
     * Convert grid coordinates to isometric world coordinates
     */
    gridToIso(x, y) {
        return {
            x: (x - y) * (Config.TILE_SIZE / 2),
            y: (x + y) * (Config.TILE_SIZE / 4)
        };
    }
    
    /**
     * Convert isometric world coordinates to grid coordinates
     */
    isoToGrid(x, y) {
        const tileHalfWidth = Config.TILE_SIZE / 2;
        const tileQuarterHeight = Config.TILE_SIZE / 4;
        
        return {
            x: Math.floor((x / tileHalfWidth + y / tileQuarterHeight) / 2),
            y: Math.floor((y / tileQuarterHeight - x / tileHalfWidth) / 2)
        };
    }
    
    /**
     * Check if a tile is walkable
     */
    isWalkable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.walkable;
    }
    
    /**
     * Check if a tile is buildable
     */
    isBuildable(x, y) {
        const tile = this.getTile(x, y);
        return tile && tile.buildable;
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\map\Tile.js 
======================================== 
 
/**
 * Represents a single tile on the game map
 */
class Tile {
    /**
     * Initialize a tile
     */
    constructor(terrainType = 'grass') {
        // Ensure valid tile type
        this.type = this.validateTerrainType(terrainType);
        this.terrainType = this.type; // For consistency with server data
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
        this.resourceType = this.getResourceType(this.type);
        this.resourceAmount = this.resourceType ? Math.floor(Math.random() * 500) + 500 : 0;
        this.elevation = 0; // Default elevation
    }
    
    /**
     * Validate and normalize terrain type
     */
    validateTerrainType(type) {
        const validTypes = ['grass', 'water', 'mountain', 'forest', 'sand'];
        
        if (!type || typeof type !== 'string') {
            console.warn(`Invalid tile type: ${type}, defaulting to grass`);
            return 'grass';
        }
        
        const normalizedType = type.toLowerCase();
        
        if (!validTypes.includes(normalizedType)) {
            console.warn(`Unknown tile type: ${normalizedType}, defaulting to grass`);
            return 'grass';
        }
        
        return normalizedType;
    }
    
    /**
     * Determine if a tile type is walkable
     */
    isWalkable(type) {
        switch (type) {
            case 'water':
            case 'mountain':
                return false;
            case 'grass':
            case 'sand':
            case 'forest':
                return true;
            default:
                return true;
        }
    }
    
    /**
     * Determine if a tile type is buildable
     */
    isBuildable(type) {
        switch (type) {
            case 'grass':
            case 'sand':
                return true;
            case 'water':
            case 'mountain':
            case 'forest':
                return false;
            default:
                return false;
        }
    }
    
    /**
     * Get resource type for a tile if applicable
     */
    getResourceType(type) {
        switch (type) {
            case 'forest':
                return 'wood';
            case 'mountain':
                return 'stone';
            default:
                return null;
        }
    }
    
    /**
     * Extract resources from the tile
     */
    extractResource(amount) {
        if (!this.resourceType || this.resourceAmount <= 0) {
            return 0;
        }
        
        const extracted = Math.min(amount, this.resourceAmount);
        this.resourceAmount -= extracted;
        
        // If resources are depleted, change the tile type
        if (this.resourceAmount <= 0) {
            this.depleteResource();
        }
        
        return extracted;
    }
    
    /**
     * Handle resource depletion
     */
    depleteResource() {
        switch (this.resourceType) {
            case 'wood':
                this.type = 'grass';
                this.terrainType = 'grass';
                break;
            case 'stone':
                this.type = 'mountain';
                this.terrainType = 'mountain';
                break;
            default:
                break;
        }
        
        this.resourceType = null;
        this.resourceAmount = 0;
        this.walkable = this.isWalkable(this.type);
        this.buildable = this.isBuildable(this.type);
    }
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateDetailedImages.js 
======================================== 
 
/**
 * Script to generate detailed images for units and buildings
 * This creates visually appealing assets for the game
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

/**
 * Generate a detailed unit image
 */
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Generate a detailed building image
 */
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

/**
 * Helper function to draw an isometric building
 */
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

/**
 * Helper function to darken a color
 */
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

/**
 * Function to save an image
 */
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

/**
 * Generate and save unit images
 */
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

/**
 * Generate and save building images
 */
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating detailed images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: public/images/units/');
console.log('   - Building images: public/images/buildings/');
console.log('2. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generateImages.js 
======================================== 
 
const fs = require('fs');
const path = require('path');
const { createCanvas } = require('canvas');

// Create directories if they don't exist
const unitsDir = path.join(__dirname, '../../public/images/units');
const buildingsDir = path.join(__dirname, '../../public/images/buildings');

if (!fs.existsSync(unitsDir)) {
    fs.mkdirSync(unitsDir, { recursive: true });
}

if (!fs.existsSync(buildingsDir)) {
    fs.mkdirSync(buildingsDir, { recursive: true });
}

// Create a canvas
const canvas = createCanvas(64, 64);
const ctx = canvas.getContext('2d');

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different unit types
    let primaryColor, secondaryColor, detailColor;
    
    switch(unitType) {
        case 'SOLDIER':
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
            break;
        case 'ARCHER':
            primaryColor = '#33cc33';
            secondaryColor = '#1a661a';
            detailColor = '#99ff99';
            break;
        case 'CAVALRY':
            primaryColor = '#cc3333';
            secondaryColor = '#661a1a';
            detailColor = '#ff9999';
            break;
        case 'TANK':
            primaryColor = '#666666';
            secondaryColor = '#333333';
            detailColor = '#cccccc';
            break;
        case 'WORKER':
            primaryColor = '#cc9933';
            secondaryColor = '#664d1a';
            detailColor = '#ffcc99';
            break;
        default:
            primaryColor = '#3366cc';
            secondaryColor = '#1a3366';
            detailColor = '#99ccff';
    }
    
    // Draw isometric unit base
    ctx.fillStyle = primaryColor;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(width/2, height/4); // Top
    ctx.lineTo(3*width/4, height/2); // Right
    ctx.lineTo(width/2, 3*height/4); // Bottom
    ctx.lineTo(width/4, height/2); // Left
    ctx.closePath();
    ctx.fill();
    
    // Draw unit details based on type
    switch(unitType) {
        case 'SOLDIER':
            // Draw helmet
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw sword
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 8, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.stroke();
            break;
            
        case 'ARCHER':
            // Draw hood
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw bow
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(width/2 + 10, height/2, 8, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            
            // Draw arrow
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2);
            ctx.stroke();
            break;
            
        case 'CAVALRY':
            // Draw horse body
            ctx.fillStyle = secondaryColor;
            ctx.beginPath();
            ctx.ellipse(width/2, height/2 + 5, 15, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw rider
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw lance
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 15);
            ctx.stroke();
            break;
            
        case 'TANK':
            // Draw tank body
            ctx.fillStyle = secondaryColor;
            ctx.fillRect(width/2 - 15, height/2, 30, 15);
            
            // Draw tank turret
            ctx.fillStyle = primaryColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw tank cannon
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 5);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
            
        case 'WORKER':
            // Draw hard hat
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw body
            ctx.fillStyle = primaryColor;
            ctx.fillRect(width/2 - 5, height/2, 10, 15);
            
            // Draw pickaxe
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 + 5, height/2);
            ctx.lineTo(width/2 + 15, height/2 - 10);
            ctx.lineTo(width/2 + 20, height/2 - 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set dimensions
    const width = canvas.width;
    const height = canvas.height;
    
    // Base colors for different building types
    let baseColor, roofColor, detailColor;
    
    switch(buildingType) {
        case 'BASE':
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
            break;
        case 'BARRACKS':
            baseColor = '#996666';
            roofColor = '#663333';
            detailColor = '#cc9999';
            break;
        case 'TOWER':
            baseColor = '#669966';
            roofColor = '#336633';
            detailColor = '#99cc99';
            break;
        case 'FARM':
            baseColor = '#999966';
            roofColor = '#666633';
            detailColor = '#cccc99';
            break;
        case 'MINE':
            baseColor = '#666666';
            roofColor = '#333333';
            detailColor = '#999999';
            break;
        default:
            baseColor = '#666699';
            roofColor = '#333366';
            detailColor = '#9999cc';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red':
                baseColor = '#cc3333';
                roofColor = '#661a1a';
                detailColor = '#ff9999';
                break;
            case 'blue':
                baseColor = '#3366cc';
                roofColor = '#1a3366';
                detailColor = '#99ccff';
                break;
            case 'green':
                baseColor = '#33cc33';
                roofColor = '#1a661a';
                detailColor = '#99ff99';
                break;
            case 'yellow':
                baseColor = '#cccc33';
                roofColor = '#66661a';
                detailColor = '#ffff99';
                break;
        }
    }
    
    // Draw isometric building based on type
    switch(buildingType) {
        case 'BASE':
            // Draw main building (castle-like)
            drawIsometricBuilding(width/2, height/2, 40, 30, baseColor, roofColor);
            
            // Draw towers at corners
            drawIsometricBuilding(width/2 - 15, height/2 - 10, 10, 20, baseColor, roofColor);
            drawIsometricBuilding(width/2 + 15, height/2 - 10, 10, 20, baseColor, roofColor);
            
            // Draw flag on top
            ctx.fillStyle = playerColor || detailColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 25);
            ctx.lineTo(width/2 + 10, height/2 - 20);
            ctx.lineTo(width/2, height/2 - 15);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 'BARRACKS':
            // Draw main building
            drawIsometricBuilding(width/2, height/2, 40, 20, baseColor, roofColor);
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 + 5, height/2 + 2);
            ctx.lineTo(width/2 + 5, height/2 + 10);
            ctx.lineTo(width/2, height/2 + 13);
            ctx.closePath();
            ctx.fill();
            
            // Draw crossed swords emblem
            ctx.strokeStyle = detailColor;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 - 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.moveTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2 - 10, height/2 + 5);
            ctx.stroke();
            break;
            
        case 'TOWER':
            // Draw tower base
            drawIsometricBuilding(width/2, height/2 + 5, 20, 30, baseColor, roofColor);
            
            // Draw tower top (pointed roof)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(width/2, height/2 - 20);
            ctx.lineTo(width/2 + 10, height/2 - 5);
            ctx.lineTo(width/2, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 - 5);
            ctx.closePath();
            ctx.fill();
            
            // Draw windows
            ctx.fillStyle = detailColor;
            ctx.beginPath();
            ctx.arc(width/2, height/2 - 5, 3, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 'FARM':
            // Draw main building (barn-like)
            drawIsometricBuilding(width/2, height/2, 35, 20, baseColor, roofColor);
            
            // Draw field
            ctx.fillStyle = '#cccc00';
            ctx.beginPath();
            ctx.moveTo(width/2 - 20, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 2);
            ctx.lineTo(width/2 + 10, height/2 + 10);
            ctx.lineTo(width/2 - 5, height/2 + 18);
            ctx.closePath();
            ctx.fill();
            
            // Draw crop rows
            ctx.strokeStyle = '#666600';
            ctx.lineWidth = 1;
            for (let i = -15; i <= 5; i += 5) {
                ctx.beginPath();
                ctx.moveTo(width/2 + i, height/2 + 5 + i/2);
                ctx.lineTo(width/2 + i + 15, height/2 + 5 + i/2 + 7.5);
                ctx.stroke();
            }
            break;
            
        case 'MINE':
            // Draw mine entrance (mountain-like)
            ctx.fillStyle = '#666666';
            ctx.beginPath();
            ctx.moveTo(width/2, height/4);
            ctx.lineTo(3*width/4, height/2);
            ctx.lineTo(width/2, 3*height/4);
            ctx.lineTo(width/4, height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw entrance
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.closePath();
            ctx.fill();
            
            // Draw support beams
            ctx.strokeStyle = '#996633';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 - 10, height/2 + 15);
            ctx.moveTo(width/2 + 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 15);
            ctx.moveTo(width/2 - 10, height/2 + 5);
            ctx.lineTo(width/2 + 10, height/2 + 5);
            ctx.stroke();
            break;
    }
    
    // Return the canvas
    return canvas;
}

// Helper function to draw an isometric building
function drawIsometricBuilding(x, y, width, height, baseColor, roofColor) {
    // Calculate dimensions
    const halfWidth = width / 2;
    const halfHeight = height / 2;
    const roofHeight = height / 3;
    
    // Draw roof (top face)
    ctx.fillStyle = roofColor;
    ctx.beginPath();
    ctx.moveTo(x, y - halfHeight - roofHeight);
    ctx.lineTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x - halfWidth, y - halfHeight);
    ctx.closePath();
    ctx.fill();
    
    // Draw right face
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(x + halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x + halfWidth, y);
    ctx.closePath();
    ctx.fill();
    
    // Draw left face
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(x - halfWidth, y - halfHeight);
    ctx.lineTo(x, y - halfHeight + halfWidth);
    ctx.lineTo(x, y + halfHeight);
    ctx.lineTo(x - halfWidth, y);
    ctx.closePath();
    ctx.fill();
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(canvas, filename) {
    const buffer = canvas.toBuffer('image/png');
    fs.writeFileSync(filename, buffer);
    console.log(`Generated: ${filename}`);
}

// Generate and save unit images
function generateUnitImages() {
    console.log('Generating unit images...');
    
    unitTypes.forEach(unitType => {
        const canvas = generateUnitImage(unitType);
        const filename = path.join(unitsDir, `${unitType.toLowerCase()}.png`);
        saveImage(canvas, filename);
    });
    
    console.log('Unit image generation complete!');
}

// Generate and save building images
function generateBuildingImages() {
    console.log('Generating building images...');
    
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const canvas = generateBuildingImage(buildingType);
        const filename = path.join(buildingsDir, `${buildingType.toLowerCase()}.png`);
        saveImage(canvas, filename);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredCanvas = generateBuildingImage(buildingType, color);
            const coloredFilename = path.join(buildingsDir, `${buildingType.toLowerCase()}_${color}.png`);
            saveImage(coloredCanvas, coloredFilename);
        });
    });
    
    console.log('Building image generation complete!');
}

// Generate all images
function generateAllImages() {
    generateUnitImages();
    generateBuildingImages();
}

// Run the generator
generateAllImages();  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\tools\generatePlaceholderImages.js 
======================================== 
 
/**
 * Script to generate placeholder images for units and buildings
 * Run this script to create basic placeholder images until proper assets are available
 */

// Create a canvas element
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// Set canvas dimensions
canvas.width = 64;
canvas.height = 64;

// Unit types to generate
const unitTypes = ['SOLDIER', 'ARCHER', 'CAVALRY', 'TANK', 'WORKER'];

// Building types to generate
const buildingTypes = ['BASE', 'BARRACKS', 'TOWER', 'FARM', 'MINE'];

// Player colors
const playerColors = ['red', 'blue', 'green', 'yellow'];

// Function to generate a unit image
function generateUnitImage(unitType) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set background color based on unit type
    let color;
    switch(unitType) {
        case 'SOLDIER': color = '#3366cc'; break;
        case 'ARCHER': color = '#33cc33'; break;
        case 'CAVALRY': color = '#cc3333'; break;
        case 'TANK': color = '#666666'; break;
        case 'WORKER': color = '#cc9933'; break;
        default: color = '#3366cc';
    }
    
    // Draw isometric unit shape
    ctx.fillStyle = color;
    
    // Draw a diamond shape for the base
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Add details based on unit type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add unit type initial
    ctx.fillText(unitType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Function to generate a building image
function generateBuildingImage(buildingType, playerColor = null) {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Set base color based on building type
    let baseColor;
    switch(buildingType) {
        case 'BASE': baseColor = '#666699'; break;
        case 'BARRACKS': baseColor = '#996666'; break;
        case 'TOWER': baseColor = '#669966'; break;
        case 'FARM': baseColor = '#999966'; break;
        case 'MINE': baseColor = '#666666'; break;
        default: baseColor = '#666699';
    }
    
    // Apply player color if provided
    if (playerColor) {
        switch(playerColor) {
            case 'red': baseColor = '#cc3333'; break;
            case 'blue': baseColor = '#3366cc'; break;
            case 'green': baseColor = '#33cc33'; break;
            case 'yellow': baseColor = '#cccc33'; break;
        }
    }
    
    // Draw isometric building
    // Base
    ctx.fillStyle = baseColor;
    ctx.beginPath();
    ctx.moveTo(32, 16); // Top
    ctx.lineTo(48, 32); // Right
    ctx.lineTo(32, 48); // Bottom
    ctx.lineTo(16, 32); // Left
    ctx.closePath();
    ctx.fill();
    
    // Right face (darker)
    ctx.fillStyle = darkenColor(baseColor, 0.7);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(48, 32); // Right middle
    ctx.lineTo(48, 40); // Right bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Left face (darkest)
    ctx.fillStyle = darkenColor(baseColor, 0.5);
    ctx.beginPath();
    ctx.moveTo(32, 48); // Bottom center
    ctx.lineTo(16, 32); // Left middle
    ctx.lineTo(16, 40); // Left bottom
    ctx.lineTo(32, 56); // Bottom
    ctx.closePath();
    ctx.fill();
    
    // Add details based on building type
    ctx.fillStyle = '#ffffff';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Add building type initial
    ctx.fillText(buildingType.charAt(0), 32, 32);
    
    // Return the image data URL
    return canvas.toDataURL('image/png');
}

// Helper function to darken a color
function darkenColor(color, factor) {
    // Convert hex to RGB
    let r, g, b;
    if (color.startsWith('#')) {
        const hex = color.substring(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    } else {
        return color; // Can't darken
    }
    
    // Darken
    r = Math.floor(r * factor);
    g = Math.floor(g * factor);
    b = Math.floor(b * factor);
    
    // Convert back to hex
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

// Function to save an image
function saveImage(dataUrl, filename) {
    const link = document.createElement('a');
    link.href = dataUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// Generate and save unit images
function generateUnitImages() {
    unitTypes.forEach(unitType => {
        const imageData = generateUnitImage(unitType);
        saveImage(imageData, `${unitType.toLowerCase()}.png`);
        console.log(`Generated unit image: ${unitType.toLowerCase()}.png`);
    });
}

// Generate and save building images
function generateBuildingImages() {
    buildingTypes.forEach(buildingType => {
        // Generate default building image
        const imageData = generateBuildingImage(buildingType);
        saveImage(imageData, `${buildingType.toLowerCase()}.png`);
        console.log(`Generated building image: ${buildingType.toLowerCase()}.png`);
        
        // Generate player-colored variants
        playerColors.forEach(color => {
            const coloredImageData = generateBuildingImage(buildingType, color);
            saveImage(coloredImageData, `${buildingType.toLowerCase()}_${color}.png`);
            console.log(`Generated building image: ${buildingType.toLowerCase()}_${color}.png`);
        });
    });
}

// Run the generation functions
console.log('Generating placeholder images...');
generateUnitImages();
generateBuildingImages();
console.log('Image generation complete!');

// Instructions for use
console.log('\nInstructions:');
console.log('1. Save these images to your assets folder:');
console.log('   - Unit images: assets/units/');
console.log('   - Building images: assets/buildings/');
console.log('2. Make sure the folder structure exists');
console.log('3. The game will automatically use these images');  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\src\utils\helpers.js 
======================================== 
 
/**
 * Utility functions for the game
 */

/**
 * Calculate distance between two points
 */
function distance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Clamp a value between min and max
 */
function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
}

/**
 * Linear interpolation between two values
 */
function lerp(a, b, t) {
    return a + (b - a) * t;
}

/**
 * Generate a random integer between min and max (inclusive)
 */
function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Check if a point is inside a rectangle
 */
function pointInRect(px, py, rx, ry, rw, rh) {
    return px >= rx && px <= rx + rw && py >= ry && py <= ry + rh;
}

/**
 * Check if two rectangles overlap
 */
function rectOverlap(r1x, r1y, r1w, r1h, r2x, r2y, r2w, r2h) {
    return (
        r1x < r2x + r2w &&
        r1x + r1w > r2x &&
        r1y < r2y + r2h &&
        r1y + r1h > r2y
    );
}

/**
 * Convert degrees to radians
 */
function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

/**
 * Convert radians to degrees
 */
function radToDeg(radians) {
    return radians * 180 / Math.PI;
}

/**
 * Calculate the angle between two points (in radians)
 */
function angleBetweenPoints(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
}

/**
 * Get a point on a circle given center, radius, and angle
 */
function pointOnCircle(centerX, centerY, radius, angleRadians) {
    return {
        x: centerX + radius * Math.cos(angleRadians),
        y: centerY + radius * Math.sin(angleRadians)
    };
}

/**
 * Shuffle an array (Fisher-Yates algorithm)
 */
function shuffleArray(array) {
    const result = [...array];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
function formatNumber(num) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

/**
 * Format time in seconds to MM:SS format
 */
function formatTime(seconds) {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Ease in-out function (smooth acceleration and deceleration)
 */
function easeInOut(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
}

/**
 * Get a random element from an array
 */
function randomArrayElement(array) {
    return array[Math.floor(Math.random() * array.length)];
}

/**
 * Check if a value is between min and max (inclusive)
 */
function isBetween(value, min, max) {
    return value >= min && value <= max;
}

/**
 * Calculate the Manhattan distance between two points
 */
function manhattanDistance(x1, y1, x2, y2) {
    return Math.abs(x2 - x1) + Math.abs(y2 - y1);
}  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\index.html 
======================================== 
 
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Massive RTS Game</title>
    <link rel="stylesheet" href="styles.css">
    <!-- Socket.IO client library -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="resourcesPanel" class="panel">
                <!-- Resources will be displayed here -->
            </div>
            <div id="minimap" class="panel">
                <!-- Minimap will be displayed here -->
            </div>
            <div id="controlPanel" class="panel">
                <!-- Control buttons will be displayed here -->
            </div>
        </div>
    </div>

    <!-- Game scripts -->
    <script src="/src/utils/helpers.js"></script>
    <script src="/src/map/Tile.js"></script>
    <script src="/src/map/Map.js"></script>
    <script src="/src/entities/Entity.js"></script>
    <script src="/src/entities/Unit.js"></script>
    <script src="/src/entities/Building.js"></script>
    <script src="/src/game/Config.js"></script>
    <script src="/src/game/Camera.js"></script>
    <script src="/src/game/InputHandler.js"></script>
    <script src="/src/game/Renderer.js"></script>
    <script src="/src/game/Multiplayer.js"></script>
    <script src="/src/game/Game.js"></script>
    <script>
        // Initialize the game when the window loads
        window.onload = function() {
            const game = new Game();
            game.start();
        };
    </script>
</body>
</html>  
 
 
======================================== 
FILE: C:\Users\Garrett\Documents\massive-rts\public\styles.css 
======================================== 
 
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #222;
    color: #fff;
    overflow: hidden;
}

.game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
    background-color: #000;
}

.ui-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allow clicks to pass through to canvas */
}

.panel {
    pointer-events: auto; /* Make panels clickable */
    background-color: rgba(0, 0, 0, 0.7);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
}

#resourcesPanel {
    position: absolute;
    top: 10px;
    left: 220px;
    width: 200px;
}

#minimap {
    position: absolute;
    top: 10px;
    left: 10px;
    width: 200px;
    height: 200px;
}

#controlPanel {
    position: absolute;
    bottom: 10px;
    left: 10px;
    width: 200px;
}

.control-btn {
    display: block;
    width: 100%;
    padding: 8px 12px;
    margin-bottom: 8px;
    background-color: #2a6496;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    text-align: center;
    transition: background-color 0.2s;
}

.control-btn:hover {
    background-color: #3a7db5;
}

.control-btn:active {
    background-color: #1a5486;
}  
 
 
======================================== 
FILE: package.json 
======================================== 
 
{
  "name": "massive-rts",
  "version": "0.1.0",
  "description": "A browser-based RTS game with massively multiplayer capabilities",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "client": "http-server -c-1 -p 8080",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "rts",
    "game",
    "multiplayer",
    "browser",
    "html5",
    "canvas"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "canvas": "^3.1.0",
    "express": "^4.18.2",
    "socket.io": "^4.7.2",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "http-server": "^14.1.1",
    "nodemon": "^3.0.1"
  }
}
 
 
